{"data":[{"id":"Prospector_bandit","category":"Security","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"Bandit tool","description":"Bandit is a tool designed to find common security issues in Python code.","explanation":"# Bandit\n\nBandit is a tool designed to find common security issues in Python code. To do this Bandit processes each file, builds an AST from it, and runs appropriate plugins against the AST nodes. Once Bandit has finished scanning all the files it generates a report.\n\nBandit was originally developed within the OpenStack Security Project and later rehomed to PyCQA.\n\n## Notes on Codacy Bandit\n\nBandit is officially supported in Codady on its own. If you want better configurability, we suggest disabling Bandit in Prospector and using the \"Bandit\" tool in Codacy. If however, you prefer the Prospector default settings, you can disable the Codacy Bandit tool and use it from Prospector.","timeToFix":5},{"id":"Prospector_dodgy","category":"Security","level":"Error","severityLevel":"Error","enabled":true,"parameters":[],"title":"dodgy tool","subCategory":"InsecureStorage","description":"Dodgy is a very basic tool to detect things such as accidental passwords or secret keys hard coded into files.","explanation":"# dodgy\n\nDodgy is a very basic tool to run against your codebase to search for \"dodgy\" looking values. It is a series of simple regular expressions designed to detect things such as accidental SCM diff checkins, or passwords or secret keys hard coded into files.\n\nWhile this is primarily aimed at open source projects (for whom a publicly available secret key is pretty dangerous), it can also be used in private projects, with the caveat that it will point out things which are not a problem for private projects and is not configurable enough currently to change that.","timeToFix":5},{"id":"Prospector_frosted","category":"CodeStyle","level":"Info","severityLevel":"Info","enabled":false,"parameters":[],"title":"frosted tool","description":"Frosted is a fork of pyflakes that aims at more open contribution from the outside public, a smaller more maintainable code base, and a better Python checker for all.","explanation":"# Frosted\n\nFrosted is a fork of pyflakes (originally created by Phil Frost) that aims at more open contribution from the outside public, a smaller more maintainable code base, and a better Python checker for all. It currently cleanly supports Python 2.6 - 3.4 using pies (https://github.com/timothycrosley/pies) to achieve this without ugly hacks and/or py2to3.","timeToFix":5},{"id":"Prospector_mccabe","category":"CodeStyle","level":"Info","severityLevel":"Info","enabled":true,"parameters":[],"title":"mccabe tool","description":"McCabe is a complexity checker for Python.","timeToFix":5},{"id":"Prospector_mypy","category":"CodeStyle","level":"Info","severityLevel":"Info","enabled":false,"parameters":[],"title":"mypy tool","description":"Mypy is an experimental optional static type checker for Python that aims to combine the benefits of dynamic typing and static typing.","explanation":"# mypy\n\nMypy is an optional static type checker for Python that aims to combine the benefits of dynamic (or \"duck\") typing and static typing. Mypy combines the expressive power and convenience of Python with a powerful type system and compile-time type checking. Mypy type checks standard Python programs; run them using any Python VM with basically no runtime overhead.","timeToFix":5},{"id":"Prospector_pep257","category":"CodeStyle","level":"Info","severityLevel":"Info","enabled":true,"parameters":[],"title":"pep257 tool","description":"pep257 is a static analysis tool for checking compliance with Python PEP 257.","explanation":"# PEP 257 docstring style checker\n\npep257 is a static analysis tool for checking compliance with Python PEP 257.\n\nThe framework for checking docstring style is flexible, and custom checks can be easily added, for example to cover NumPy docstring conventions.","timeToFix":5},{"id":"Prospector_pep8","category":"CodeStyle","level":"Info","severityLevel":"Info","enabled":false,"parameters":[],"title":"pep8 tool","description":"pep8 is a tool that validates Python code against the PEP 8 Style Guide.","timeToFix":5},{"id":"Prospector_pydocstyle","category":"CodeStyle","level":"Info","severityLevel":"Info","enabled":true,"parameters":[],"title":"pydocstyle tool","description":"pydocstyle is a static analysis tool for checking compliance with Python docstring conventions.","timeToFix":5},{"id":"Prospector_pyflakes","category":"CodeStyle","level":"Info","severityLevel":"Info","enabled":true,"parameters":[],"title":"pyflakes tool","description":"A simple program which checks Python source files for errors.","explanation":"# pyflakes\n\nA simple program which checks Python source files for errors.\n\nPyflakes analyzes programs and detects various errors. It works by parsing the source file, not importing it, so it is safe to use on modules with side effects. Itâ€™s also much faster.","timeToFix":5},{"id":"Prospector_pylint","category":"CodeStyle","level":"Info","severityLevel":"Info","enabled":false,"parameters":[],"title":"Pylint tool","description":"Pylint is the most comprehensive static analysis tool for Python. It is extremely thorough and is the source of most messages that prospector outputs.","explanation":"# Pylint\n\nPylint is the most comprehensive static analysis tool for Python. It is extremely thorough and is the source of most messages that prospector outputs.\n\n## Notes on Codacy Pylint\n\nPylint is officially supported in Codady on its own. If you want better configurability, we suggest disabling Pylint in Prospector and using the \"Pylint\" tool in Codacy. If however, you prefer the Prospector default settings, you can disable the Codacy Pylint tool and use it from Prospector.","timeToFix":5},{"id":"Prospector_pyroma","category":"CodeStyle","level":"Info","severityLevel":"Info","enabled":false,"parameters":[],"title":"pyroma tool","description":"pyroma gives a rating of how well a Python project complies with the best practices of the Python packaging ecosystem.","explanation":"# pyroma\n\nPyroma rhymes with aroma, and is a product aimed at giving a rating of how well\na Python project complies with the best practices of the Python packaging\necosystem, primarily PyPI, pip, Distribute etc, as well as a list of issues that\ncould be improved.\n\nThe aim of this is both to help people make a project that is nice and usable,\nbut also to improve the quality of Python third-party software, making it easier\nand more enjoyable to use the vast array of available modules for Python.\n\n## Tests\n\nThis is the list of checks that are currently performed:\n\n* The package should have a name, a version and a Description.\n  If it does not, it will receive a rating of 0.\n\n* The version number should be a string. A floating point number will\n  work with distutils, but most other tools will fail.\n\n* The version number should comply to PEP386.\n\n* The description should be over 10 characters, and the long_description\n  should be over a 100 characters.\n\n* Pyroma will convert your long_description to HTML using Docutils, to\n  verify that it is possible. This guarantees pretty formatting of your\n  description on PyPI. As long as Docutils can convert it, this passes,\n  even if there are warnings or error in the conversion. These warnings\n  and errors are printed to stdout so you will see them.\n\n  NB! Currently this doesn't change the rating, this is because Docutils\n  no longer raises an error during this process, so I have to rewrite the\n  test. Once it's reinstated, incorrect syntax will be fatal.\n\n* You should have the following meta data fields filled in:\n  classifiers, keywords, author, author_email, url and license.\n\n* You should have classifiers specifying the supported Python versions.\n\n* You should have a classifier specifying the project license.\n\n* If you are checking on a PyPI package, and not a local directory or\n  local package, pyroma will check the number of owners the package has\n  on PyPI. It should be three or more, to minimize the \"Bus factor\",\n  the risk of the index owners suddenly going off-line for whatever reason.\n\n* If you are checking on a PyPI package, and not a local directory or\n  local package, pyroma will check that you have uploaded a source\n  distribution, and not just binary distributions.","timeToFix":5},{"id":"Prospector_vulture","category":"CodeStyle","level":"Info","severityLevel":"Info","enabled":false,"parameters":[],"title":"vulture tool","description":"Vulture finds unused code in Python programs.","explanation":"# Vulture - Find dead code\n\nVulture finds unused code in Python programs. This is useful for cleaning up and finding errors in large code bases. If you run Vulture on both your library and test suite you can find untested code.\n\nDue to Python's dynamic nature, static code analyzers like Vulture are likely to miss some dead code. Also, code that is only called implicitly may be reported as unused. Nonetheless, Vulture can be a very helpful tool for higher code quality.\n\n## Features\n\n- fast: uses static code analysis\n- tested: tests itself and has complete test coverage\n- complements pyflakes and has the same output syntax\n- sorts unused classes and functions by size with --sort-by-size\n- supports Python 2.7 and Python >= 3.5","timeToFix":5}],"pagination":{"limit":100,"total":12}}
