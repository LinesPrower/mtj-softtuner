{"data":[{"id":"shellcheck_SC2100","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"Use `$((..))` for arithmetics, e.g. `i=$((i + 2))`","description":"Use `$((..))` for arithmetics, e.g. `i=$((i + 2))`","explanation":"## Use `$((..))` for arithmetics, e.g. `i=$((i + 2))`\n\n### Problematic code:\n\n```sh\ni=3\ni=i+2\n```\n\n### Correct code:\n\n```sh\ni=3\ni=$((i + 2))\n```\n\n### Rationale:\n\nUnlike most languages, variable assignments (almost) always assigns strings and not expressions. In the example code, `i` will become the string `i+2` instead of the intended `5`. \n\nTo instead evaluate a mathematical expressions, use `$((..))` as in the correct code.\n\n### Exceptions:\n\nIf you wanted to assign a literal string, quote it:\n\n    description=\"friendly-looking\"\n\nShellCheck (as of v0.5) doesn't recognize Bash/Ksh numeric variables created with `declare -i` where this syntax is valid. Using `$((..))` still works, but you can also [[ignore]] this warning.\n\n### Related resources:\n\n* Help by adding links to BashFAQ, StackOverflow, man pages, POSIX, etc!\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2100)"},{"id":"shellcheck_SC2101","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"Named class needs outer [], e.g. [[:digit:]\\].","description":"Named class needs outer [], e.g. [[:digit:]\\].","explanation":"# Named class needs outer [], e.g. [[:digit:]\\].\n\n### Problematic code:\n\n```sh\ngzip file[:digit:]*.txt\n```\n\n### Correct code:\n\n```sh\ngzip file[[:digit:]]*.txt\n```\n\n### Rationale:\n\nPredefined character groups are supposed to be used inside character ranges. `[:digit:]` matches one of \"digt:\" just like `[abc]` matches one of \"abc\". `[[:digit:]]` matches a digit.\n\n### Exceptions\n\nWhen passing an argument to `tr` which parses these by itself without relying on globbing, you should quote it instead, e.g. `tr -d '[:digit:]'`\n\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2101)"},{"id":"shellcheck_SC2102","category":"CodeStyle","level":"Info","severityLevel":"Info","enabled":false,"parameters":[],"title":"Ranges can only match single chars (mentioned due to duplicates).","description":"Ranges can only match single chars (mentioned due to duplicates).","explanation":"## Ranges can only match single chars (mentioned due to duplicates).\n\n### Problematic code:\n\n```sh\necho [100-999].txt\n```\n\n### Correct code:\n\n```sh\necho [1-9][0-9][0-9].txt\n```\n### Rationale:\n\nShellCheck found a glob range expression (such as `[a-z]`) that contains multiple of the same character.\n\nRange expressions can only be used to match a single character in a given set, so `[ab]` and `[abba]` will both match the same thing: either one `a` or one `b`. \n\nHaving multiple of the same character often means you're trying to match more than one character, such as in the problematic example where someone tried to match any number from 100 to 999. Instead, it matches a single digit just like `[0-9].txt`, and specifies 0, 1 and 9 multiple times.\n\nIn Bash, most uses can be rewritten using [extglob](https://mywiki.wooledge.org/glob#extglob) and/or [brace expansion](https://mywiki.wooledge.org/BraceExpansion). For example:\n\n```sh\ncat *.[dev,prod,test].conf   # Doesn't work\ncat *.{dev,prod,test}.conf   # Works in bash\ncat *.@(dev|prod|test).conf  # Works in bash with `shopt -s extglob`\n```\n\nIn POSIX sh, you may have to write multiple globs, one after the other:\n\n```sh\ncat *.dev.conf *.prod.conf *.test.conf\n```\n\n### Exceptions:\n\nThere is currently a bug in which a range expression whose contents is a variable gets parsed verbatim, e.g. `[$foo]`. In this case, either ignore the warning or make the square brackets part of the variable contents instead.\n\nv0.7.2 and below would unintentionally show this warning for subscripts in arrays in `[[ -v array[xx] ]]` and other dereferencing  operators. In these versions, you can either [[ignore]] the message or quote the word (as in `[[ -v 'array[xx]' ]]`)\n\n### Related resources:\n\n* Help by adding links to BashFAQ, StackOverflow, man pages, POSIX, etc!\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2102)"},{"id":"shellcheck_SC2103","category":"CodeStyle","level":"Info","severityLevel":"Info","enabled":false,"parameters":[],"title":"Use a ( subshell ) to avoid having to cd back.","description":"Use a ( subshell ) to avoid having to cd back.","explanation":"# Use a ( subshell ) to avoid having to cd back.\n\n### Problematic code:\n\n```sh\nfor dir in */\ndo\n  cd \"$dir\"\n  convert index.png index.jpg\n  cd ..\ndone\n```\n\n\n### Correct code:\n\n```sh\nfor dir in */\ndo\n  (\n  cd \"$dir\" || exit\n  convert index.png index.jpg\n  )\ndone\n```\n\nor\n\n```sh\nfor dir in */\ndo\n  cd \"$dir\" || exit\n  convert index.png index.jpg\n  cd ..\ndone\n```\n\n### Rationale:\n\nWhen doing `cd dir; somestuff; cd ..`, `cd dir` can fail when permissions are lacking, if the dir was deleted, or if `dir` is actually a file.\n\nIn this case, `somestuff` will run in the wrong directory and `cd ..` will take you to an even more wrong directory. In a loop, this will likely cause the next `cd` to fail as well, propagating this error and running these commands far away from the intended directories.\n\nCheck `cd`s exit status and/or use subshells to limit the effects of `cd`.\n\n### Exceptions\n\nIf you set variables you can't use a subshell. In that case, you should definitely check the exit status of `cd`, which will also silence this suggestion.\n\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2103)"},{"id":"shellcheck_SC2104","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"In functions, use return instead of break.","description":"In functions, use return instead of break.","explanation":"## In functions, use return instead of break.\n\n### Problematic code:\n\n```sh\nfoo() {\n  if [[ -z $1 ]]\n  then\n    break\n  fi\n  echo \"Hello $1\"\n}\n```\n\n### Correct code:\n\n```sh\nfoo() {\n  if [[ -z $1 ]]\n  then\n    return 1\n  fi\n  echo \"Hello $1\"\n}\n```\n### Rationale:\n\n`break` or `continue` are used to abort or continue a loop, and are not the right way to exit a function. Use `return` instead.\n\n### Exceptions:\n\nThe `break` or `continue` may be intended for a loop that calls the function:\n\n```\n# Rarely valid\nfoo() { break; echo $?; }\nwhile true; do foo; done\n```\n\nThis is undefined behavior in POSIX sh. Different shells do different things.\n\nWhen the function is called from a loop:\n\n* `ksh` keeps going and `$?` is 0.\n* `bash` version 4.4+ prints an error \"break: only meaningful in a \\`for', \\`while', or \\`until' loop\", the function keeps going, and `$?` is 0. \n* `bash` versions before 4.4, will return from the function, break the loop calling the function, or exit a subshell if there's one in between.\n* `dash`, BusyBox `ash`: like above.\n\nWhen the function is not called from a loop:\n\n* All `bash` versions print an error \"break: only meaningful in a \\`for', \\`while', or \\`until' loop\", the function keeps going, and `$?` is 0. \n* `ksh`, `dash` and `ash` silently keep going and `$?` is 0.\n\nDue to the many different implementations, many of which are not helpful, it's recommended to use proper flow control. A typical solution is making sure the function `return`s success/failure, and calling `myfunction || break` in the loop.\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2104)"},{"id":"shellcheck_SC2105","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"`break` is only valid in loops","description":"`break` is only valid in loops","explanation":"## `break` is only valid in loops\n\n### Problematic code:\n\n```sh\ncase \"$1\" in\n    -v)\n       verbose=1\n       break\n       ;;\n    -d)\n       debug=1\nesac\n```\n\n### Correct code:\n\n```sh\ncase \"$1\" in\n    -v)\n       verbose=1\n       ;;\n    -d)\n       debug=1\nesac\n```\n### Rationale:\n\n`break` or `continue` was found outside a loop. These statements are only valid in loops. In particular, `break` is not required in `case` statements as there is no implicit fall-through.\n\nTo return from a function or sourced script, use `return`. To exit a script, use `exit`.\n\n### Exceptions:\n\nIt's possible to `break`/`continue` in a function without a loop. The call will then affect the loop -- if any -- that the function is invoked from. This is obviously not good coding practice.\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2105)"},{"id":"shellcheck_SC2106","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"SC2106: This only exits the subshell caused by the pipeline.","description":"SC2106: This only exits the subshell caused by the pipeline.","explanation":"## SC2106: This only exits the subshell caused by the pipeline.\n\n### Problematic code:\n\n```sh\nfor i in a b c; do\n  echo hi | grep -q bye | break\ndone\n```\n\n### Correct code:\n\n```sh\nfor i in a b c; do\n  echo hi | grep -q bye || break\ndone\n```\n### Rationale:\n\nThe most common cause of this issue is probably using a single `|` when `||` was intended.  The reason this message appears, though, is that a construction like this, intended to surface a failure inside of a loop:\n\n```sh\nfor i in a b c; do false | break; done; echo ${PIPESTATUS[@]}\n```\n\nmay appear to work:\n```\n$ for i in a b c; do false | break; done; echo ${PIPESTATUS[@]}\n1 0\n```\n\nWhat's actually happening, though, becomes clear if we add some `echo`s; the entire loop completes, and the `break` has no effect.\n\n```sh\n$ for i in a b c; do echo $i; false | break; done; echo ${PIPESTATUS[@]}\na\nb\nc\n1 0\n$ for i in a b c; do false | break; echo $i; done; echo ${PIPESTATUS[@]}\na\nb\nc\n0\n```\n\nBecause bash processes pipelines by creating subshells, control statements like `break` only take effect in the subshell.\n\n### Related resources:\n\n* Contrast with the related, but different, problem in [this link](https://unix.stackexchange.com/questions/166546/bash-cannot-break-out-of-piped-while-read-loop-process-substitution-works).\n* [Bash Reference Manual: Pipelines](https://www.gnu.org/software/bash/manual/bash.html#Pipelines), esp.:\n     > Each command in a pipeline is executed in its own subshell.\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2106)"},{"id":"shellcheck_SC2107","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"Instead of [ a && b ], use [ a ] && [ b ].","description":"Instead of [ a && b ], use [ a ] && [ b ].","explanation":"## Instead of [ a && b ], use [ a ] && [ b ].\n\n### Problematic code:\n\n```sh\n[ \"$1\" = \"-v\" && -z \"$2\" ]\n```\n\n### Correct code:\n\n```sh\n[ \"$1\" = \"-v\" ] && [ -z \"$2\" ]\n```\n\n### Rationale:\n\n`&&` can not be used in a `[ .. ]` test expression. Instead, make two `[ .. ]` expressions and put the `&&` between them.\n\n### Exceptions:\n\nNone.\n\n### Related resources:\n\n* [Bash Pitfalls: [ \"$foo\" = bar && \"$bar\" = foo ]](https://mywiki.wooledge.org/BashPitfalls#pf6)\n* [StackOverflow: using and (&&) operator in if statement bash script\n](https://stackoverflow.com/questions/16396146/using-and-operator-in-if-statement-bash-script/16396181)\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2107)"},{"id":"shellcheck_SC2108","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"In [\\[..]], use && instead of -a.","description":"In [\\[..]], use && instead of -a.","explanation":"## In [\\[..]], use && instead of -a.\n\n### Problematic code:\n\n```sh\n[[ \"$1\" = \"-v\" -a -z \"$2\" ]]\n```\n\n### Correct code:\n\n```sh\n[[ \"$1\" = \"-v\" && -z \"$2\" ]]\n```\n\n### Rationale:\n\n`-a` for logical AND is not supported in a `[[ .. ]]` expression. Use `&&` instead.\n\n### Exceptions:\n\nNone.\n\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2108)"},{"id":"shellcheck_SC2109","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"Instead of [ a || b ], use [ a ] || [ b ].","description":"Instead of [ a || b ], use [ a ] || [ b ].","explanation":"## Instead of [ a || b ], use [ a ] || [ b ].\n\n### Problematic code:\n\n```sh\n[ \"$1\" = \"-v\" || \"$1\" = \"-help\" ]\n```\n\n### Correct code:\n\n```sh\n[ \"$1\" = \"-v\" ] || [ \"$1\" = \"-help\" ]\n```\n\n### Rationale:\n\n`||` cannot be used in a `[ .. ]` test expression. Instead, make two `[ .. ]` expressions and put the `||` between them.\n\n### Exceptions:\n\nNone.\n\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2109)"},{"id":"shellcheck_SC2110","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"In [\\[..]], use || instead of -o.","description":"In [\\[..]], use || instead of -o.","explanation":"## In [\\[..]], use || instead of -o.\n\n### Problematic code:\n\n```sh\n[[ \"$1\" = \"-v\" -o \"$1\" = \"-help\" ]]\n```\n\n### Correct code:\n\n```sh\n[[ \"$1\" = \"-v\" || \"$1\" = \"-help\" ]]\n```\n\n### Rationale:\n\n`-o` for logical OR is not supported in a `[[ .. ]]` expression. Use `||` instead.\n\n### Exceptions:\n\nNone.\n\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2110)"},{"id":"shellcheck_SC2112","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"'function' keyword is non-standard. Delete it.","description":"'function' keyword is non-standard. Delete it.","explanation":"## 'function' keyword is non-standard. Delete it.\n\n### Problematic code:\n\n```sh\n#!/bin/sh\nfunction hello() {\n  echo \"Hello World\"\n}\n```\n\n### Correct code:\n\n```sh\n#!/bin/sh\nhello() {\n  echo \"Hello World\"\n}\n```\n\n### Rationale:\n\n`function` is a non-standard keyword that can be used to declare functions in Bash and Ksh.\n\nIn POSIX `sh` and `dash`, a function is instead declared without the `function` keyword as in the correct example. \n\n### Exceptions:\n\nNone.\n\n### Related resources:\n\n* Help by adding links to BashFAQ, StackOverflow, man pages, POSIX, etc!\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2112)"},{"id":"shellcheck_SC2113","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"`function` keyword is non-standard. Use `foo()` instead of `function foo`.","description":"`function` keyword is non-standard. Use `foo()` instead of `function foo`.","explanation":"## `function` keyword is non-standard. Use `foo()` instead of `function foo`.\n\n### Problematic code:\n\n```sh\n#!/bin/sh\nfunction hello {\n    echo \"Hello World\"\n}\n```\n\n### Correct code:\n\n```sh\n#!/bin/sh\nhello() {\n    echo \"Hello World\"\n}\n```\n\n### Rationale:\n\n`function` is a non-standard keyword that can be used to declare functions in Bash and Ksh.\n\nIn POSIX `sh` and `dash`, a function is defined without a `function` keyword. Instead, the function name is followed by `()` as in the correct example.\n\n### Exceptions:\n\nNone\n\n### Related resources:\n\n* Help by adding links to BashFAQ, StackOverflow, man pages, POSIX, etc!\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2113)"},{"id":"shellcheck_SC2114","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"Warning: deletes a system directory.","description":"Warning: deletes a system directory.","explanation":"## Warning: deletes a system directory.\n\n### Problematic code:\n\n```sh\nrm -rf /usr /lib/nvidia-current/xorg/xorg\n```\n\n### Correct code:\n\n```sh\nrm -rf /usr/lib/nvidia-current/xorg/xorg\n```\n\n### Rationale:\n\nThe example line of code was an actual bug in the [Bumblebee NVIDIA driver](https://github.com/MrMEEE/bumblebee-Old-and-abbandoned/commit/a047be85247755cdbe0acce6f1dafc8beb84f2ac).\n\nDue to an accidental space, it deleted `/usr` instead of just the particular directory.\n\n### Exceptions:\n\nIf you do intend to delete a system directory, such as when working in a chroot or initramfs, you can disable this message with a directive: \n\n```sh\n# shellcheck disable=SC2114\nrm -rf /usr \n```\n\nPrevious versions of shellcheck, up to and including 0.4.6, would ignore `rm` statements containing a `--` (an arbitrary convention). This is no longer the case.\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2114)"},{"id":"shellcheck_SC2115","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"Use \"${var:?}\" to ensure this never expands to /* .","description":"Use \"${var:?}\" to ensure this never expands to /* .","explanation":"## Use \"${var:?}\" to ensure this never expands to /* .\n\n### Problematic code:\n\n```sh\nrm -rf \"$STEAMROOT/\"*\n```\n\n### Correct code:\n\n```sh\nrm -rf \"${STEAMROOT:?}/\"*\n```\n\n### Rationale:\n\nIf `STEAMROOT` is empty, this will [end up deleting everything](https://github.com/ValveSoftware/steam-for-linux/issues/3671) in the system's root directory.\n\nUsing `:?` will cause the command to fail if the variable is null or unset. Similarly, you can use `:-` to set a default value if applicable.\n\nIn the case command substitution, assign to a variable first and then use `:?`. This is relevant even if the command seems simple and obviously correct, since forks and execs can fail due to external system limits and conditions, resulting in a blank substitution.\n\nFor more details about `:?` see the \"Parameter Expansion\" section of the Bash man page.\n### Exceptions:\n\nNone.\n\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2115)"},{"id":"shellcheck_SC2116","category":"CodeStyle","level":"Info","severityLevel":"Info","enabled":false,"parameters":[],"title":"SC2116 Useless echo? Instead of 'cmd $(echo foo)', just use 'cmd foo'.","description":"SC2116 Useless echo? Instead of 'cmd $(echo foo)', just use 'cmd foo'.","explanation":"## SC2116 Useless echo? Instead of 'cmd $(echo foo)', just use 'cmd foo'.\n\n### Problematic code:\n\n```sh\ngreeting=$(echo \"Hello, $name\")\n# or\ntar czf \"$(echo \"$(date +%F).tar.gz\")\" *\n```\n\n### Correct code:\n\n```sh\ngreeting=\"Hello, $name\"\n# or\ntar czf \"$(date +%F).tar.gz\" *\n```\n\n### Rationale:\n\nYou appear to be using `echo` to write a value to stdout, and then using `$(..)` or `` `..` `` to capture the value again. This is as pointless as mailing yourself a postcard: you already have what you want, so there's no need to send it on a round trip.\n\nYou can just replace `$(echo myvalue)` with `myvalue`.\n\n### Exceptions\n\nSometimes this pattern is used because of side effect of `echo` or expansions. For example, here `$(echo ..)` is used to expand a glob.\n```\nglob=\"*.png\"\nfiles=\"$(echo $var)\"\n```\n\nThe `echo` is not useless, but this code is problematic because it concatenates filenames by spaces. This will break filenames containing spaces and other characters later when the list is split again. Better options are:\n\n* Arrays, if supported by the shell: `files=( $glob ); echo \"The first file is ${files[0]}\"`\n* Positional parameters when possible: `set -- $glob; echo \"The first file is $1\"`\n* Delaying expansion until it's needed: `for file in $glob; do ...`\n\nAll three methods will let you avoid issues with special characters in filenames.\n\nAs another example, here `$(echo ..)` is used to expand escape sequences:\n```\nunexpanded='var\\tvalue'\nexpanded=\"$(echo \"$var\")\"\n```\n\nIn this case, use `printf` instead. It's well defined with regard to escape sequences. \n\nFinally, if you really do want to concatenate a series of elements by a character like space, consider doing it explicitly with `for` or `printf` (e.g. `printf '%s\\n' $glob`).\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2116)"},{"id":"shellcheck_SC2117","category":"CodeStyle","level":"Info","severityLevel":"Info","enabled":false,"parameters":[],"title":"To run commands as another user, use su -c or sudo.","description":"To run commands as another user, use su -c or sudo.","explanation":"## To run commands as another user, use su -c or sudo.\n\n### Problematic code:\n\n```sh\nwhoami\nsu\nwhoami\n```\n\n### Correct code:\n\n```sh\nwhoami\nsudo whoami\n```\n\n### Rationale:\n\nIt's commonly believed that `su` makes a session run as another user. In reality, it starts an entirely new shell, independent of the one currently running your script.\n\n`su; whoami` will start a root shell and wait for it to exit before running `whoami`. It will not start a root shell and then proceed to run `whoami` in it.\n\nTo run commands as another user, use `sudo some command` or `su -c 'some command'`. `sudo` is preferred when available, as it doesn't require additional quoting and can be configured to run passwordless if desired.\n\n\n### Exceptions\n\nIf you're aware of the above and want to e.g. start an interactive shell for a user, feel free to ignore this message.\n\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2117)"},{"id":"shellcheck_SC2119","category":"CodeStyle","level":"Info","severityLevel":"Info","enabled":false,"parameters":[],"title":"Use foo \"$@\" if function's $1 should mean script's $1.","description":"Use foo \"$@\" if function's $1 should mean script's $1.","explanation":"# Use foo \"$@\" if function's $1 should mean script's $1.\n\nSee companion warning [[SC2120]].\n\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2119)"},{"id":"shellcheck_SC2120","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"foo references arguments, but none are ever passed.","description":"foo references arguments, but none are ever passed.","explanation":"# foo references arguments, but none are ever passed.\n\n### Problematic code:\n\n```sh\nsayhello() {\n  echo \"Hello $1\"\n}\nsayhello\n```\n\n`./myscript World` just prints \"Hello \" instead of \"Hello World\".\n\n### Correct code:\n\n```sh\nsayhello() {\n  echo \"Hello $1\"\n}\nsayhello \"$@\"\n```\n\n`./myscript World` now prints \"Hello World\".\n\n### Rationale:\n\nIn a function, `$1` and up refers to the function's parameters, not the script's parameters.\n\nIf you want to process your script's parameters in a function, you have to explicitly pass them. You can do this with `myfunction \"$@\"`.\n\nNote that `\"$@\"` refers to the current context's positional parameters, so if you call a function from a function, you have to pass in `\"$@\"` to both of them:\n\n```sh\nfirst() { second \"$@\"; }\nsecond() { echo \"The first script parameter is: $1\"; }\nfirst \"$@\"\n```\n\n### Exceptions\n\nIf the parameters are optional and you currently just don't want to use them, you can ignore this message. In versions strictly greater than v0.6.0, ignoring SC2120 on a function will also disable SC2119 on each of the call sites.\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2120)"},{"id":"shellcheck_SC2121","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"To assign a variable, use just 'var=value', no 'set ..'.","description":"To assign a variable, use just 'var=value', no 'set ..'.","explanation":"# To assign a variable, use just 'var=value', no 'set ..'.\n\n### Problematic code:\n\n```sh\nset var=42\nset var 42\n```\n\n### Correct code:\n\n```sh\nvar=42\n```\n\n### Rationale:\n\n`set` is not used to set or assign variables in Bourne shells. It's used to set shell options and positional parameters.\n\nTo assign variables, use `var=value` with no `set` or other qualifiers.\n\n### Exceptions\n\nIf you actually do want to set positional parameters, simply quoting them or using `--` will make shellcheck stop warning, e.g. `set -- var1 var2` or `set \"foo=bar\"`.\n\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2121)"},{"id":"shellcheck_SC2122","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":">= is not a valid operator. Use '! a < b' instead.","description":">= is not a valid operator. Use '! a < b' instead.","explanation":"## >= is not a valid operator. Use '! a < b' instead.\n\n### Problematic code:\n\n```sh\n[[ a &lt;= b ]]\n```\n\n### Correct code:\n\n```sh\n[[ ! a > b ]]\n```\n\n### Rationale:\n\nThe operators `<=` and `>=` are not supported by Bourne shells. Instead of \"less than or equal\", rewrite as \"not greater than\".\n\n### Exceptions\n\nNone\n\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2122)"},{"id":"shellcheck_SC2123","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"PATH is the shell search path. Use another name.","description":"PATH is the shell search path. Use another name.","explanation":"## PATH is the shell search path. Use another name.\n\n### Problematic code:\n\n```sh\nPATH=/my/dir\ncat \"$PATH/myfile\"\n```\n\n### Correct code:\n\nGood practice: always use lowercase for unexported variables.\n\n```sh\npath=/my/dir\ncat \"$path/myfile\"\n```\n\nBad practice: use another uppercase name.\n\n```sh\nMYPATH=/my/dir\ncat \"$MYPATH/myfile\"\n```\n\n### Rationale:\n\n`PATH` is where the shell looks for the commands it executes. By inadvertently overwriting it, the shell will be unable to find commands (like `cat` in this case).\n\nYou get this warning when ShellCheck suspects that you didn't meant to overwrite it (because it's a single path with no path separators).\n\nBest shell scripting practice is to always use lowercase variable names to avoid accidentally overwriting exported and internal variables.\n\n### Exceptions\n\nIf you're aware of the above and really do want to set your shell search path to `/my/dir`, you can ignore this warning.\n\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2123)"},{"id":"shellcheck_SC2124","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"Assigning an array to a string! Assign as array, or use * instead of @ to concatenate.","description":"Assigning an array to a string! Assign as array, or use * instead of @ to concatenate.","explanation":"## Assigning an array to a string! Assign as array, or use * instead of @ to concatenate.\n\n### Problematic code:\n\n```sh\n# Want to store multiple elements in var\nvar=$@\nfor i in $var; do ..; done\n```\n\nor\n\n```sh\nset -- Hello World\n# Want to concatenate multiple elements into a single string\nmsg=$@\necho \"You said $msg\"\n```\n\n### Correct code:\n\n```sh\n# Bash: use an array variable\nvar=( \"$@\" )\nfor i in \"${var[@]}\"; do ..; done\n\n# POSIX sh: without array support, one possible workaround\n# is to store elements concatenated with a delimiter (here linefeed/newline)\nvar=$(printf '%s\\n' \"$@\")\nprintf '%s\\n' \"$var\" | while IFS='' read -r line; do ..; done\n```\n\nor\n\n```sh\n#!/bin/sh\nset -- Hello World\n# Explicitly concatenates all the array elements into a single string\nmsg=$*\necho \"You said $msg\"\n```\n\n### Rationale:\n\nArrays and `$@` can contain multiple elements. Simple variables contain only one. When assigning multiple elements to one element, the default behavior depends on the shell (bash concatenates with spaces, zsh concatenates with first char of `IFS`).\n\nSince doing this usually indicates a bug, ShellCheck warns and asks you to be explicit about what you want.\n\nIf you want to assign N elements as N elements in Bash or Ksh, use an array, e.g. `myArray=( \"$@\" )`.\n\nDash and POSIX sh do not support arrays. In this case, either concatenate the values with some delimiter that you can split on later (the example uses linefeeds and splits them back up with a `while read` loop), or keep the values as positional parameters without putting them in an intermediate variable. \n\nIf you want to assign N elements as 1 element by concatenating them, use `*` instead of `@`, e.g. `myVar=${myArray[*]}` (this separates elements with the first character of `IFS`, usually space).\n\nThe same is true for `${@: -1}`, which results in 0 or 1 elements: `var=${*: -1}` assigns the last element or an empty string.\n\n### Exceptions\n\nNone.\n\n### Adding an element to an array may trigger this warning when you forget the parenthesis.\n```\nfilelist=\"${filelist[@]}\" \"$filename\"\n```\nWhat was meant is:\n```\nfilelist=(\"${filelist[@]}\" \"$filename\")\n```\nNote: This syntax is compatible with older shells;\nin later shells (bash 3.1+ and zsh 4.2+), you can do `filelist+=(\"$filename\")`.\n\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2124)"},{"id":"shellcheck_SC2125","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"Brace expansions and globs are literal in assignments. Quote it or use an array.","description":"Brace expansions and globs are literal in assignments. Quote it or use an array.","explanation":"## Brace expansions and globs are literal in assignments. Quote it or use an array.\n\n### Problematic code:\n\n```sh\nfoo={1..9}\necho \"$foo\"\n```\n```sh\nfoo=\"/some/path/*\"\necho \"$foo\"\n```\n\n### Correct code:\n\n```sh\nfoo=( {1..9} )\necho \"${foo[@]}\"\n```\n```sh\nfoo=(/some/path/*)\necho \"${foo[@]}\"\n```\n\nNote that either of these will trigger SC3030 (\"In POSIX sh, array references are undefined\") if you are using `sh` and not e.g. `bash`.\n\n### Rationale:\n\n`echo *.png {1..9}` expands to all png files and numbers from 1 to 9, but `var=*.png` or `var={1..9}` will just assign the literal strings `'*.png'` and `'{1..9}'`.\n\nTo make the variable contain all png files or 1 through 9, use an array as demonstrated.\n\nIf you intended to assign these values as literals, quote them (e.g. `var=\"*.png\"`).\n\n### Exceptions\n\nNone.\n\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2125)"},{"id":"shellcheck_SC2126","category":"CodeStyle","level":"Info","severityLevel":"Info","enabled":false,"parameters":[],"title":"Consider using `grep -c` instead of `grep | wc`","description":"Consider using `grep -c` instead of `grep | wc`","explanation":"## Consider using `grep -c` instead of `grep | wc`\n\n### Problematic code:\n\n```sh\ngrep foo | wc -l\n```\n\n### Correct code:\n\n```sh\ngrep -c foo\n```\n\n#### For multiple files\n\nInstead of:\n\n```sh\ngrep foo *.log | wc -l\n```\n\nYou can pipe all the file contents into `grep` (passing the files directly to `grep` causes `-c` to print each file's count separately, rather than the total):\n\n```sh\ncat *.log | grep foo -c\n```\n\n### Rationale:\n\nThis is purely a stylistic issue. `grep` can count lines without piping to `wc`.\n\nOften this number is only used to see whether there are matches (i.e. `== 0`). In these cases it's clearer and more efficient to use `grep -q` and check its exit status:\n\n```sh\nif grep -q pattern file; then\n  echo \"The file contains the pattern\"\nfi\n```\n\nAlso note that in `foo | grep bar | wc -l`, `wc` will mask the exit code of `grep` by default (i.e. without `set -o pipefail`), and always return success. If replacing with `foo | grep -c bar`, `grep` will exit non-zero when there are no matches. This is generally desirable (see above), but may require handling when used with `set -e`.\n\n### Exceptions\n\nIf you find piping to `wc` is clearer in a given situation it's fine to [[ignore]] this error.\n\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2126)"},{"id":"shellcheck_SC2128","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"Expanding an array without an index only gives the first element.","description":"Expanding an array without an index only gives the first element.","explanation":"## Expanding an array without an index only gives the first element.\n\n### Problematic code:\n\n```sh\nmyarray=(foo bar)\nfor f in $myarray\ndo\n  cat \"$f\"\ndone\n```\n\n### Correct code:\n\n```sh\nmyarray=(foo bar)\nfor f in \"${myarray[@]}\"\ndo\n  cat \"$f\"\ndone\n```\n\n### Rationale:\n\nWhen referencing arrays, `$myarray` is equivalent to `${myarray[0]}` -- it results in only the first of multiple elements.\n\nTo get all elements as separate parameters, use the index `@` (and make sure to double quote). In the example, `echo \"${myarray[@]}\"` is equivalent to `echo \"foo\" \"bar\"`.\n\nTo get all elements as a single parameter, concatenated by the first character in `IFS`, use the index `*`. In the example, `echo \"${myarray[*]}\"` is equivalent to `echo \"foo bar\"`.\n\n### Bugs:\n\nThere is a [known issue](https://github.com/koalaman/shellcheck/issues/1309) with this check's handling of `local` variables, causing ShellCheck to flag variables that were previously declared as arrays, even if they are in different scopes.\n\nThe easiest workaround is to simply use different variable names. Alternatively, you can [[ignore]] the check.\n\nIt is also possible to satisfy ShellCheck by declaring the `local` variable separately from assigning to it, e.g.:\n\n```sh\nfoo () {\n   local -a baz\n   baz+=(\"foo\" \"bar\")\n   echo \"${baz[@]}\"\n}\n\nbar () {\n   local baz # ShellCheck gets confused if these lines are merged as local baz=\"qux\"\n   baz=\"qux\"\n   echo \"$baz\"\n}\n```\n\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2128)"},{"id":"shellcheck_SC2129","category":"CodeStyle","level":"Info","severityLevel":"Info","enabled":false,"parameters":[],"title":"Consider using { cmd1; cmd2; } >> file instead of individual redirects.","description":"Consider using { cmd1; cmd2; } >> file instead of individual redirects.","explanation":"## Consider using { cmd1; cmd2; } >> file instead of individual redirects.\n\n### Problematic code:\n\n```sh\necho foo >> file\ndate >> file\ncat stuff  >> file\n\n```\n\n### Correct code:\n\n```sh\n{\n  echo foo\n  date\n  cat stuff\n} >> file\n```\n\n### Rationale:\n\nRather than adding `>> something` after every single line, you can simply group the relevant commands and redirect the group. So the file has to be opened and closed only once and it means a performance gain.\n\n### Exceptions:\n\nThis is mainly a stylistic issue, and can freely be ignored.\n\n### Related resources:\n\n* [BashFaq: How can I redirect the output of multiple commands at once?](https://mywiki.wooledge.org/BashFAQ/014)\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2129)"},{"id":"shellcheck_SC2139","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"This expands when defined, not when used. Consider escaping.","description":"This expands when defined, not when used. Consider escaping.","explanation":"## This expands when defined, not when used. Consider escaping.\n\n### Problematic code:\n\n```sh\nalias whereami=\"echo $PWD\"\n```\n\n### Correct code:\n\n```sh\nalias whereami='echo $PWD'\n```\n\n### Rationale:\n\nWith double quotes, this particular alias will be defined as `echo /home/me`, so it will always print the same path. This is rarely intended.\n\nBy using single quotes or escaping any expansions, we define the alias as `echo $PWD`, which will be expanded when we use the alias. This is the far more common use case.\n\nNote that even if you expect that the variable will never change, it may still be better to quote it. This prevents a second round of evaluation later:\n\n    default=\"Can't handle failure, aborting\"\n    trap \"echo $default; exit 1\" err\n    false \n\nThe trap now has a syntax error, because instead of running `echo $default`, it runs `echo Can't handle ..` which has an unmatched single quote. Avoid early expansion unless you're equally comfortable putting `eval` in there.\n\n### Exceptions\n\nIf you don't mind that your alias definition is expanded at define time (and its result expanded again at evaluation time), you can ignore this warning.\n\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2139)"},{"id":"shellcheck_SC2140","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"Word is on the form \"A\"B\"C\" (B indicated). Did you mean \"ABC\" or \"A\\\\\"B\\\\\"C\"?","description":"Word is on the form \"A\"B\"C\" (B indicated). Did you mean \"ABC\" or \"A\\\\\"B\\\\\"C\"?","explanation":"##  Word is on the form \"A\"B\"C\" (B indicated). Did you mean \"ABC\" or \"A\\\\\"B\\\\\"C\"?\n\n### Problematic code:\n\n```sh\necho \"<img src=\"foo.png\" />\" > file.html\n```\n\nor\n\n```sh\nexport \"var\"=\"42\"\n```\n\n### Correct code:\n\n```sh\necho \"<img src=\\\"foo.png\\\" />\" > file.html\n```\n\nor\n\n```sh\nexport \"var=42\"\n```\n\n\n### Rationale:\n\nThis warning triggers when an unquoted literal string is found suspiciously sandwiched between two double quoted strings.\n\nThis usually indicates one of:\n\n- quotes that were supposed to be nested, and therefore need to be escaped (like the `<img>` example)\n- quotes that are just plain unnecessary (like the `export` example).\n\nWithout escaping, the inner two quotes of the sandwich (the end quote of the first section and the start quote of the second section) are no-ops. The following two statements are identical, so the quotes that were intended to be part of the html output are instead removed:\n\n```sh\necho \"<img src=\"foo.png\" />\" > file.html\necho \"<img src=foo.png />\" > file.html\n```\n\nSimilarly, these statements are identical, but work as intended:\n\n```sh\nexport \"var\"=\"42\"\nexport \"var=42\"\n```\n\n### Exceptions\n\nIf you know that the quotes are ineffectual but you prefer it stylistically, you can ignore this message.\n\nIt's common not to realize that double quotes can span multiple elements, or to stylistically prefer to quote individual variables. For example, these statements are identical, but the first is laboriously and redundantly quoted:\n\n```sh\nhttp://\"$user\":\"$password\"@\"$host\"/\"$path\"\n\"http://$user:$password@$host/$path\"\n```\n\nWhen ShellCheck detects the first style (i.e. the double quotes include only a single element each), it will suppress the warning.\n\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2140)"},{"id":"shellcheck_SC2141","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"Did you mean IFS=$'\\t' ?","description":"Did you mean IFS=$'\\t' ?","explanation":"## Did you mean IFS=$'\\t' ?\n\n### Problematic code:\n\n```sh\nIFS=\"\\t\"\n```\n\n### Correct code:\n\n```sh\nIFS=$'\\t'\n```\nor POSIX:\n\n```sh\nIFS=\"$(printf '\\t')\"\n```\n\n\n### Rationale:\n\n`IFS=\"\\t\"` splits on backslash and the letter \"t\". `IFS=$'\\t'` splits on tab.\n\n### Exceptions\n\nIt's extremely rare to want to split on the letter \"n\" or \"t\", rather than linefeed or tab.\n\n\n### Related resources\n\nSee https://github.com/koalaman/shellcheck/wiki/SC1012\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2141)"},{"id":"shellcheck_SC2142","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"Aliases can't use positional parameters. Use a function.","description":"Aliases can't use positional parameters. Use a function.","explanation":"## Aliases can't use positional parameters. Use a function.\n\n### Problematic code:\n\n```sh\nalias archive='mv \"$@\" /backup'\n```\n\n### Correct code:\n\n```sh\narchive() { mv \"$@\" /backup; }\n\n```\n\n### Rationale:\n\nAliases just substitute the start of a command with something else. They therefore can't use positional parameters, such as `$1`. Rewrite your alias as a function.\n\n### Exceptions\n\nIf your alias ends up quoting the value, e.g. `alias cut_first=\"awk '{print \\$1}'\"`, you can technically [[ignore]] this error. However, you should consider turning this alias into a more readable function instead: `cut_first() { awk '{print $1}' \"$@\"; }`\n\nYou can also [[ignore]] this warning if you intentionally referenced the positional parameters of its relevant context, knowing that it won't refer to the parameters of the alias itself. For example, `alias whatisthis='echo \"This is $0 -$-\" #'` will show the shell name with flags, i.e. `This is dash -smi` or `This is bash -himBs`, and is correct usage because it does not intend for `$0` to reflect anything related to the `whatisthis` alias or its invocation.\n\n\n### Related resources:\n\n* [BashFaq: How can I make an alias that takes an argument?](https://mywiki.wooledge.org/BashFAQ/080)\n* [StackOverflow: Make a Bash alias that takes a parameter?](https://stackoverflow.com/questions/7131670/make-a-bash-alias-that-takes-a-parameter)\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2142)"},{"id":"shellcheck_SC2143","category":"CodeStyle","level":"Info","severityLevel":"Info","enabled":false,"parameters":[],"title":"Use grep -q instead of comparing output with [ -n .. ].","description":"Use grep -q instead of comparing output with [ -n .. ].","explanation":"## Use grep -q instead of comparing output with [ -n .. ].\n### Problematic code:\n\n```sh\nif [ \"$(find . | grep 'IMG[0-9]')\" ]\nthen\n  echo \"Images found\"\nfi\n```\n\n### Correct code:\n\n```sh\nif find . | grep -q 'IMG[0-9]'\nthen\n  echo \"Images found\"\nfi\n```\n\n### Rationale:\n\nThe problematic code has to iterate the entire directory and read all matching lines into memory before making a decision.\n\nThe correct code is cleaner and stops at the first matching line, avoiding both iterating the rest of the directory and reading data into memory.\n\n### Exceptions\n\nThe `pipefail` bash option may interfere with this rewrite, since the `if` will now in effect be evaluating the statuses of all commands instead of just the last one. Be careful using them together.\n\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2143)"},{"id":"shellcheck_SC2144","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"-e doesn't work with globs. Use a for loop.","description":"-e doesn't work with globs. Use a for loop.","explanation":"##  -e doesn't work with globs. Use a for loop.\n\n### Problematic code:\n\n```sh\nif [ -e dir/*.mp3 ]\nthen\n  echo \"There are mp3 files.\"\nfi\n```\n\n### Correct code:\n\n```sh\nfor file in dir/*.mp3\ndo\n  if [ -e \"$file\" ]\n  then\n    echo \"There are mp3 files\"\n    break\n  fi\ndone\n```\n\n### Rationale:\n\n`[ -e file* ]` only works if there's 0 or 1 matches. If there are multiple, it becomes `[ -e file1 file2 ]`, and the test fails.\n\n`[[ -e file* ]]` doesn't work at all.\n\nInstead, use a for loop to expand the glob and check each result individually.\n\nIf you are looking for the existence of a directory, do:\n\n```sh\nfor f in /path/to/your/files*; do\n\n    ## Check if the glob gets expanded to existing files.\n    ## If not, f here will be exactly the pattern above\n    ## and the exists test will evaluate to false.\n    [ -e \"$f\" ] && echo \"files do exist\" || echo \"files do not exist\"\n\n    ## This is all we needed to know, so we can break after the first iteration\n    break\ndone\n```\n\n### Exceptions\n\nIf filename expansion (globbing) is disabled (`set -f`), then the `[` statement works as expected.\n\n### Related resources:\n\n* [BashFaq: How can I check whether a directory is empty or not? How do I check for any *.mpg files, or count how many there are?](https://mywiki.wooledge.org/BashFAQ/004)\n* [sh - Check if a file exists with wildcard in shell script - Stack Overflow](https://stackoverflow.com/a/6364244/2309247)\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2144)"},{"id":"shellcheck_SC2145","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"Argument mixes string and array. Use * or separate argument.","description":"Argument mixes string and array. Use * or separate argument.","explanation":"## Argument mixes string and array. Use * or separate argument.\n\n### Problematic code:\n\n```sh\nprintf \"Error: %s\\n\" \"Bad parameters: $@\"\n```\n\n### Correct code:\n\n```sh\nprintf \"Error: %s\\n\" \"Bad parameters: $*\"\n```\n\n### Problematic code 2:\n\n```sh\nprintf \"Error: %s\\n\" \"Bad parameters: ${ARRAY_VAR[@]}\"\n```\n\n### Correct code 2:\n\n```sh\nprintf \"Error: %s\\n\" \"Bad parameters: \" \"${ARRAY_VAR[@]}\"\n```\n\n### Rationale:\n\nThe behavior when concatenating a string and array is rarely intended. The preceding string is prefixed to the first array element, while the succeeding string is appended to the last one. The middle array elements are unaffected.\n\nE.g., with the parameters `foo`,`bar`,`baz`, `\"--flag=$@\"` is equivalent to the three arguments `\"--flag=foo\" \"bar\" \"baz\"`.\n\nIf the intention is to concatenate all the array elements into one argument, use `$*`. This concatenates based on `IFS`.\n\nIf the intention is to provide each array element as a separate argument, put the array expansion in its own argument.\n\n### Exceptions\n\nThe POSIX specified behavior of `$@` (and by extension arrays) as part of other strings is often unexpected:\n\n> if the parameter being expanded was embedded within a word, the first field shall be joined with the beginning part of the original word and the last field shall be joined with the end part of the original word. In all other contexts the results of the expansion are unspecified. If there are no positional parameters, the expansion of '@' shall generate zero fields, even when '@' is within double-quotes; however, if the expansion is embedded within a word which contains one or more other parts that expand to a quoted null string, these null string(s) shall still produce an empty field, except that if the other parts are all within the same double-quotes as the '@', it is unspecified whether the result is zero fields or one empty field.\n\nIf you're aware of this and intend to take advantage of it, you can ignore this warning. However, you can also usually also rewrite it into a less surprising form. For example, here's a wrapper script that uses this behavior to substitute certain commands by defining a function for them:\n\n    #!/bin/sh\n    fixed_fgrep() { grep -F \"$@\"; }\n    fixed_echo() { printf '%s\\n' \"$*\"; }\n    fixed_seq() { echo \"seq is not portable\" >&2; return 1; }\n\n    if command -v \"fixed_$1\" > /dev/null 2>&1\n    then\n      # shellcheck disable=SC2145   # I know how fixed_\"$@\" behaves and it's correct!\n      fixed_\"$@\"\n    else\n      \"$@\"\n    fi\n\nHere's the same script without relying on this behavior:\n\n    #!/bin/sh\n    fixed_fgrep() { grep -F \"$@\"; }\n    fixed_echo() { printf '%s\\n' \"$*\"; }\n    fixed_seq() { echo \"seq is not portable\" >&2; return 1; }\n\n    cmd=\"$1\"\n    shift\n\n    if command -v \"fixed_$cmd\" > /dev/null 2>&1\n    then\n     # Perhaps more straight forward with fewer surprises:\n      \"fixed_$cmd\" \"$@\"\n    else\n      \"$cmd\" \"$@\"\n    fi\n\n\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2145)"},{"id":"shellcheck_SC2146","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"This action ignores everything before the -o. Use \\\\( \\\\) to group.","description":"This action ignores everything before the -o. Use \\\\( \\\\) to group.","explanation":"## This action ignores everything before the -o. Use \\\\( \\\\) to group.\n\n### Problematic code:\n\n```sh\nfind . -name '*.avi' -o -name '*.mkv' -exec cp {} /media \\;\n```\n\n### Correct code:\n\n```sh\nfind . \\( -name '*.avi' -o -name '*.mkv' \\) -exec cp {} /media \\;\n```\n\n### Rationale:\n\nIn `find`, two predicates with no operator between them is considered a logical, short-circuiting AND (as if using `-a`). E.g., `-name '*.mkv' -exec ..` is the same as `-name '*.mkv' -a -exec ..`.\n\n`-a` has higher precedence than `-o`, so `-name '*.avi' -o -name '*.mkv' -a -exec ..` is equivalent to `-name '*.avi' -o \\( -name '*.mkv' -a -exec .. \\)`.\n\nIn other words, the problematic code means \"if name matches `*.avi`, do nothing. Otherwise, if it matches `*.mkv`, execute a command.\".\n\nIn the correct code, we use `\\( \\)` to group to get the evaluation order we want. The correct code means \"if name matches `*.avi` or `*.mkv`, then execute a command\", which was what was intended.\n\n### Exceptions\n\nIf you're aware of this, you can either ignore this error or group to make it explicit. For example, to decompress all gz files except tar.gz, you can use:\n\n```sh\nfind . -name '*.tar.gz' -o \\( -name '*.gz' -exec gzip -d {} + \\)\n```\n\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2146)"},{"id":"shellcheck_SC2147","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"Literal tilde in PATH works poorly across programs.","description":"Literal tilde in PATH works poorly across programs.","explanation":"##  Literal tilde in PATH works poorly across programs.\n\n### Problematic code:\n\n```sh\nPATH=\"$PATH:~/bin\"\n```\n\n### Correct code:\n\n```sh\nPATH=\"$PATH:$HOME/bin\"\n```\n\n### Rationale:\n\nHaving literal `~` in PATH is a bad idea. Bash handles it, but nothing else does.\n\nThis means that even if you're always using Bash, you should avoid it because any invoked program that relies on PATH will effectively ignore those entries.\n\nFor example, `make` may say `foo: Command not found` even though `foo` works fine from the shell and Make and Bash both use the same PATH. You'll get similar messages from any non-bash scripts invoked, and `whereis` will come up empty.\n\nUse `$HOME` or full path instead.\n\n### Exceptions\n\nIf your directory name actually contains a literal tilde, you can ignore this message.\n\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2147)"},{"id":"shellcheck_SC2148","category":"ErrorProne","level":"Error","severityLevel":"Error","enabled":true,"parameters":[],"title":"Tips depend on target shell and yours is unknown. Add a shebang.","description":"Tips depend on target shell and yours is unknown. Add a shebang.","explanation":"##  Tips depend on target shell and yours is unknown. Add a shebang.\n\n### Problematic code:\n\n```sh\necho \"$RANDOM\"   # Does this work?\n```\n\n### Correct code:\n\n```sh\n#!/bin/sh\necho \"$RANDOM\"  # Unsupported in sh. Produces warning.\n```\n\nor\n\n```sh\n#!/bin/bash\necho \"$RANDOM\"  # Supported in bash. No warnings.\n```\n\n### Rationale:\n\nDifferent shells support different features. To give effective advice, ShellCheck needs to know which shell your script is going to run on. You will get a different numbers of warnings about different things depending on your target shell.\n\nIf you add a shebang (e.g. `#!/bin/bash` as the first line), the OS will use this interpreter when the script is executed, and ShellCheck will use this shell when offering advice.\n\nIf you for any reason can't or won't add a shebang, there are multiple other ways to let shellcheck know which shell you're coding for:\n\n* Specify the shell using the `-s` or `--shell` flag, e.g. `shellcheck -s bash myfile`\n* Use a shellcheck [[directive]], adding `# shellcheck shell=ksh` before the first command in the file.\n* Give the script a `.bash`, `.ksh` or `.dash` extension (`.sh` will not assume `--shell=sh` since it's so generic)\n\n### Exceptions\n\nNone. Please either add a shebang, directive, extension or use `-s` to maximize ShellCheck's usefulness. \n[Source](https://github.com/koalaman/shellcheck/wiki/SC2148)"},{"id":"shellcheck_SC2150","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"-exec does not automatically invoke a shell. Use -exec sh -c .. for that.","description":"-exec does not automatically invoke a shell. Use -exec sh -c .. for that.","explanation":"## -exec does not automatically invoke a shell. Use -exec sh -c .. for that.\n\n### Problematic code:\n\n```sh\nfind . -type f -exec 'cat {} | wc -l' \\;\n```\n\n### Correct code:\n\n```sh\nfind . -type f -exec sh -c 'cat {} | wc -l' \\;         # Insecure\nfind . -type f -exec sh -c 'cat \"$1\" | wc -l' _ {} \\;  # Secure\n```\n\nSometimes the command can also be rewritten to not require `find` to invoke a shell:\n\n```sh\nfind . -type f -exec wc -l {} \\; | cut -d ' ' -f 1\n```\n\n### Rationale:\n\nfind `-exec` and `-execdir` uses `execve(2)` style semantics, meaning it expects an executable and zero or more arguments that should be passed to it.\n\nIt does not use `system(3)` style semantics, meaning it does not accept a shell command as a string, to be parsed and evaluated by the system's command interpreter.\n\nIf you want `find` to execute a shell command, you have to specify `sh` (or `bash`) as the executable, `-c` as first argument and your shell command as the second.\n\nTo prevent command injection, the filename can be passed as a separate argument to sh and referenced as a positional parameter.\n\n### Exceptions\n\nThis warning would trigger falsely if executing a program with spaces in the path, if no other arguments were specified.\n\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2150)"},{"id":"shellcheck_SC2151","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"Only one integer 0-255 can be returned. Use stdout for other data.","description":"Only one integer 0-255 can be returned. Use stdout for other data.","explanation":"## Only one integer 0-255 can be returned. Use stdout for other data.\n\n### Problematic code:\n\n```sh\nmyfunc() {\n  return foo bar\n}\n```\n\n### Correct code:\n\n```sh\nmyfunc() {\n  echo foo\n  echo bar\n  return 0\n}\n```\n\n### Rationale:\n\nIn bash, `return` can only be used to signal success or failure (0 = success, 1-255 = failure).\n\nTo return textual or multiple values from a function, write them to stdout and capture them with command substitution instead.\n\nSee [[SC2152]] for more information.\n\n### Exceptions:\n\nNone\n\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2151)"},{"id":"shellcheck_SC2152","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"Can only return 0-255. Other data should be written to stdout.","description":"Can only return 0-255. Other data should be written to stdout.","explanation":"## Can only return 0-255. Other data should be written to stdout.\n\n### Problematic code:\n\n```sh\nmyfunc() {\n  return \"Hello $USER\"\n}\n```\n\n### Correct code:\n\n```sh\nmyfunc() {\n  echo \"Hello $USER\"\n  return 0\n}\n```\n\n### Rationale:\n\nIn many languages, `return` is used to return from the function with a final result.\n\nIn sh/bash, `return` can only be used to signal success or failure (0 = success, 1-255 = failure), more akin to `throw/raise` in other languages.\n\nResults should instead be written to stdout and captured:\n\n```sh\nmessage=$(myfunc)\necho \"The function wrote: $message\"\n```\n\nIn functions that return small integers, such as getting the cpu temperature, the value should still be written to stdout. `return` should be reserved for error conditions, such as \"can't determine CPU temperature\". Error or failure messages should be written to stderr.\n\nNote in particular that `return -1` is equivalent to `return 255`, but that `return 1` is the more canonical way of expressing the first possible error code.\n\n### Exceptions:\n\nNone\n\n### Related resources:\n\n* [BashFaq: How do I return a string (or large number, or negative number) from a function?](https://mywiki.wooledge.org/BashFAQ/084) \"return\" only lets me give a number from 0 to 255.\n\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2152)"},{"id":"shellcheck_SC2153","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"Possible Misspelling: MYVARIABLE may not be assigned. Did you mean MY_VARIABLE?","description":"Possible Misspelling: MYVARIABLE may not be assigned. Did you mean MY_VARIABLE?","explanation":"## Possible Misspelling: MYVARIABLE may not be assigned. Did you mean MY_VARIABLE?\n\n### Problematic code:\n\n```sh\nMY_VARIABLE=\"hello world\"\necho \"$MYVARIABLE\"\n```\n\n### Correct code:\n\n```sh\nMY_VARIABLE=\"hello world\"\necho \"$MY_VARIABLE\"\n```\n\n### Rationale:\n\nShellCheck has noticed that you reference a variable that is not assigned in the script, but which has a name similar to another known variable. You should verify that the variable name is spelled correctly.\n\nNote: This error only triggers for environment variables (all uppercase variables), and only when they have names similar to another known variable in the script. If the variable is script-local, it should by convention have a lowercase name, and will in that case be caught by [SC2154] whether or not it resembles another name.\n\n### Exceptions:\n\nIf you've double checked and ensured that you did not intend to reference the specified variable, you can disable this message with a [[directive]]. The message will also not appear for guarded references like `${ENVVAR:-default}` or `${ENVVAR:?Unset error message here}`.\n\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2153)"},{"id":"shellcheck_SC2154","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"var is referenced but not assigned.","description":"var is referenced but not assigned.","explanation":"## var is referenced but not assigned.\n\n### Problematic code:\n\n```sh\nvar=name\nn=42\necho \"$var_$n.jpg\"   # overextended\n```\n\nor\n\n```sh\ntarget=\"world\"\necho \"hello $tagret\"  # misspelled\n```\n\nor\n\n```sh\necho \"Result: ${mycmd -a myfile}\"  # trying to execute commands\n```\n\n### Correct code:\n\n```sh\nvar=name\nn=42\necho \"${var}_${n}.jpg\"\n```\n\nor\n\n```sh\ntarget=\"world\"\necho \"hello $target\"\n```\n\nor\n\n```sh\necho \"Result: $(mycmd -a myfile)\"\n```\n\n### Rationale:\n\nShellCheck has noticed that you reference a variable that is not assigned. Double check that the variable is indeed assigned, and that the name is not misspelled.\n\nNote: This message only triggers for variables with lowercase characters in their name (`foo` and `kFOO` but not `FOO`) due to the standard convention of using lowercase variable names for unexported, local variables.\n\n### Exceptions:\n\nShellCheck intentionally does not attempt to figure out runtime or dynamic assignments like with `source \"$(date +%F).sh\"` or `eval var=value`. See [[SC2034]] for an extended discussion of why this is the case.\n\nIf you know for a fact that the variable is set, you can use `${var:?}` to fail if the variable is unset (or empty), initialize it to a default value if uninitialized with `: \"${var:=}\"`, or explicitly initialize/declare it with `var=\"\"` or `declare var`. You can also disable the message with a [[directive]].\n\n---\n\n## Read more:\n\nPOSIX - Parameter expansion:\n* https://stackoverflow.com/a/16753536/2309247\n* http://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_06_02\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2154)"},{"id":"shellcheck_SC2155","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"Declare and assign separately to avoid masking return values.","description":"Declare and assign separately to avoid masking return values.","explanation":"## Declare and assign separately to avoid masking return values.\n\n### Problematic code in the case of `export`:\n\n```sh\nexport foo=\"$(mycmd)\"\n```\n\n#### Correct code:\n\n```sh\nfoo=\"$(mycmd)\"\nexport foo\n```\n\n#### Rationale:\n\nIn the original code, the return value of `mycmd` is ignored, and `export` will instead always return true. This may prevent conditionals, `set -e` and traps from working correctly.\n\nWhen first marked for export and assigned separately, the return value of the assignment will be that of `mycmd`. This avoids the problem.\n\nNote that ShellCheck does not warn about masking of local read-only variables, such as `local -r foo=$(cmd)`, even though this also masks the return value. This is because the alternative `local foo; foo=$(cmd); local -r foo` is repetitive and cumbersome.\n\n#### Exceptions:\n\nIf you intend to ignore the return value of an assignment, you can either [[ignore]] this warning or use\n\n```sh\nfoo=$(mycmd) || true\nexport foo\n```\n\nShellcheck does not warn about `export foo=bar` because `bar` is a literal and not a command substitution with an independent return value. \n\n### Problematic code in the case of `local`:\n\n```sh\nlocal foo=\"$(mycmd)\"\n```\n\n#### Correct code:\n\n```sh\nlocal foo\nfoo=$(mycmd)\n```\n\n#### Rationale\n\nThe exit status of the command is overridden by the exit status of the creation of the local variable. For example:\n\n```bash\n$ f() { local foo=$(false) || echo foo; }; f\n$ f() { local foo; foo=$(false) || echo foo; }; f\nfoo\n```\n\n### Problematic code in the case of `readonly`:\n\n```sh\nreadonly foo=\"$(mycmd)\"\n```\n\n#### Correct code:\n\n```sh\nfoo=\"$(mycmd)\"\nreadonly foo\n```\n\n## Word splitting and quoting issue with dash, maybe others\n\nA serious quoting problem with dash is another reason to declare and assign separately. Dash is the [default, `/bin/sh` shell on Ubuntu](https://wiki.ubuntu.com/DashAsBinSh). More specifically, dash version 0.5.8-2.10 and others cannot run these two examples:\n```sh\nf(){ local e=$1; }\nf \"1 2\"\n\nexport g=$(printf '%s' \"foo 2\")\n``` \nWhile this runs fine in other shells, [dash doesn't treat any of these as assignments](http://mywiki.wooledge.org/BashPitfalls#local_var.3D.24.28cmd.29) and fails both like this:\n```\nlocal: 2: bad variable name\nexport: 2: bad variable name\n```\nThe direct workaround to this bug is to quote the right-hand-side of the assignment. Separating declaraction and assignment also makes this runs fine in any shell.\n\n(A rule to catch this problem is in the works at [#1556](https://github.com/koalaman/shellcheck/issues/1556)).\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2155)"},{"id":"shellcheck_SC2156","category":"Security","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"Injecting filenames is fragile and insecure. Use parameters.","subCategory":"CommandInjection","description":"Injecting filenames is fragile and insecure. Use parameters.","explanation":"## Injecting filenames is fragile and insecure. Use parameters.\n\n### Problematic code:\n\n```sh\nfind . -name '*.mp3' -exec sh -c 'i=\"{}\"; sox \"$i\" \"${i%.mp3}.wav\"' \\;\n```\n\n### Correct code:\n\n```sh\nfind . -name '*.mp3' -exec sh -c 'i=\"$1\"; sox \"$i\" \"${i%.mp3}.wav\"' shell {} \\;\n```\n\n### Rationale:\n\nIn the problematic example, the filename is passed by injecting it into a shell string. Any shell metacharacters in the filename will be interpreted as part of the script, and not as part of the filename. This can break the script and allow arbitrary code execution exploits.\n\nIn the correct example, the filename is passed as a parameter. It will be safely treated as literal text. Note that when using the shell command with `-c`, the first parameter to the shell command (in the example \"shell\") becomes `$0` in the shell command's environment, where it is used e.g. in shell error messages (you can set it to an arbitrary value, but it makes sense to set it to the shell's name). You should not use the first parameter to the shell command as a data processing parameter because you cannot, for example, access `$0` via `$*` in the shell command (because `$*` starts with `$1`), and as previously mentioned, `$0` is used in the shell command's error messages, which would be confusing.\n\n### Exceptions:\n\nNone.\n\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2156)"},{"id":"shellcheck_SC2157","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"Argument to implicit -n is always true due to literal strings.","description":"Argument to implicit -n is always true due to literal strings.","explanation":"## Argument to implicit -n is always true due to literal strings.\n(Or: Argument to -z is always false due to literal strings. )\n\n### Problematic code:\n\n```sh\nif [ \"$foo \" ]\nthen\n  echo \"this is always true because of the trailing space\"\nfi\n```\n\n### Correct code:\n\n```sh\nif [ \"$foo\" ]\nthen\n  echo \"correctly checks value\"\nfi\n```\n\n### Rationale:\n\nSince `[ str ]` and `[ -n str ]` check that the string is non-empty, any literal characters in the string -- including a space character like in the example -- will cause the test to always be true.\n\nEquivalently, since `[ -z str ]` checks that the string is empty, any literal character in the string will cause the test to always be false.\n\nDouble check the string: you may have added trailing characters, or bad quotes or syntax. Some examples include:\n\n* `[ \"$foo \" ]` like in the example, where the space becomes part of the string\n* `[ \"{$foo}\" ]` instead of `[ \"${foo}\" ]`, where the `{` becomes part of the string\n* `[ \"$foo -gt 0\" ]` instead of `[ \"$foo\" -gt \"0\" ]`, where the `-gt` becomes part of the string\n\n\n### Exceptions:\n\nNone.\n\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2157)"},{"id":"shellcheck_SC2158","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"[ false ] is true. Remove the brackets","description":"[ false ] is true. Remove the brackets","explanation":"## [ false ] is true. Remove the brackets\n\n### Problematic code:\n\n```sh\nif [ false ]\nthen\n  echo \"triggers anyways\"\nfi\n```\n\n### Correct code:\n\n```sh\nif false\nthen\n  echo \"never triggers\"\nfi\n```\n\n### Rationale:\n\n`[ str ]` checks whether `str` is non-empty. It doesn't matter if `str` is `false`, it will still be evaluated for non-emptyness.\n\nInstead, use the command `false` which -- as the manual puts it -- does nothing, unsuccessfully.\n\n### Exceptions:\n\nNone\n\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2158)"},{"id":"shellcheck_SC2159","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"[ 0 ] is true. Use 'false' instead","description":"[ 0 ] is true. Use 'false' instead","explanation":"## [ 0 ] is true. Use 'false' instead\n\n### Problematic code:\n\n```sh\nif [ 0 ]\nthen\n  echo \"always triggers\"\nfi\n```\n\n### Correct code:\n\n```sh\nif false\nthen\n  echo \"never triggers\"\nfi\n```\n\n### Rationale:\n\n`[ str ]` checks whether `str` is non-empty. It doesn't matter if `str` is `0`, it will still be evaluated for non-emptyness.\n\nInstead, use the command `false` which -- as the manual puts it -- does nothing, unsuccessfully.\n\n### Exceptions:\n\nNone\n\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2159)"},{"id":"shellcheck_SC2160","category":"CodeStyle","level":"Info","severityLevel":"Info","enabled":false,"parameters":[],"title":"Instead of '[ true ]', just use 'true'.","description":"Instead of '[ true ]', just use 'true'.","explanation":"## Instead of '[ true ]', just use 'true'.\n\n### Problematic code:\n\n```sh\nif [ true ]\nthen\n  echo \"always triggers\"\nfi\n```\n\n### Correct code:\n\n```sh\nif true\nthen\n  echo \"always triggers\"\nfi\n```\n\n### Rationale:\n\nThis is a stylistic suggestion to use `true` instead of `[ true ]`.\n\n`[ true ]` seems to suggest that the value \"true\" is somehow relevant to the statement. This is not the case, it doesn't matter. You can replace it with `[ false ]` or `[ wombat ]`, and it will still always be true:\n\nString  | In brackets  | Outside brackets\n--------|--------------|-----------------\ntrue    | true         | true\nfalse   | true         | false\nwombat  | true         | unknown command\n\nIt's therefore better to use it without brackets, so that the \"true\" actually matters.\n\n### Exceptions:\n\nNone.\n\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2160)"},{"id":"shellcheck_SC2161","category":"CodeStyle","level":"Info","severityLevel":"Info","enabled":false,"parameters":[],"title":"Instead of '[ 1 ]', use 'true'.","description":"Instead of '[ 1 ]', use 'true'.","explanation":"## Instead of '[ 1 ]', use 'true'.\n\n### Problematic code:\n\n```sh\nwhile [ 1 ]\ndo\n  echo \"infinite loop\"\ndone\n```\n\n### Correct code:\n\n```sh\nwhile true\ndo\n  echo \"infinite loop\"\ndone\n```\n\n### Rationale:\n\nThis is a stylistic suggestion to use `true` instead of `[ 1 ]`.\n\n`[ 1 ]` seems to suggest that the value \"1\" is somehow relevant to the statement. This is not the case: it doesn't matter. You can replace it with `[ 0 ]` or `[ wombat ]`, and it will still always be true.\n\nIf you instead use `true`, the value is actually considered and can be inverted by replacing with `false`.\n\nOn bash, you can also use `(( 1 ))`, which evaluates to true much like in C. `(( 0 ))` is similarly false.\n\n### Exceptions:\n\nNone.\n\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2161)"},{"id":"shellcheck_SC2162","category":"CodeStyle","level":"Info","severityLevel":"Info","enabled":false,"parameters":[],"title":"read without -r will mangle backslashes","description":"read without -r will mangle backslashes","explanation":"## read without -r will mangle backslashes\n\n### Problematic code:\n\n```sh\necho \"Enter name:\"\nread name\n```\n\n### Correct code:\n\n```sh\necho \"Enter name:\"\nread -r name\n```\n\n### Rationale:\n\nBy default, `read` will interpret backslashes before spaces and line feeds (i.e. you can use backslashes in your string as an escape character). This is rarely expected or desired.\n\nNormally you just want to read data _including backslashes_ which are part of the input string and have no special escape meaning, which is what `read -r` does. You should always use `-r` unless you have a good reason not to:\n\n> -r\n>\n> If this option is given, backslash does not act as an escape character.\n\nNote that [`read -r`](https://www.tldp.org/LDP/abs/html/internal.html#READR) will still strip leading and trailing spaces. `IFS=\"\" read -r` prevents this.\n\n### Exceptions:\n\nIf you want backslashes to affect field splitting and line terminators instead of being read, you can disable this message with a [[directive]].\n\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2162)"},{"id":"shellcheck_SC2163","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"This does not export 'FOO'. Remove $/${} for that, or use ${var?} to quiet.","description":"This does not export 'FOO'. Remove $/${} for that, or use ${var?} to quiet.","explanation":"## This does not export 'FOO'. Remove $/${} for that, or use ${var?} to quiet.\n\n### Problematic code:\n\n```sh\nMYVAR=foo\nexport $MYVAR\n```\n\n### Correct code:\n\n```sh\nMYVAR=foo\nexport MYVAR\n```\n\n### Rationale:\n\n`export` takes a variable name, but shellcheck has noticed that you give it an expanded variable instead. The problematic code does not export `MYVAR` but a variable called `foo` if any.\n\n### Exceptions:\n\nIf this is intentional and you do want to export `foo` instead of `MYVAR`, you can either use a directive:\n\n```sh\n# shellcheck disable=SC2163\nexport \"$MYVAR\"\n```\n\nOr after (but not including) version 0.4.7, take advantage of the fact that ShellCheck only warns when no parameter expansion modifiers are applied:\n\n```sh\nexport \"${MYVAR}\"    # ShellCheck warns\nexport \"${MYVAR?}\"   # No warning\n```\n\n`${MYVAR?}` fails when `MYVAR` is unset, which is fine since `export` would have failed too. The main side effect is an improved runtime error message in that case.\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2163)"},{"id":"shellcheck_SC2164","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"Use cd ... || exit in case cd fails.","description":"Use cd ... || exit in case cd fails.","explanation":"## Use cd ... || exit in case cd fails.\n\n### Problematic code:\n\n```sh\ncd generated_files\nrm -r *.c\n```\n```sh\nfunc(){\n  cd foo\n  do_something\n}\n```\n\n### Correct code:\n\n```sh\ncd generated_files || exit\nrm -r *.c\n```\n```sh\n# For functions, you may want to use return:\nfunc(){\n  cd foo || return\n  do_something\n}\n```\n\n### Rationale:\n\n`cd` can fail for a variety of reasons: misspelled paths, missing directories, missing permissions, broken symlinks and more.\n\nIf/when it does, the script will keep going and do all its operations in the wrong directory. This can be messy, especially if the operations involve creating or deleting a lot of files.\n\nTo avoid this, make sure you handle the cases when `cd` fails. Ways to do this include\n\n* `cd foo || exit` as suggested to abort immediately, reusing exit code from failed `cd` command\n* `cd foo || { echo \"Failure\"; exit 1; }` abort with custom message\n* `cd foo || ! echo \"Failure\"` omitting \"abort with custom message\"\n* `if cd foo; then echo \"Ok\"; else echo \"Fail\"; fi` for custom handling\n* `<(cd foo && cmd)` as an alternative to `<(cd foo || exit; cmd)` in `<(..)`, `$(..)` or `( )`\n\n### Exceptions:\n\nShellCheck does not give this warning when `cd` is on the left of a `||` or `&&`, or the condition of a `if`, `while` or `until` loop. Having a `set -e` command anywhere in the script will disable this message, even though it won't necessarily prevent the issue.\n\nIf you are accounting for `cd` failures in a way shellcheck doesn't realize, you can disable this message with a [[directive]].\n\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2164)"},{"id":"shellcheck_SC2165","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"This nested loop overrides the index variable of its parent.","description":"This nested loop overrides the index variable of its parent.","explanation":"## This nested loop overrides the index variable of its parent.\n\nAnd companion warning \"This parent loop has its index variable overridden.\"\n\n### Problematic code:\n\n```sh\nfor((i=0; i<10; i++))\ndo\n  for i in *\n  do\n    echo \"$i\"\n  done\ndone\n```\n\n### Correct code:\n\n```sh\nfor((i=0; i<10; i++))\ndo\n  for j in *\n  do\n    echo \"$j\"\n  done\ndone\n```\n\n### Rationale:\n\nWhen nesting loops, especially arithmetic for loops, using the same loop variable can cause unexpected results.\n\nIn the problematic code, `i` will contain the last filename from the inner loop, which will be interpreted as a value in the next iteration out the outer loop. This results in either an infinite loop or a syntax error, depending on whether the last filename is a valid shell variable name.\n\nIn nested for-in loops, variable merely shadow each other and won't cause infinite loops or syntax errors, but reusing the variable name is rarely intentional.\n\n### Exceptions:\n\nNone.\n\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2165)"},{"id":"shellcheck_SC2166","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"Prefer [ p ] && [ q ] as [ p -a q ] is not well defined.","description":"Prefer [ p ] && [ q ] as [ p -a q ] is not well defined.","explanation":"## Prefer [ p ] && [ q ] as [ p -a q ] is not well defined.\n\nAnd likewise, prefer `[ p ] || [ q ]` over `[ p -o q ]`.\n\n### Problematic code:\n\n```sh\n[ \"$1\" = \"test\" -a -z \"$2\" ]\n```\n\n### Correct code:\n\n```sh\n[ \"$1\" = \"test\" ] && [ -z \"$2\" ]\n```\n\n\n### Rationale:\n\n`-a` and `-o` to mean AND and OR in a `[ .. ]` test expression is not well defined, and can cause incorrect results when arguments start with dashes or contain `!`. [From POSIX](http://pubs.opengroup.org/onlinepubs/9699919799/utilities/test.html):\n\n>The XSI extensions specifying the -a and -o binary primaries and the '(' and ')' operators have been marked obsolescent. (Many expressions using them are ambiguously defined by the grammar depending on the specific expressions being evaluated.) Scripts using these expressions should be converted to the forms given below. Even though many implementations will continue to support these obsolescent forms, scripts should be extremely careful when dealing with user-supplied input that could be confused with these and other primaries and operators. Unless the application developer knows all the cases that produce input to the script, invocations like:\n>\n>    `test \"$1\" -a \"$2\"`\n>\n>should be written as:\n>\n>   `test \"$1\" && test \"$2\"`\n\n\nUsing multiple `[ .. ]` expressions with shell AND/OR operators `&&` and `||` is well defined and therefore preferred (but note that they have equal precedence, while `-a`/`-o` is unspecified but usually implemented as `-a` having higher precedence).\n\n### Exceptions:\n\nIf the shell variant being used is ksh derived (such as the bash shell) it will have the shell builtin command `[[ ... ]]`. This has the operators `&&`, `||`, `(`, `)`, `!` which safely avoid the ambiguity by noting which arguments were quoted and requiring the operators to be unquoted (except by the `[[ ... ]]` construct itself).\n\n### See also:\n* [Problems With the test Builtin: What Does -a Mean?](http://www.oilshell.org/blog/2017/08/31.html)\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2166)"},{"id":"shellcheck_SC2167","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"This parent loop has its index variable overridden.","description":"This parent loop has its index variable overridden.","explanation":"## This parent loop has its index variable overridden.\n\nSee companion warning [[SC2165]].\n\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2167)"},{"id":"shellcheck_SC2168","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"'local' is only valid in functions.","description":"'local' is only valid in functions.","explanation":"## 'local' is only valid in functions.\n\n### Problematic code:\n\n```sh\nlocal foo=bar\necho \"$foo\"\n```\n\n### Correct code:\n\n```sh\nfoo=bar\necho \"$foo\"\n```\n### Rationale:\n\nIn Bash, `local` can only be used in functions. In other contexts, it's an error.\n\n### Exceptions:\n\nIt's possible to source files containing `local` from a function context but not from any other context. This is not good practice, but in these cases you can [[ignore]] this error.\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2168)"},{"id":"shellcheck_SC2170","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"Invalid number for -eq. Use = to compare as string (or use $var to expand as a variable).","description":"Invalid number for -eq. Use = to compare as string (or use $var to expand as a variable).","explanation":"## Invalid number for -eq. Use = to compare as string (or use $var to expand as a variable).\n\n### Problematic code:\n\n```sh\nread -r n\nif [ n -lt 0 ]\nthen\n   echo \"bad input\"\nfi\n\nif [ \"$USER\" -eq root ]\nthen\n  echo \"You are root\"\nfi\n```\n\n### Correct code:\n\n```sh\nread -r n\nif [ \"$n\" -lt 0 ]        # Numerical comparison\nthen\n   echo \"bad input\"\nfi\n\nif [ \"$USER\" = root ]    # String comparison\nthen\n  echo \"You are root\"\nfi\n```\n### Rationale:\n\nYou are comparing a string value with a numerical operator, such as `-eq`, `-ne`, `-lt` or `-gt`. These only work for numbers.\n\nIf you want to compare the value as a string, switch to the equivalent string operator: `=`, `!=` `\\<` or `\\>`.\n\nIf you want to compare it as a number, such as `n=42; while [ n -gt 1024/8 ]; ..`, then keep the operator and expand the operands yourself with `$var` or `$((expr))`: `while [ \"$n\" -gt $((1024/8)) ]`\n\n### Exceptions:\n\nNone.\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2170)"},{"id":"shellcheck_SC2171","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"Found trailing ] outside test. Add missing [ or quote if intentional.","description":"Found trailing ] outside test. Add missing [ or quote if intentional.","explanation":"## Found trailing ] outside test. Add missing [ or quote if intentional.\n\n### Problematic code:\n\n```sh\nif foo -eq bar ]; then true; fi\n```\n\nor\n\n```sh\ntr -d ]\n```\n\n### Correct code:\n\n```sh\nif [ foo -eq bar ]; then true; fi\n```\n\nor\n\n```sh\ntr -d ']'\n```\n\n### Rationale:\n\nShellCheck found a non-test command that ends with `]` or `]]`.\n\nIf this was intended to be a test expression like in the first example, add the missing `[` or `[[`. \n\nIf the `]` was intended to be literal, like in `tr -d ]`, you can quote to make this obvious.\n\n### Exceptions:\n\n`tr -d ]` is valid and not different from `tr -d ']'`, so in these cases you can ignore the error instead.\n\n### Related resources:\n\n* Help by adding links to BashFAQ, StackOverflow, man pages, POSIX, etc!\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2171)"},{"id":"shellcheck_SC2172","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"Trapping signals by number is not well defined. Prefer signal names.","description":"Trapping signals by number is not well defined. Prefer signal names.","explanation":"## Trapping signals by number is not well defined. Prefer signal names.\n\n### Problematic code:\n\n```sh\ntrap myfunc 28\n```\n\n### Correct code:\n\n```sh\ntrap myfunc WINCH\n```\n### Rationale:\n\nSignal numbers can vary between platforms. Prefer signal names, which are fixed.\n\nSignal numbers 1, 2, 3, 6, 9, 14 and 15 are specified as parts of the optional POSIX XSI and ShellCheck will not warn about these. \n\n### Exceptions:\n\nNone.\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2172)"},{"id":"shellcheck_SC2173","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"SIGKILL/SIGSTOP can not be trapped.","description":"SIGKILL/SIGSTOP can not be trapped.","explanation":"## SIGKILL/SIGSTOP can not be trapped.\n\n### Problematic code:\n\n```sh\ntrap 'echo \"unkillable\"' KILL\n```\n\n### Correct code:\n\nNot applicable. This is not possible.\n\n### Rationale:\n\nSIGKILL and SIGSTOP can not be caught/ignored (according to POSIX and as implemented on platforms including Linux and FreeBSD). Trying to trap this signal has undefined results.\n\n### Exceptions:\n\nNone. If you come across one, please file an issue about it.\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2173)"},{"id":"shellcheck_SC2174","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"When used with -p, -m only applies to the deepest directory.","description":"When used with -p, -m only applies to the deepest directory.","explanation":"## When used with -p, -m only applies to the deepest directory.\n\n### Problematic code:\n\n```sh\nmkdir -p -m 0755 foo/bar/baz\n```\n\n### Correct code:\n\n```sh\nmkdir -p foo/bar/baz\nchmod 0755 foo/bar/baz foo/bar foo\n```\n\n### Rationale:\n\nWhen using `-m 0755`, the mode of the directory created will be set to 0755. When using `-p`, parent directories which do not exist will be created, but the mode specified by `-m` will only be used on the last directory. The parent directories will get their access mode the default way, via [umask(2)].\n\n[umask(2)]: http://man7.org/linux/man-pages/man2/umask.2.html\n\n### Exceptions:\n\nShellCheck does not warn if the path only has one component, as in `mkdir -p -m 0755 mydir`, but will not attempt to determine whether this applies for a variable as in `mkdir -p -m 0755 \"$mydir\"`. You can mkdir/chmod separately or [[ignore]] this message.\n\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2174)"},{"id":"shellcheck_SC2175","category":"CodeStyle","level":"Info","severityLevel":"Info","enabled":false,"parameters":[],"title":"Quote this invalid brace expansion since it should be passed literally to eval","description":"Quote this invalid brace expansion since it should be passed literally to eval","explanation":"## Quote this invalid brace expansion since it should be passed literally to eval\n\n### Problematic code:\n\n```sh\neval echo {1..$n}\n```\n\n### Correct code:\n\n```sh\neval \"echo {1..$n}\"\n```\n### Rationale:\n\nUsing `eval somecommand {1..$n}` depends both on bash silently failing to interpret the brace expansion, and on it passing failing brace expansions literally. \n\nRather than depending on these questionable features (which already behave differently in other shells), use the explicit, predictable way of passing values literally: quoting.\n\n### Exceptions:\n\nNone. \n[Source](https://github.com/koalaman/shellcheck/wiki/SC2175)"},{"id":"shellcheck_SC2176","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"'time' is undefined for pipelines. time single stage or bash -c instead.","description":"'time' is undefined for pipelines. time single stage or bash -c instead.","explanation":"## 'time' is undefined for pipelines. time single stage or bash -c instead.\n\n### Problematic code:\n\n```sh\ntime foo | bar\n```\n\n### Correct code:\n\nTo time the most relevant stage:\n\n```sh\nfoo | { time bar; }\n```\n\nTo time everything in a pipeline:\n\n```sh\ntime bash -c 'foo | bar'\n```\n\nNote that you can not use `time sh -c` to time an entire pipeline, because POSIX does not guarantee that anything other than the last stage is waited upon by the shell. \n\n### Rationale:\n\nThis behavior is explicitly left undefined [in POSIX](http://pubs.opengroup.org/onlinepubs/9699919799/utilities/time.html).\n\n### Exceptions:\n\nNone. This warning is not emitted in `ksh` or `bash` where `time` is defined for pipelines.\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2176)"},{"id":"shellcheck_SC2177","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"'time' is undefined for compound commands, use time sh -c instead.","description":"'time' is undefined for compound commands, use time sh -c instead.","explanation":"## 'time' is undefined for compound commands, use time sh -c instead.\n\n### Problematic code:\n\n```sh\ntime for i in *.bmp; do convert \"$i\" \"$i.png\"; done\n```\n\n### Correct code:\n\n```sh\ntime sh -c 'for i in *.bmp; do convert \"$i\" \"$i.png\"; done'\n```\n### Rationale:\n\n`time` is only defined for Simple Commands [by POSIX](http://pubs.opengroup.org/onlinepubs/9699919799/utilities/time.html). Timing loops, command groups and similar is not.\n\n### Exceptions:\n\nNone. If you use a shell that supports this (e.g. bash, ksh), specify this shell in the shebang.\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2177)"},{"id":"shellcheck_SC2178","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"Variable was used as an array but is now assigned a string.","description":"Variable was used as an array but is now assigned a string.","explanation":"## Variable was used as an array but is now assigned a string.\n\n### Problematic code:\n\n```sh\nflags[0]=\"-r\"\nflags[1]=\"--delete-after\"\n\nif [ \"$dryrun\" ]\nthen\n   flags=\"--dry-run\"\nfi\n\n```\n\n### Correct code:\n\n```sh\nflags[0]=\"-r\"\nflags[1]=\"--delete-after\"\n\nif [ \"$dryrun\" ]\nthen\n   flags=( \"--dry-run\" )\nfi\n```\n### Rationale:\n\nShellCheck noticed that you have used a variable as an array, but then assign it a string. `array=foo` is equivalent to `array[0]=foo`, and leaves the rest of the elements unaffected.\n\nIn the incorrect code, `\"${flags[@]}\"` would contain `--dry-run` `--delete-after`.\n\nTo set an array to only a single, given element, you should use `array=( foo )`.\n\nIn the correct code, `\"${flags[@]}\"` will contain `--dry-run` only. \n\nAnother possible cause is accidentally missing the `$` on a previous assignment: `var=(my command); var=bar` instead of `var=$(my command); var=bar`. If the variable is not intended to be an array, ensure that it's never assigned as one.\n\n### Bugs:\n\nThere is a [known issue](https://github.com/koalaman/shellcheck/issues/1309) with this check's handling of `local` variables, causing ShellCheck to flag variables that were previously declared as arrays, even if they are in different scopes.\n\nThe easiest workaround is to simply use different variable names. Alternatively, you can [[ignore]] the check.\n\nIt is also possible to satisfy ShellCheck by declaring the `local` variable separately from assigning to it, e.g.:\n\n```sh\nfoo () {\n   local -a baz\n   baz+=(\"foo\" \"bar\")\n   echo \"${baz[@]}\"\n}\n\nbar () {\n   local baz # ShellCheck gets confused if these lines are merged as local baz=\"qux\"\n   baz=\"qux\"\n   echo \"$baz\"\n}\n```\n\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2178)"},{"id":"shellcheck_SC2179","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"Use array+=(\"item\") to append items to an array.","description":"Use array+=(\"item\") to append items to an array.","explanation":"## Use array+=(\"item\") to append items to an array.\n\n### Problematic code:\n\n```sh\nvar=(one two)\nvar+=three\n```\n\n### Correct code:\n\n```sh\nvar=(one two)\nvar+=( three )\n```\n### Rationale:\n\nIt looks like you are trying to append a string to an array with `var+=string`. This instead appends to the first element of the array (equivalent to `var[0]+=three`).\n\nIn the problematic code, the array will therefore contain `onethree` `two`.\n\nInstead, append an array to the array with `var+=( elements )`. This will append the new items to the array.\n\nIn the correct code, it will contain `one` `two` `three` as expected.\n\n### Exceptions:\n\nIf ShellCheck mistakenly thinks the variable is an array when it's not (e.g. because the same name was used in a different context), you can ignore this error.\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2179)"},{"id":"shellcheck_SC2180","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"Bash does not support multidimensional arrays. Use 1D or associative arrays.","description":"Bash does not support multidimensional arrays. Use 1D or associative arrays.","explanation":"## Bash does not support multidimensional arrays. Use 1D or associative arrays.\n\n### Problematic code:\n\n```sh\nfoo[1][2]=bar\necho \"${foo[1][2]}\"\n```\n\n### Correct code:\n\nIn bash4, consider using associative arrays:\n```sh\ndeclare -A foo\nfoo[1,2]=bar\necho \"${foo[1,2]}\"\n```\n\nOtherwise, do your own index arithmetic:\n```sh\nsize=10\nfoo[1*size+2]=bar\necho \"${foo[1*size+2]}\"\n```\n\n### Rationale:\n\nBash does not support multidimensional arrays. Rewrite it to use 1D arrays. Associative arrays map arbitrary strings to values, and are therefore useful since you can construct keys like `\"1,2,3\"` or `\"val1;val2;val3\"` to index them.\n\n### Exceptions:\n\nNone.\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2180)"},{"id":"shellcheck_SC2181","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"Check exit code directly with e.g. 'if mycmd;', not indirectly with $?.","description":"Check exit code directly with e.g. 'if mycmd;', not indirectly with $?.","explanation":"## Check exit code directly with e.g. 'if mycmd;', not indirectly with $?.\n\n### Problematic code:\n\n```sh\nmake mytarget\n\nif [ $? -ne 0 ]\nthen\n  echo \"Build failed\"\nfi\n```\n\n### Correct code:\n\n```sh\nif ! make mytarget;\nthen\n  echo \"Build failed\"\nfi\n```\n### Rationale:\n\nRunning a command and then checking its exit status `$?` against 0 is redundant.\n\nInstead of just checking the exit code of a command, it checks the exit code of a command (e.g. `[`) that checks the exit code of a command.\n\nApart from the redundancy, there are other reasons to avoid this pattern:\n\n* Since the command and its status test are decoupled, inserting an innocent command like `echo \"make finished\"` after `make` will cause the `if` statement to silently start comparing `echo`'s status instead.\n* Scripts that run or are called with `set -e ` aka `errexit` will exit immediately if the command fails, even though they're followed by a clause that handles failure. \n* The value of `$?` is overwritten by `[`/`[[`, so you can't get the original value in the relevant then/else block (e.g. `if mycmd; then echo \"Success\"; else echo \"Failed with $?\"; fi`).\n\nTo check that a command returns success, use `if mycommand; then ...`.\n\nTo check that a command returns failure, use `if ! mycommand; then ...`. Notice that `!` will overwrite `$?` value.\n\nTo additionally capture output with command substitution: `if ! output=$(mycommand); then ...`\n\nThis also applies to `while`/`until` loops.\n\n### Exceptions:\n\nThe default Solaris 10 bourne shell does not support '!' outside of the test command (`if ! mycommand; then ...` returns `!: not found`)\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2181)"},{"id":"shellcheck_SC2182","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"This printf format string has no variables. Other arguments are ignored.","description":"This printf format string has no variables. Other arguments are ignored.","explanation":"## This printf format string has no variables. Other arguments are ignored.\n\n### Problematic code:\n\n```sh\nplace=\"world\"\nprintf hello $place\n```\n\n### Correct code:\n\n```sh\nplace=\"world\"\nprintf \"hello %s\\n\" \"$place\"\n```\n### Rationale:\n\nShellCheck has noticed that you're using a `printf` with multiple arguments, but where the first argument has no `%s` or equivalent variable placeholders.\n\n`echo` accepts zero or more strings to write, e.g. `echo hello world`.\n\n`printf` instead accepts one pattern/template with zero or more `%s`-style placeholders, and one argument for each placeholder.\n\nRewrite your command using the right semantics, otherwise all arguments after the first one will be ignored:\n\n    $ printf hello world\\\\n\n    hello\n\n    $ printf \"hello world\\n\"\n    hello world\n\n    $ printf \"hello %s\\n\" \"world\"\n    hello world\n\n### Exceptions:\n\nIf you wanted a no-op, use `:` instead.\n\n```sh\n: ${place=world}\n```\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2182)"},{"id":"shellcheck_SC2183","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"This format string has 2 variables, but is passed 1 arguments.","description":"This format string has 2 variables, but is passed 1 arguments.","explanation":"## This format string has 2 variables, but is passed 1 arguments.\n\n### Problematic code:\n\n```sh\nprintf \"Hello %s, welcome to %s.\\n\" \"$USER\"\n```\n\n### Correct code:\n\n```sh\nprintf \"Hello %s, welcome to %s.\\n\" \"$USER\" \"$HOSTNAME\"\n```\n### Rationale:\n\nShellCheck has noticed that you're using a `printf` format string with more `%s` variables than arguments to fill them.\n\nIn the problematic example case, the last `%s` will just become an empty string every time.\n\nEither remove the unused variables from the format string, or add enough arguments to fill them.\n\n### Exceptions:\n\nWhen using the Ksh/Bash `%T` timestamp extension, such as `printf 'The time is %(%H:%M)T\\n'`, an argument of `-1` and no argument are both taken to mean the current time. In these cases, consider specifying `-1` explicitly.\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2183)"},{"id":"shellcheck_SC2184","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"Quote arguments to unset so they're not glob expanded.","description":"Quote arguments to unset so they're not glob expanded.","explanation":"## Quote arguments to unset so they're not glob expanded.\n\n### Problematic code:\n\n```sh\nunset foo[index]\n```\n\n### Correct code:\n\n```sh\nunset 'foo[index]'\n```\n### Rationale:\n\nArguments to `unset` are subject to regular glob expansion. This is especially relevant when unsetting indices in arrays, where `[..]` is considered a glob character group.\n\nIn the problematic code, having a file called `food` in the current directory will result in `unset foo[index]` expanding to `unset food`, which will silently succeed without unsetting the element.\n\nQuoting so that the `[..]` is passed literally to `unset` solves the issue.\n\n### Exceptions:\n\nNone.\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2184)"},{"id":"shellcheck_SC2185","category":"CodeStyle","level":"Info","severityLevel":"Info","enabled":false,"parameters":[],"title":"Some finds don't have a default path. Specify '.' explicitly.","description":"Some finds don't have a default path. Specify '.' explicitly.","explanation":"## Some finds don't have a default path. Specify '.' explicitly.\n\n### Problematic code:\n\n```sh\nfind -type f\n```\n\n### Correct code:\n\n```sh\nfind . -type f\n```\n### Rationale:\n\nWhen not provided a search path, GNU and Busybox `find` will use a default path of `.`, the current directory.\n\nOn POSIX, macOS/OSX, FreeBSD, OpenBSD and NetBSD, it will instead result in an error.\n\nExplicitly specifying a path works across all implementations, and is therefore preferred.\n\n### Exceptions:\n\nYou will get a false positive if you concatenate a series of pre-path flags:\n\n    find -XLE .\n\nIn such cases, please either use `find -X -L -E .` or [[ignore]] the message.\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2185)"},{"id":"shellcheck_SC2186","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"tempfile is deprecated. Use mktemp instead.","description":"tempfile is deprecated. Use mktemp instead.","explanation":"## tempfile is deprecated. Use mktemp instead.\n\n### Problematic code:\n\n```sh\ntmp=$(tempfile)\n```\n\n### Correct code:\n\n```sh\ntmp=$(mktemp)\n```\n### Rationale:\n\n`tempfile` is a Debian specific utility for creating temporary files. Its man page notes:\n\n>tempfile is deprecated; you should use mktemp(1) instead.\n\nNeither `tempfile` nor `mktemp` are POSIX, but `tempfile` is Debian specific while `mktemp` works on GNU, OSX, BusyBox, *BSD and Solaris.\n\n### Exceptions:\n\nShellCheck will not recognize when a function overrides this name.\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2186)"},{"id":"shellcheck_SC2187","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"Ash scripts will be checked as Dash. Add '# shellcheck shell=dash' to silence.","description":"Ash scripts will be checked as Dash. Add '# shellcheck shell=dash' to silence.","explanation":"## Ash scripts will be checked as Dash. Add '# shellcheck shell=dash' to silence.\n\n### Problematic code:\n\n```sh\n#!/bin/ash\necho \"Hello World\"\n```\n\n### Correct code:\n\n```sh\n#!/bin/ash\n# shellcheck shell=dash\necho \"Hello World\"\n```\n### Rationale:\n\nShellCheck has no first class support for `ash`, but it does support its Debian fork `dash` and defaults to this whenever `ash` is specified.\n\nUnfortunately, while the two are similar, they are not completely compatible. For example, `ash` supports `echo -e` but `dash` does not, so ShellCheck will incorrectly warn about it.\n\nYou can use a [[directive]] to let ShellCheck know you're aware of this problem.\n\n### Exceptions:\n\nNone. \n[Source](https://github.com/koalaman/shellcheck/wiki/SC2187)"},{"id":"shellcheck_SC2188","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"This redirection doesn't have a command. Move to its command (or use 'true' as no-op).","description":"This redirection doesn't have a command. Move to its command (or use 'true' as no-op).","explanation":"## This redirection doesn't have a command. Move to its command (or use 'true' as no-op).\n\n### Problematic code:\n\n```sh\n{ \n  echo \"Report for $(date +%F)\"\n  uptime\n  df -h\n}\n  > report.txt\n```\n\n### Correct code:\n\n```sh\n{ \n  echo \"Report for $(date +%F)\"\n  uptime\n  df -h\n} > report.txt\n```\n### Rationale:\n\nShellCheck found a redirection that doesn't actually redirect from/to anything.\n\nThis could indicate a bug, such as in the problematic code where an additional linefeed causes `report.txt` to be truncated instead of containing report output, or in `foo & > bar`, where either `foo &> bar` or `foo > bar &` was intended. \n\nHowever, it could also be intentionally used to truncate a file or check that it's readable. You can make this more explicit for both ShellCheck and human readers by using `true` or `:` as a dummy command, e.g. `true > file` or `: > file`. \n \n### Exceptions:\n\nThere are no semantic problems with using `> foo` over `true > foo`, so if you don't see this as a potential source of bugs or confusion, you can [[ignore]] it.\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2188)"},{"id":"shellcheck_SC2189","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"You can't have | between this redirection and the command it should apply to.","description":"You can't have | between this redirection and the command it should apply to.","explanation":"## You can't have | between this redirection and the command it should apply to.\n\n### Problematic code:\n\n```sh\n< file.txt | grep foo\n```\n\n### Correct code:\n\n```sh\n< file.txt grep foo   # or more canonically: grep foo < file.txt\n```\n\n### Rationale:\n\nShellCheck has found a stage in a pipeline that consists of a redirection but no command. This doesn't make sense because a redirection without a command will not read or write any data.\n\nThis is most likely to occur when deleting a command that had a redirection, but leaving a `|` behind instead of moving the redirection to a different command:\n\n```\n# Match lines with line numbers\nnl < foo.txt | grep bar\n\n# Incorrect attempt at removing line numbers. grep now has no input:\n< foo.txt | grep bar\n\n# Line numbers correctly removed. grep now reads foo.txt as intended.\ngrep bar < foo.txt\n```\n\n### Exceptions:\n\nIt's technically valid to do e.g. `echo foo | > \"$(cat)\"` to truncate a file called \"foo\", but please consider rewriting such code.\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2189)"},{"id":"shellcheck_SC2190","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"Elements in associative arrays need index, e.g. array=( [index]=value ) .","description":"Elements in associative arrays need index, e.g. array=( [index]=value ) .","explanation":"## Elements in associative arrays need index, e.g. array=( [index]=value ) .\n\n### Problematic code:\n\n```sh\ndeclare -A foo\nfoo=( myvalue )\n```\n\n### Correct code:\n\n```sh\ndeclare -A foo\nfoo=( [key]=myvalue )\n```\n### Rationale:\n\nYou appear to be initializing or appending an array element to an associative array without giving it an index. In an indexed array, elements will be auto-indexed by incremented characters. In associative arrays, the index must be given explicitly.\n\nThis could happen because of invalid spaces or otherwise malformed index assignment, such as `array=( [key] = value )`. This should instead be `array=( [key]=value )`.\n\n### Exceptions:\n\nShellCheck may be confused when a variable name is reused in different contexts. If shellcheck mistakenly believes the array is associated, please [[ignore]] this error. \n[Source](https://github.com/koalaman/shellcheck/wiki/SC2190)"},{"id":"shellcheck_SC2191","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"The = here is literal. To assign by index, use ( [index]=value ) with no spaces. To keep as literal, quote it.","description":"The = here is literal. To assign by index, use ( [index]=value ) with no spaces. To keep as literal, quote it.","explanation":"## The = here is literal. To assign by index, use ( [index]=value ) with no spaces. To keep as literal, quote it.\n\n### Problematic code:\n\n```sh\narray=( [index] = value )\n```\n\n### Correct code:\n\n```sh\narray=( [index]=value )\n```\n\n### Rationale:\n\nThe shell doesn't care about the `=` sign in your array assignment because it's not part of a recognized index assignment. Instead, it's considered a literal character and becomes part of an array element's value.\n\nIn the example problematic code, this is because the `=` was intended to set the index, but the shell will not recognize it when it is surrounded by spaces.\n\nMake sure to remove any spaces around the `=` when assigning by index, such as in the correct code.\n\nIf you wanted the `=` to be a literal part of the array element, add quotes around it, such as `env=( \"LC_CTYPE=C\" )` or `specialChars=( \"=\" \"%\" \";\" )` .\n\n### Exceptions:\n\nNone. \n[Source](https://github.com/koalaman/shellcheck/wiki/SC2191)"},{"id":"shellcheck_SC2192","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"This array element has no value. Remove spaces after = or use \"\" for empty string.","description":"This array element has no value. Remove spaces after = or use \"\" for empty string.","explanation":"## This array element has no value. Remove spaces after = or use \"\" for empty string.\n### Problematic code:\n\n```sh\narray=([1]=one [2]= two)\n```\n\n### Correct code:\n\n```sh\narray=([1]=one [2]=two)\n```\n### Rationale:\n\nYou have an array element on the form `[index]=`. The shell will interpret this as an independent element with index `index` and value `<empty string>`.\n\nThis may happen as part of the expression `[index]= value`, where the space is not allowed and causes the shell to interpret it as `[index]=\"\" [index+1]=value`.\n\nIf you wanted the element to have a value, remove the spaces after `=`, e.g. `[index]=value`.\n\nIf you wanted to assign an empty string, explicitly use empty quotes: `[index]=\"\"`. This makes no difference to the shell, but will make your intention clear to shellcheck and other humans. \n\n### Exceptions:\n\nNone.\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2192)"},{"id":"shellcheck_SC2193","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"The arguments to this comparison can never be equal. Make sure your syntax is correct.","description":"The arguments to this comparison can never be equal. Make sure your syntax is correct.","explanation":"## The arguments to this comparison can never be equal. Make sure your syntax is correct.\n\n### Problematic code:\n\n```sh\n[ $var+1 == 5 ]              # Unevaluated math\n[ \"{$var}\" == \"value\" ]      # Swapped around $ and {\n[ \"$(cmd1) | cmd2\" == \"42\" ] # Ended with ) too soon\n[[ \"$var \" == *.png ]]       # Trailing space\n```\n\n### Correct code:\n\n```sh\n[ $((var+1)) == 5 ]          # Evaluated math\n[ \"${var}\" == \"value\" ]      # Correct variable expansion\n[ \"$(cmd1 | cmd2)\" == \"42\" ] # Correct command substitution\n[[ \"$var\" == *.png ]]        # No trailing space\n```\n### Rationale:\n\nShellCheck has determined that the two values you're comparing can never be equal. \n\nMost of the time, this happens because of a syntax issue that introduced unintended literal characters into one of the arguments.\n\nThe left-hand side in the problematic examples will always contain (respectively) curly braces, pipe and trailing space. The right-hand sides are literal values and a pattern without trailing spaces, so they will never be equal. The statement is therefore useless, strongly indicating a bug. \n\n### Exceptions:\n\nNone.\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2193)"},{"id":"shellcheck_SC2194","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"This word is constant. Did you forget the $ on a variable?","description":"This word is constant. Did you forget the $ on a variable?","explanation":"## This word is constant. Did you forget the $ on a variable?\n\n### Problematic code:\n\n```sh\ncase foo in\n  bar) echo \"Match\"\nesac\n```\n\n### Correct code:\n\n```sh\ncase $foo in\n  bar) echo \"Match\"\nesac\n```\n### Rationale:\n\nYou are using a `case` statement to compare a literal word.\n\nYou most likely wanted to treat this word as a `$variable` or `$(command)` instead.\n\n### Exceptions:\n\nNone\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2194)"},{"id":"shellcheck_SC2195","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"This pattern will never match the case statement's word. Double check them.","description":"This pattern will never match the case statement's word. Double check them.","explanation":"## This pattern will never match the case statement's word. Double check them.\n\n### Problematic code:\n\n```sh\ncase \"$var \" in      # Trailing space\n  value) echo \"Match\"\nesac\n```\n\n### Correct code:\n\n```sh\ncase \"${var}\" in     # No trailing space\n  value) echo \"Match\"\nesac\n```\n### Rationale:\n\nShellCheck has detected that one of the patterns in a `case` statement will never match. \n\nOften, this is due to mistakes in the case statement word that results in unintended literal characters. In the problematic code, there's a trailing space that will prevent the match from ever succeeding.\n\nFor more examples of when this could happen, see [SC2193](https://github.com/koalaman/shellcheck/wiki/SC2193) for the equivalent warning for `[[ .. ]]` statements.\n\nNote that ShellCheck warns about individual patterns in a branch, and will flag `*.png` in this example even though the branch is not dead:\n\n```\ncase \"${img}.jpg\" in\n  *.png | *.jpg) echo \"It's an image\"\nesac\n```\n\n### Exceptions:\n\nNone. If you encounter a bug and wish to [[ignore]] this warning, make sure the directive goes in front of the `case` and not the individual branch. \n[Source](https://github.com/koalaman/shellcheck/wiki/SC2195)"},{"id":"shellcheck_SC2196","category":"CodeStyle","level":"Info","severityLevel":"Info","enabled":false,"parameters":[],"title":"egrep is non-standard and deprecated. Use grep -E instead.","description":"egrep is non-standard and deprecated. Use grep -E instead.","explanation":"##  egrep is non-standard and deprecated. Use grep -E instead.\n\n### Problematic code:\n\n```sh\negrep 'foo|bar' file\n```\n\n### Correct code:\n\n```sh\ngrep -E 'foo|bar' file\n```\n### Rationale:\n\n`egrep` is a non-standard command. Its functionality is provided in POSIX by `grep -E`. [POSIX grep](http://pubs.opengroup.org/onlinepubs/9699919799/utilities/grep.html) says:\n\n>This grep has been enhanced in an upwards-compatible way to provide the exact functionality of the historical egrep and fgrep commands as well. It was the clear intention of the standard developers to consolidate the three greps into a single command.\n\nman grep for GNU says:\n\n>Direct invocation as either egrep or fgrep is deprecated\n\n### Exceptions:\n\nShellCheck will fail to recognize when functions override `egrep`. Consider giving it a different name or [[ignore]] this error. \n[Source](https://github.com/koalaman/shellcheck/wiki/SC2196)"},{"id":"shellcheck_SC2197","category":"CodeStyle","level":"Info","severityLevel":"Info","enabled":false,"parameters":[],"title":"fgrep is non-standard and deprecated. Use grep -F instead.","description":"fgrep is non-standard and deprecated. Use grep -F instead.","explanation":"##  fgrep is non-standard and deprecated. Use grep -F instead.\n\n### Problematic code:\n\n```sh\nfgrep '*.*' file\n```\n\n### Correct code:\n\n```sh\ngrep -F '*.*' file\n```\n### Rationale:\n\n`fgrep` is a non-standard command. Its functionality is provided in POSIX by `grep -F`. [POSIX grep](http://pubs.opengroup.org/onlinepubs/9699919799/utilities/grep.html) says:\n\n>This grep has been enhanced in an upwards-compatible way to provide the exact functionality of the historical egrep and fgrep commands as well. It was the clear intention of the standard developers to consolidate the three greps into a single command.\n\nman grep for GNU says:\n\n>Direct invocation as either egrep or fgrep is deprecated\n\n### Exceptions:\n\nShellCheck will fail to recognize when functions override `fgrep`. Consider giving it a different name or [[ignore]] this error. \n[Source](https://github.com/koalaman/shellcheck/wiki/SC2197)"},{"id":"shellcheck_SC2198","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"Arrays don't work as operands in [ ]. Use a loop (or concatenate with * instead of @).","description":"Arrays don't work as operands in [ ]. Use a loop (or concatenate with * instead of @).","explanation":"## Arrays don't work as operands in [ ]. Use a loop (or concatenate with * instead of @).\n\n### Problematic code:\n\n```sh\next=png\nallowedExt=(jpg bmp png)\n[ \"$ext\" = \"${allowedExt[@]}\" ] && echo \"Extension is valid\"\n```\n\n### Correct code:\n\n```sh\next=png\nallowedExt=(jpg bmp png)\nfor value in \"${allowedExt[@]}\"\ndo\n  [ \"$ext\" = \"$value\" ] && echo \"Extension is valid\"\ndone\n```\n### Rationale:\n\nArray expansions become a series of words in `[ .. ]`. Operators expect single words only.\n\nThe problematic code is equivalent to `[ \"$ext\" = jpg bmp png ]`, which is invalid syntax. A typical error message is `bash: [: too many arguments` or `dash: somefile: unexpected operator`. \n\nInstead, use a `for` loop to iterate over values, and apply your condition to each.\n\nAlternatively, if you want to concatenate all the values in the array into a single string for your test, use `\"$*\"` or `\"${array[*]}\"`.\n\n### Exceptions:\n\nIf you are dynamically building an a test expression, make your array the only thing in the test expression. ShellCheck will not emit a warning for: `set -- 1 -lt 2; [ \"$@\" ]`\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2198)"},{"id":"shellcheck_SC2199","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"Arrays implicitly concatenate in `[[ ]]`. Use a loop (or explicit * instead of @).","description":"Arrays implicitly concatenate in `[[ ]]`. Use a loop (or explicit * instead of @).","explanation":"## Arrays implicitly concatenate in `[[ ]]`. Use a loop (or explicit * instead of @).\n### Problematic code:\n\n```sh\next=png\nallowedExt=(jpg bmp png)\n[[ \"$ext\" = \"${allowedExt[@]}\" ]] && echo \"Extension is valid\"\n```\n\n### Correct code:\n\n```sh\next=png\nallowedExt=(jpg bmp png)\nfor value in \"${allowedExt[@]}\"\ndo\n  [[ \"$ext\" = \"$value\" ]] && echo \"Extension is valid\"\ndone\n```\n### Rationale:\n\nArray expansions in `[[ .. ]]` will implicitly concatenate into a single string, much like in assignments. The problematic code is equivalent to `[ \"$ext\" = \"jpg bmp png\" ]`. \n\nInstead, use a `for` loop to iterate over values, and apply your condition to each.\n\nAlternatively, if you do want to concatenate all the values in the array into a single string for your test, use `\"$*\"` or `\"${array[*]}\"` to make this explicit.\n\n### Exceptions:\n\nNone.\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2199)"},{"id":"shellcheck_SC2200","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"Brace expansions don't work as operands in [ ]. Use a loop.","description":"Brace expansions don't work as operands in [ ]. Use a loop.","explanation":"## Brace expansions don't work as operands in [ ]. Use a loop.\n\n### Problematic code:\n\n```sh\n[ \"$file\" = index.{htm,html,php} ] && echo \"This is the main file\"\n\n```\n\n### Correct code:\n\n```sh\nfor main in index.{htm,html,php}\ndo\n  [ \"$file\" = \"$main\" ] && echo \"This is the main file\"\ndone\n```\n\n### Rationale:\n\nBrace expansions in `[ ]` will expand to a sequence of words. Operators work on single words.\n\nThe problematic code is equivalent to `[ \"$file\" = index.htm index.html index.php ]`, which is invalid syntax. A typical error message is `bash: [: too many arguments` or `dash: somefile: unexpected operator`. \n\nInstead, use a `for` loop to iterate over values, and apply your condition to each.\n\n### Exceptions:\n\nNone.\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2200)"},{"id":"shellcheck_SC2201","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"Brace expansion doesn't happen in `[[ ]]`. Use a loop.","description":"Brace expansion doesn't happen in `[[ ]]`. Use a loop.","explanation":"## Brace expansion doesn't happen in `[[ ]]`. Use a loop.\n\n### Problematic code:\n\n```sh\n[[ \"$file\" = index.{htm,html,php} ]] && echo \"This is the main file\"\n```\n\n### Correct code:\n\n```sh\nfor main in index.{htm,html,php}\ndo\n  [[ \"$file\" = \"$main\" ]] && echo \"This is the main file\"\ndone\n```\n\n### Rationale:\n\nBrace expansions doesn't happen in `[[ ]]`. They will just be interpreted literally.\n\nInstead, use a `for` loop to iterate over values, and apply your condition to each.\n\n### Exceptions:\n\nNone.\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2201)"},{"id":"shellcheck_SC2202","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"Globs don't work as operands in [ ]. Use a loop.","description":"Globs don't work as operands in [ ]. Use a loop.","explanation":"## Globs don't work as operands in [ ]. Use a loop.\n\n### Problematic code:\n\n```sh\n[ current.log -nt backup/*.log ] && echo \"This is the latest file\"\n\n```\n\n### Correct code:\n\n```sh\nnewerThanAll=true\nfor log in backup/*.log\ndo\n  [ current.log -nt \"$log\" ] || newerThanAll=false\ndone\n[ \"$newerThanAll\" = \"true\" ] && echo \"This is the latest file\"\n```\n\n### Rationale:\n\nGlobs in `[ ]` will expand to a sequence of words, one per matching filename. Meanwhile, operators work on single words.\n\nThe problematic code is equivalent to `[ current.log -nt backup/file1.log backup/file2.log backup/file3.log ]`, which is invalid syntax. A typical error message is `bash: [: too many arguments` or `dash: somefile: unexpected operator`. \n\nInstead, use a `for` loop to iterate over matching filenames, and apply your condition to each.\n\n### Exceptions:\n\nIf you know your glob will only ever match one file, you can check this explicitly and use the first file:\n\n```\nset -- backup/*.log\n[ $# -eq 1 ] || { echo \"There are too many matches.\"; exit 1; }\n[ file.log -nt \"$1\" ] && echo \"This is the latest file\"\n```\n\nAlternatively, [[ignore]] this warning.\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2202)"},{"id":"shellcheck_SC2203","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"Globs are ignored in `[[ ]]` except right of =/!=. Use a loop.","description":"Globs are ignored in `[[ ]]` except right of =/!=. Use a loop.","explanation":"## Globs are ignored in `[[ ]]` except right of =/!=. Use a loop.\n\n### Problematic code:\n\n```sh\n[[ current.log -nt backup/*.log ]] && echo \"This is the latest file\"\n\n```\n\n### Correct code:\n\n```sh\nnewerThanAll=true\nfor log in backup/*.log\ndo\n  [[ current.log -nt \"$log\" ]] || newerThanAll=false\ndone\n[[ \"$newerThanAll\" = \"true\" ]] && echo \"This is the latest file\"\n```\n\n### Rationale:\n\nGlobs in `[[ ]]` will not filename expand, and will be treated literally (or as patterns on the right-hand side of `=`, `==` and `!=`).\n\nThe problematic code is equivalent to `[[ current.log -nt 'backup/*.png' ]`, and will look for a file with a literal asterisk in the name.\n\nInstead, you can iterate over the filenames you want with a loop, and apply your condition to each filename.\n\n### Exceptions:\n\nNone.\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2203)"},{"id":"shellcheck_SC2204","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"(..) is a subshell. Did you mean [ .. ], a test expression?","description":"(..) is a subshell. Did you mean [ .. ], a test expression?","explanation":"## (..) is a subshell. Did you mean [ .. ], a test expression?\n\n### Problematic code:\n\n```sh\nif ( -d mydir )\nthen\n  echo \"It's a directory\"\nfi\n```\n\n### Correct code:\n\n```sh\nif [ -d mydir ]\nthen\n  echo \"It's a directory\"\nfi\n```\n### Rationale:\n\nTests like `-d` to see if something is a directory or `-z` to see if it's non-empty are actually flags to the `test` command, and only work as tests in that context. `[` is an alias for `test`, so you'll frequently see them written as `[ -d mydir ]`.\n\n`( .. )` is completely unrelated, and is a subshell mostly used to scope shell modifications. They should not be used in `if` or `while` statements in shell scripts.\n\nIf you wanted to test a condition, rewrite the `( .. )` to `[ .. ]`. \n\n### Exceptions:\n\nNone. \n\nThis error is triggered by having a unary test operator as the first command name in a subshell, which won't normally happen. Note that there's a similar warning [[SC2205]] with a higher false positive rate.\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2204)"},{"id":"shellcheck_SC2205","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"(..) is a subshell. Did you mean [ .. ], a test expression?","description":"(..) is a subshell. Did you mean [ .. ], a test expression?","explanation":"## (..) is a subshell. Did you mean [ .. ], a test expression?\n\n### Problematic code:\n\n```sh\nif ( 1 -lt 2 )\nthen\n  echo \"1 is less than 2\"\nfi\n```\n\n### Correct code:\n\n```sh\nif [ 1 -lt 2 ]\nthen\n  echo \"1 is less than 2\"\nfi\n```\n### Rationale:\n\nTests like `-eq` to check numeric equality or `\\<` for string comparison only work are actually parameters to the `test` command, and only work as tests in that context. `[` is an alias for `test`, so you'll frequently see them written as `[ 1 -eq 2 ]`.\n\n`( .. )` is completely unrelated, and is a subshell mostly used to scope shell modifications. They should not be used in `if` or `while` statements in shell scripts.\n\nIf you wanted to test a condition, rewrite the `( .. )` to `[ .. ]`. \n\n### Exceptions:\n\nThis error is triggered by having a binary operator as the first parameter in a subshell, and could falsely trigger on e.g. `if ( grep -eq \"foo|bar\" file )`. In these cases, check whether the subshell is actually needed.\n\nNote that there's a similar looking error [[SC2204]] with a low false positive rate.\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2205)"},{"id":"shellcheck_SC2206","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"Quote to prevent word splitting/globbing, or split robustly with mapfile or read -a.","description":"Quote to prevent word splitting/globbing, or split robustly with mapfile or read -a.","explanation":"## Quote to prevent word splitting/globbing, or split robustly with mapfile or read -a.\n\n### Problematic code:\n\n```sh\narray=( $var )\n```\n\n### Correct code:\n\nIf the variable should be a single element:\n\n```sh\narray=( \"$var\" )\n```\n\nIf it's multiple lines, each of which should be an element:\n\n```sh\n# For bash\nmapfile -t array <<< \"$var\"\n\n# For ksh\nprintf '%s\\n' \"$var\" | while IFS=\"\" read -r line; do array+=(\"$line\"); done\n```\n\nIf it's a line with multiple words (separated by spaces, other delimiters can be chosen with IFS), [each of which should be an element](https://stackoverflow.com/a/30212526):\n\n```sh\n# For bash\nIFS=\" \" read -r -a array <<< \"$var\"\n\n# For ksh\nIFS=\" \" read -r -A array <<< \"$var\"\n``` \n\n### Rationale:\n\nYou are expanding a variable unquoted in an array. This will invoke the shell's sloppy word splitting and glob expansion.\n\nInstead, prefer explicitly splitting (or not splitting):\n\n* If the variable should become a single array element, quote it.\n* If you want to split into lines or words, use `mapfile`, `read -ra` and/or `while` loops as appropriate.\n\nThis prevents the shell from doing unwanted splitting and glob expansion, and therefore avoiding problems with data containing spaces or special characters.\n\n### Exceptions:\n\nIf you have already taken care (through setting IFS and `set -f`) to have word splitting work the way you intend, you can ignore this warning.\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2206)"},{"id":"shellcheck_SC2207","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"Prefer mapfile or read -a to split command output (or quote to avoid splitting).","description":"Prefer mapfile or read -a to split command output (or quote to avoid splitting).","explanation":"## Prefer mapfile or read -a to split command output (or quote to avoid splitting).\n\n### Problematic code:\n\n```sh\narray=( $(mycommand) )\n```\n\n### Correct code:\n\nIf it outputs multiple lines, each of which should be an element:\n\n```sh\n# For bash 4.x, must not be in posix mode, may use temporary files\nmapfile -t array < <(mycommand)\n\n# For bash 3.x+, must not be in posix mode, may use temporary files\narray=()\nwhile IFS='' read -r line; do array+=(\"$line\"); done < <(mycommand)\n\n# For ksh, and bash 4.2+ with the lastpipe option enabled (may require disabling monitor mode)\narray=()\nmycommand | while IFS=\"\" read -r line; do array+=(\"$line\"); done\n```\n\nIf it outputs a line with multiple words (separated by spaces), other delimiters can be chosen with IFS, each of which should be an element:\n\n```sh\n# For bash, uses temporary files\nIFS=\" \" read -r -a array <<< \"$(mycommand)\"\n\n# For bash 4.2+ with the lastpipe option enabled (may require disabling monitor mode)\narray=()\nmycommand | IFS=\" \" read -r -a array\n\n# For ksh\nIFS=\" \" read -r -A array <<< \"$(mycommand)\"\n```\n\nIf the output should be a single element:\n\n```sh\narray=( \"$(mycommand)\" )\n```\n\n### Rationale:\n\nYou are doing unquoted command expansion in an array. This will invoke the shell's sloppy word splitting and glob expansion.\n\nInstead, prefer explicitly splitting (or not splitting):\n\n* If you want to split the output into lines or words, use `mapfile`, `read -ra` and/or `while` loops as appropriate.\n* If the command output should become a single array element, quote it.\n\nThis prevents the shell from doing unwanted splitting and glob expansion, and therefore avoiding problems with output containing spaces or special characters.\n\n### Exceptions:\n\nIf you have already taken care (through setting IFS and `set -f`) to have word splitting work the way you intend, you can ignore this warning.\n\nAnother exception is the wish for error handling: `array=( $(mycommand) ) || die-with-error` works the way it looks while a similar `mapfile` construct like `mapfile -t array < <(mycommand)` **doesn't fail** and you will have to write more code for error handling.\n```\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2207)"},{"id":"shellcheck_SC2208","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"Use `[[ ]]` or quote arguments to -v to avoid glob expansion.","description":"Use `[[ ]]` or quote arguments to -v to avoid glob expansion.","explanation":"## Use `[[ ]]` or quote arguments to -v to avoid glob expansion.\n\n### Problematic code:\n\n```sh\n[ -v foo[0] ] \n```\n\n### Correct code:\n\n```sh\n[ -v 'foo[0]' ]\n```\n### Rationale:\n\nWith `[`, arguments will undergo glob expansion. If a file `foo0` exists when the problematic code is run, it will check for the variable `foo0` instead of the array entry `foo[0]`. If there additionally exists a `foo1`, it will simply fail with an error.\n\nUse `[[ ]]` or quote the argument.\n\n### Exceptions:\n\nNone.\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2208)"},{"id":"shellcheck_SC2209","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"Use var=$(command) to assign output (or quote to assign string).","description":"Use var=$(command) to assign output (or quote to assign string).","explanation":"## Use var=$(command) to assign output (or quote to assign string).\n\n### Problematic code:\n\n```sh\nuser=whoami         # Want to run whoami and assign output\n\nPAGER=cat git log   # Want to assign the string \"cat\"\n```\n\n### Correct code:\n\n```sh\nuser=$(whoami)\n\nPAGER=\"cat\" git log\n```\n\n### Rationale:\n\nPutting `var=` in front of a command will not assign its output. Use `var=$(my command here)` to execute the command and capture its output.\n\nIf you do want to assign a literal string, use quotes to make this clear to shellcheck and humans alike. \n\n### Exceptions:\n\nNone. \n\nQuoting a single command (as in `PAGER=\"cat\"` above) doesn't change how the script works. It's purely to show shellcheck (and humans) that a literal assignment of a command name is intentional. \n\nThis warning triggers generally when a variable is assigned an unquoted command name (from a list of hard coded names). See related warning [[SC2037]] which detects the same kind of error through the patterns `var=value -flag` and `var=value *glob*`.\n\n### Related resources:\n\n* [BashFaq: How can I store the return value and/or output of a command in a variable?](https://mywiki.wooledge.org/BashFAQ/002)\n* [StackOverflow: How to set a variable to the output from a command in Bash](https://stackoverflow.com/questions/4651437/how-to-set-a-variable-to-the-output-from-a-command-in-bash)\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2209)"},{"id":"shellcheck_SC2210","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"This is a file redirection. Was it supposed to be a comparison or fd operation?","description":"This is a file redirection. Was it supposed to be a comparison or fd operation?","explanation":"## This is a file redirection. Was it supposed to be a comparison or fd operation?\n\n### Problematic code:\n\n```sh\nif x > 5; then echo \"true\"; fi\n```\nor\n```sh\nfoo > /dev/null 2>1\n```\n\n### Correct code:\n\n```sh\nif (( x > 5 )); then echo \"true\"; fi\n```\nor\n```sh\nfoo > /dev/null 2>&1\n```\n### Rationale:\n\nYou are redirecting to or from a filename that is an integer. For example, `ls > file` where `file` happens to be `3`.\n\nThis is not likely to be intentional. The most common causes are:\n\n1. Trying to compare two numbers, as in `x > 5`. This should instead be `[ \"$x\" -gt 5 ]` or `(( x > 5 ))`.\n1. Trying similarly to compare command output, as in `grep -c foo file > 100` instead of `[ \"$(grep -c foo file)\" -gt 100 ]`\n1. Malformed FD operations, such as writing `1>2` instead of `1>&2`.\n\nIf you do want to create a file named `4`, you can quote it to silence shellcheck and make it more clear to humans that it's not supposed to be taken numerically.\n\n### Exceptions:\n\nIf you use the `&>` form of redirection, as in `foo > /dev/null 2&>1`, it will trigger this warning. You can safely ignore this warning if that is what triggered it, or change your redirection operator to the semantically preferable `>&`.\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2210)"},{"id":"shellcheck_SC2211","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"This is a glob used as a command name. Was it supposed to be in ${..}, array, or is it missing quoting?","description":"This is a glob used as a command name. Was it supposed to be in ${..}, array, or is it missing quoting?","explanation":"## This is a glob used as a command name. Was it supposed to be in ${..}, array, or is it missing quoting?\n\n### Problematic code:\n\n```sh\nfor f in $(*.png); do echo \"$f\"; done   # Trying to loop over a glob\narray=$(*.txt)                          # Trying to assign an array\necho \"$(array[1])\"                      # Trying to expand an array\n```\n\n### Correct code:\n\n```sh\nfor f in *.png; do echo \"$f\"; done\narray=(*.txt)\necho \"${array[1]}\"\n```\n\n### Rationale:\n\nYou are using a glob as a command name. This is usually a mistake caused by one of the following:\n\n* Trying to use `` `*foo*` `` or `$(*foo*)` to expand a glob. \n* Using `var=$(*.txt)` instead of `var=(*.txt)` to assign an array.\n* Using `$(..)` instead of `${..}` when expanding an array element.\n* Running a program with a name or directory that contains glob characters without escaping them.\n\nLook up and double check the syntax of what you're trying to do.\n\n### Exceptions:\n\nNone. If you want to specify a command name via glob, e.g. to not hard code version in `./myprogram-*/foo`, expand to array or parameters first to allow handling the cases of 0 or 2+ matches. \n[Source](https://github.com/koalaman/shellcheck/wiki/SC2211)"},{"id":"shellcheck_SC2212","category":"CodeStyle","level":"Info","severityLevel":"Info","enabled":false,"parameters":[],"title":"Use 'false' instead of empty [/[[ conditionals.","description":"Use 'false' instead of empty [/[[ conditionals.","explanation":"## Use 'false' instead of empty [/[[ conditionals.\n\n### Problematic code:\n\n```sh\nif [ ]\nthen\n  echo \"Temporarily disabled\"\nfi\n```\n\n### Correct code:\n\n```sh\nif false\nthen\n  echo \"Temporarily disabled\"\nfi\n```\n### Rationale:\n\n`[ ]` is a somewhat obscure way of expressing falsehood, and the behavior is likely intended to allow the incorrectly quoted command `[ $var ]` to still work when the variable is unset.\n\nPOSIX has a more descriptive command `false` for this.\n\n### Exceptions:\n\nNone. This is a stylistic suggestion, and has no effect on how the script works.\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2212)"},{"id":"shellcheck_SC2213","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"getopts specified -n, but it's not handled by this 'case'.","description":"getopts specified -n, but it's not handled by this 'case'.","explanation":"## getopts specified -n, but it's not handled by this 'case'.\n\n### Problematic code:\n\n```sh\nwhile getopts \"vrn\" n\ndo\n  case \"$n\" in\n    v) echo \"Verbose\" ;;\n    r) echo \"Recursive\" ;;\n    \\?) usage;;\n  esac\ndone\n```\n\n### Correct code:\n\n```sh\nwhile getopts \"vrn\" n\ndo\n  case \"$n\" in\n    v) echo \"Verbose\" ;;\n    r) echo \"Recursive\" ;;\n    n) echo \"Dry-run\" ;;    # -n handled here\n    \\?) usage;;\n  esac\ndone\n```\n### Rationale:\n\nYou have a `while getopts` loop where the corresponding `case` statement fails to handle one of the flags.\n\nEither add a case to handle the flag, or remove it from the `getopts` option string.\n\n### Exceptions:\n\nShellCheck may not correctly recognize less canonical uses of `while getopts ..; do case ..;`, such as when modifying the variable before using it:\n\n```\nwhile getopts \"rf-:\" OPT; do\n  if [ \"$OPT\" = \"-\" ]; then   # long option: reformulate OPT and OPTARG\n    OPT=\"${OPTARG%%=*}\"       # extract long option name\n    OPTARG=\"${OPTARG#$OPT}\"   # extract long option argument (may be empty)\n    OPTARG=\"${OPTARG#=}\"      # if long option argument, remove assigning `=`\n  fi\n\n  case \"$OPT\" in\n    r) ... ;;\n    f) ... ;;\n    my-long-option) ... ;;\n  esac\ndone\n```\n\nIn such cases you can do one of:\n\n* [[Ignore]] the warning.\n* Use the external tool `getopt` (no \"s\") which supports long options natively.\n* Rewrite to not modify the variable first, in this case by instead doing it in a `-)` branch.\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2213)"}],"pagination":{"cursor":"MzAw","limit":100,"total":411}}