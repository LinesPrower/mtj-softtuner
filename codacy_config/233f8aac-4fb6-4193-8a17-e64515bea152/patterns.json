{"data":[{"id":"shellcheck_SC1000","category":"CodeStyle","level":"Info","severityLevel":"Info","enabled":false,"parameters":[],"title":"$ is not used specially and should therefore be escaped.","description":"$ is not used specially and should therefore be escaped.","explanation":"# $ is not used specially and should therefore be escaped.\n\n### Problematic code:\n\n```sh\necho \"$\"\n```\n\n### Correct code:\n\n```sh\necho \"\\$\"\n```\n\n### Rationale:\n`$` is special in double quotes, but there are some cases where it's interpreted literally:\n\n1. Following a backslash: `echo \"\\$\"`\n2. In a context where the shell can't make sense of it, such as at the end of the string, (`\"foo$\"`) or before some constructs (`\"$'foo'\"`).\n\nTo avoid relying on strange and shell-specific behavior, any `$` intended to be literal should be escaped with a backslash.\n\nRemoved in [v0.3.3 - 2014-05-29](https://github.com/koalaman/shellcheck/blob/2e5c56b27034492134be1538c1e1e6a533ca791a/CHANGELOG.md#removed-1)\n[Source](https://github.com/koalaman/shellcheck/wiki/SC1000)"},{"id":"shellcheck_SC1001","category":"CodeStyle","level":"Info","severityLevel":"Info","enabled":false,"parameters":[],"title":"This `\\o` will be a regular 'o' in this context.","description":"This `\\o` will be a regular 'o' in this context.","explanation":"## This `\\o` will be a regular 'o' in this context.\n\n### Problematic code:\n\n```sh\n# Want literal backslash\necho Yay \\o/\n\n# Want other characters\nbell=\\a\n```\n\n### Correct code:\n\n```sh\necho 'Yay \\o/'\n\nbell=\"$(printf '\\a')\"\n```\n\n### Rationale:\n\nYou have escaped something that has no special meaning when escaped. The backslash will be simply be ignored.\n\nIf the backslash was supposed to be literal, single quote or escape it.\n\nIf you wanted it to expand to something, rewrite the expression to use `printf` (or in bash, `$'\\t'`). If the sequence in question is `\\n`, `\\t` or `\\r`, you instead get a [[SC1012]] that describes this. \n\n### Exceptions\n\nNone. ShellCheck (as of 2017-07-03, commit 31bb02d6) will not warn when the first letter of a command is unnecessarily escaped, as this is frequently used to suppress aliases interactively. \n[Source](https://github.com/koalaman/shellcheck/wiki/SC1001)"},{"id":"shellcheck_SC1003","category":"CodeStyle","level":"Info","severityLevel":"Info","enabled":false,"parameters":[],"title":"Want to escape a single quote? echo 'This is how it'\\\\''s done'.","description":"Want to escape a single quote? echo 'This is how it'\\\\''s done'.","explanation":"## Want to escape a single quote? echo 'This is how it'\\\\''s done'.\n\n(Note: in v0.4.6, the error message was accidentally missing the backslash)\n\n### Problematic code:\n\n```sh\necho 'This is not how it\\'s done'.\n```\n\n### Correct code:\n\n```sh\necho 'This is how it'\\''s done'.\n```\n\n\n### Rationale\n\nIn POSIX shell, the shell cares about nothing but another single quote to terminate the quoted segment. Not even backslashes are interpreted.\n\n[POSIX.1 Shell Command Language ยง 2.2.2 Single Quotes](http://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_02_02):\n\n> Enclosing characters in single-quotes ( `''` ) shall preserve the literal value of each character within the single-quotes. A single-quote cannot occur within single-quotes.\n\n### Exceptions\nIf you want your single quoted string to end in a backslash, you can rewrite as `'string'\\\\` or [[ignore]] this warning.\n\n[Source](https://github.com/koalaman/shellcheck/wiki/SC1003)"},{"id":"shellcheck_SC1004","category":"CodeStyle","level":"Info","severityLevel":"Info","enabled":false,"parameters":[],"title":"This backslash+linefeed is literal. Break outside single quotes if you just want to break the line.","description":"This backslash+linefeed is literal. Break outside single quotes if you just want to break the line.","explanation":"## This backslash+linefeed is literal. Break outside single quotes if you just want to break the line.\n\n(This warning was retired after 0.7.2 due to low signal-to-noise ratio)\n\n### Problematic code:\n\n```sh\nvar='This is long \\\npiece of text'\n```\n\n### Correct code:\n\n```sh\nvar='This is a long '\\\n'piece of text'\n```\n### Rationale:\n\nYou have a single quoted string containing a backslash followed by a linefeed (newline). Unlike double quotes or unquoted strings, this has no special meaning. The string will contain a literal backslash and a linefeed.\n\nIf you wanted to break the line but not add a linefeed to the string, stop the single quote, break the line, and reopen it. This is demonstrated in the correct code.\n\nIf you wanted to break the line and also include the linefeed as a literal, you don't need a backslash:\n\n```\nvar='This is a multi-line string\nwith an embedded linefeed'\n```\n\n\n### Exceptions:\n\nIf you do want a string containing a literal backslash+linefeed combo, such as with `sed`, you can [[ignore]] this warning.\n[Source](https://github.com/koalaman/shellcheck/wiki/SC1004)"},{"id":"shellcheck_SC1007","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"Remove space after = if trying to assign a value (or for empty string, use var='' ... ).","description":"Remove space after = if trying to assign a value (or for empty string, use var='' ... ).","explanation":"# Remove space after = if trying to assign a value (or for empty string, use var='' ... ).\n\n### Problematic code:\n\n```sh\n# I want programs to show text in dutch!\nLANGUAGE= nl\n```\n\n```sh\n# I want to run the nl command with English error messages!\nLANGUAGE= nl\n```\n\n### Correct code:\n\n```sh\n# I want programs to show text in dutch!\nLANGUAGE=nl\n```\n\n```sh\n# I want to run the nl command with English error messages!\nLANGUAGE='' nl\n```\n\n### Rationale:\n\nIt's easy to think that `LANGUAGE= nl` would assign `\"nl\"` to the variable `LANGUAGE`. It doesn't.\n\nInstead, it runs `nl` (the \"number lines\" command) and sets `LANGUAGE` to an empty string in its environment.\n\nSince trying to assign values this way is a common mistake, ShellCheck warns about it and asks you to be explicit when assigning empty strings (except for `IFS`, due to the common `IFS= read ..` idiom).\n\n### Exceptions\nIf you're familiar with this behavior and feel that the explicit version is unnecessary, you can [[ignore]] it.\n\n[Source](https://github.com/koalaman/shellcheck/wiki/SC1007)"},{"id":"shellcheck_SC1008","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"This shebang was unrecognized. ShellCheck only supports sh/bash/dash/ksh. Add a 'shell' directive to specify.","description":"This shebang was unrecognized. ShellCheck only supports sh/bash/dash/ksh. Add a 'shell' directive to specify.","explanation":"## This shebang was unrecognized. ShellCheck only supports sh/bash/dash/ksh. Add a 'shell' directive to specify.\n\n### Problematic code:\n\n```sh\n#!/bin/mywrapper\necho \"Hello World\"\n```\n\n### Correct code:\n\n```sh\n#!/bin/mywrapper\n# shellcheck shell=bash\necho \"Hello World\"\n```\n\n### Rationale:\n\nYou have specified a shebang that ShellCheck doesn't recognize. This can be due to invoking the script via a wrapper, specifying a dummy like `#!/bin/false` to prevent execution, or trying to check a script for a non-Bourne shell or tool.\n\nIf this really is a sh/bash/dash/ksh script, please add a `shell` directive after the shebang to tell ShellCheck how to interpret the script, as in the example. You can also specify the shell with the `-s` flag. \n\nIf this is a script in some other language, like `#!/bin/sed` for a `sed` script, then sorry -- ShellCheck does not support `sed`, `awk`, `expect` scripts. It only supports Bourne style shell scripts. \n\n### Exceptions:\n\nNone.\n\n### Related resources:\n\n* Help by adding links to BashFAQ, StackOverflow, man pages, POSIX, etc!\n[Source](https://github.com/koalaman/shellcheck/wiki/SC1008)"},{"id":"shellcheck_SC1009","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"The mentioned parser error was in ...","description":"The mentioned parser error was in ...","explanation":"#  The mentioned parser error was in ...\n\nThis info warning points to the start of what ShellCheck was parsing when it failed. See [[Parser error]] for example and information.\n\n[Source](https://github.com/koalaman/shellcheck/wiki/SC1009)"},{"id":"shellcheck_SC1010","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"Use semicolon or linefeed before 'done' (or quote to make it literal).\r","description":"Use semicolon or linefeed before 'done' (or quote to make it literal).\r","explanation":"## Use semicolon or linefeed before 'done' (or quote to make it literal).\r\n\r\n(or `do` `then`, `fi`, `esac`)\r\n\r\n### Problematic code:\r\n\r\n```\r\nfor f in *; do echo \"$f\" done\r\n```\r\nor\r\n\r\n```\r\necho $f is done\r\n```\r\n\r\n### Correct code:\r\n\r\n```\r\nfor f in *; do echo \"$f\"; done\r\n```\r\n\r\nor\r\n\r\n```\r\necho \"$f is done\"\r\n```\r\n\r\n\r\n### Rationale:\r\n\r\nShellCheck found a keyword like `done`, `then`, `fi`, `esac`, etc used as the argument of a command. This means that the shell will interpret it as a literal string rather than a shell keyword. To be interpreted as a keyword, it must be the first word in the line (i.e. after `;`, `&` or a linefeed). \r\n\r\nIn the example, `echo \"$f\" done` is the same as `echo \"$f\" \"done\"`, and the `done` does not terminate the loop. This is fixed by terminating the `echo` command with a `;` so that the `done` is the first word in the next line.\r\n\r\n### Exceptions\r\n\r\nIf you're intentionally using `done` as a literal, you can quote it to make this clear to shellcheck (and also human readers), e.g. instead of `echo Task is done`, use `echo \"Task is done\"`. This makes no difference to the shell, but it will silence this warning.\r\n\n[Source](https://github.com/koalaman/shellcheck/wiki/SC1010)"},{"id":"shellcheck_SC1011","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"This apostrophe terminated the single quoted string!","description":"This apostrophe terminated the single quoted string!","explanation":"## This apostrophe terminated the single quoted string!\n\n### Problematic code:\n\n```sh\necho 'Nothing so needs reforming as other people's habits.'\n```\n\n### Correct code:\n\n```sh\necho 'Nothing so needs reforming as other people'\\''s habits.'\n```\nor\n```sh\necho \"Nothing so needs reforming as other people's habits.\"\n```\n### Rationale:\n\nWhen writing a string in single quotes, you have to make sure that any apostrophes in the text don't accidentally terminate the single quoted string prematurely.\n\nEscape them properly (see the correct code) or switch quotes to avoid the problem.\n\n### Exceptions:\n\nNone.\n[Source](https://github.com/koalaman/shellcheck/wiki/SC1011)"},{"id":"shellcheck_SC1012","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"`\\t` is just literal `t` here. For tab, use `\"$(printf '\\t')\"` instead.","description":"`\\t` is just literal `t` here. For tab, use `\"$(printf '\\t')\"` instead.","explanation":"## `\\t` is just literal `t` here. For tab, use `\"$(printf '\\t')\"` instead.\n\n### Problematic code:\n\n```sh\n# Want tab\nvar=foo\\tbar\n```\n\nor\n\n```sh\n# Want linefeed\nvar=foo\\nbar\n```\n\n### Correct code:\n\n```sh\nvar=\"foo$(printf '\\t')bar\"  # As suggested in warning\nvar=\"$(printf 'foo\\tbar')\"  # Equivalent alternative\n```\n\nor\n```sh\n# Literal, quoted linefeed\nline=\"foo\nbar\"\n```\n### Rationale:\n\nShellCheck has found a `\\t`, `\\n` or `\\r` in a context where they just become regular letter `t`, `n` or `r`. Most likely, it was intended as a tab, linefeed or carriage return.\n\nTo generate such characters (plus other less common ones including `\\a`, `\\f` and octal escapes) , use `printf` as in the example. The exception is for linefeeds that would be stripped by command substitution; in these cases, use a literal quoted linefeed instead.\n\nOther characters like `\\z` generate a [[SC1001]] info message, as the intent is less certain.\n\n### Exceptions:\n\nNone.\n\n### Related resources:\n\n* Help by adding links to BashFAQ, StackOverflow, man pages, POSIX, etc!\n[Source](https://github.com/koalaman/shellcheck/wiki/SC1012)"},{"id":"shellcheck_SC1014","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"Use 'if cmd; then ..' to check exit code, or 'if [ \"$(cmd)\" = .. ]' to check output.","description":"Use 'if cmd; then ..' to check exit code, or 'if [ \"$(cmd)\" = .. ]' to check output.","explanation":"## Use 'if cmd; then ..' to check exit code, or 'if [ \"$(cmd)\" = .. ]' to check output.\n\n### Problematic code:\n\n```sh\nif [ grep -q pattern file ]\nthen\n  echo \"Found a match\"\nfi\n```\n\n### Correct code:\n\n```sh\nif grep -q pattern file\nthen\n  echo \"Found a match\"\nfi\n\n```\n### Rationale:\n\n`[ .. ]` is not part of shell syntax like `if` statements. It is not equivalent to parentheses in C-like languages, `if (foo) { bar; }`, and should not be wrapped around commands to test. \n\n`[` is just regular command, like `whoami` or `grep`, but with a funny name (see `ls -l /bin/[`). It's a shorthand for `test`. \n\nIf you want to check the exit status of a certain command, use that command directly as demonstrated in the correct code.\n\nIf you want to check the output of a command, use `\"$(..)\"` to get its output, and then use `test` or  `[`/`[[` to do a string comparison:\n\n```sh\n# Check output of `whoami` against the string `root`\nif [ \"$(whoami)\" = \"root\" ]\nthen\n  echo \"Running as root\"\nfi\n```\n\nFor more information, see [this problem in the Bash Pitfall](http://mywiki.wooledge.org/BashPitfalls#if_.5Bgrep_foo_myfile.5D) list, or generally [Tests and Conditionals](http://mywiki.wooledge.org/BashGuide/TestsAndConditionals) in the WoolEdge BashGuide \n\n### Exceptions:\n\nNone.\n\n### Related resources:\n\n* [How do I use a file grep comparison inside a bash if/else statement?](https://stackoverflow.com/questions/2480584/how-do-i-use-a-file-grep-comparison-inside-a-bash-if-else-statement)\n* Bash Pitfalls: [ if [grep foo myfile] ](https://mywiki.wooledge.org/BashPitfalls#if_.5Bgrep_foo_myfile.5D)\n[Source](https://github.com/koalaman/shellcheck/wiki/SC1014)"},{"id":"shellcheck_SC1017","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"Literal carriage return. Run script through `tr -d '\\r'` .","description":"Literal carriage return. Run script through `tr -d '\\r'` .","explanation":"## Literal carriage return. Run script through `tr -d '\\r'` .\n\n### Problematic code:\n\n```sh\n$ cat -v myscript\n#!/bin/sh^M\necho \"Hello World\"^M\n```\n\n### Correct code:\n\n```sh\n$ cat -v myscript\n#!/bin/sh\necho \"Hello World\"\n```\n### Rationale:\n\nThe script uses Windows/DOS style `\\r\\n` line terminators instead of UNIX style `\\n` terminators. The additional `\\r` aka `^M` aka carriage return characters will be treated literally, and results in all sorts strange bugs and messages.\n\nYou can verify this with `cat -v yourfile` and see whether or not each line ends with a `^M`. To delete them, open the file in your editor and save the file as \"Unix\", \"UNIX/OSX Format\", `:set ff=unix` or similar if it supports it.\n\nIf you don't know how to get your editor to save a file with Unix line terminators, you can use `tr`:\n\n    tr -d '\\r' < badscript   > goodscript\n\nThis will read a script `badscript` with possible carriage returns, and write `goodscript` without them.\n\n### Exceptions:\n\nNone\n\n### Related resources:\n\n* [BashFaq: How do I convert a file from DOS format to UNIX format (remove CRs from CR-LF line terminators)?](https://mywiki.wooledge.org/BashFAQ/052)\n* [StackOverflow: Are shell scripts sensitive to encoding and line endings?\n](https://stackoverflow.com/questions/39527571/are-shell-scripts-sensitive-to-encoding-and-line-endings)\n[Source](https://github.com/koalaman/shellcheck/wiki/SC1017)"},{"id":"shellcheck_SC1018","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"This is a unicode non-breaking space. Delete it and retype as space.","description":"This is a unicode non-breaking space. Delete it and retype as space.","explanation":"# This is a unicode non-breaking space. Delete it and retype as space.\n\nYou copy-pasted some code, probably from a blog or web site, which for formatting reasons contained unicode no-break spaces or unicode zero-width spaces instead of regular spaces or in words.\n\nTo humans, a zero-width space is invisible and a non-breaking space is indistinguishable from a regular space, but the shell does not agree.\n\nIf you have just a few, delete the indiciated space/word and retype it. If you have tons, do a search&replace in your editor (copy-paste an offending space into the search field, and type a regular space into the replace field), or use `sed -e $'s/\\xC2\\xA0/ /g' -e $'s/\\xE2\\x80\\x8b//g' -i yourfile` to remove them.\n\n[Source](https://github.com/koalaman/shellcheck/wiki/SC1018)"},{"id":"shellcheck_SC1019","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"Expected this to be an argument to the unary condition.","description":"Expected this to be an argument to the unary condition.","explanation":"## Expected this to be an argument to the unary condition.\n\n### Problematic code:\n\n```sh\n[ -x ]\n```\n\n### Correct code:\n\n```sh\n[ -x \"myfile\" ]\n```\n### Rationale:\n\nShellCheck has found a unary test operator that does not appear to be followed by a valid shell word. \n\nThis could be because of a misplaced `]`, `)`, or a missing space before the `]`.\n\nCheck the syntax, make sure the test operator has an operand, and try again.\n\n### Exceptions:\n\nNone.\n\n### Related resources:\n\n* Help by adding links to BashFAQ, StackOverflow, man pages, POSIX, etc!\n[Source](https://github.com/koalaman/shellcheck/wiki/SC1019)"},{"id":"shellcheck_SC1020","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"You need a space before the \"]\" or \"]]\"","description":"You need a space before the \"]\" or \"]]\"","explanation":"## You need a space before the \"]\" or \"]]\"\n\n### Problematic code:\n\n```\nif [ \"$STUFF\" = \"\"]; then\n```\n\n### Correct code:\n\n```\nif [ \"$STUFF\" = \"\" ]; then\n```\n\n### Rationale:\nBourne shells are very whitespace sensitive. Adding or removing spaces can drastically alter the meaning of a script. In these cases, ShellCheck has noticed that you're missing a space at the position indicated.\n\n### Exceptions\nnone.\n\n### Ignore\n```\n# shellcheck disable=SC1020\nif [ \"$STUFF\" = \"\"]; then\n...\n```\n[Source](https://github.com/koalaman/shellcheck/wiki/SC1020)"},{"id":"shellcheck_SC1026","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"If grouping expressions inside [[..]], use ( .. ).","description":"If grouping expressions inside [[..]], use ( .. ).","explanation":"## If grouping expressions inside [[..]], use ( .. ).\n\n### Problematic code:\n\n```sh\n[[ [ a || b ] && c ]]\n[ [ a -o b ] -a c ]]\n```\n\n### Correct code:\n\n```sh\n[[ ( a || b ) && c ]]\n[ \\( a -o b \\) -a c ]]  # or  { [ a ] || [ b ]; } && [ c ]\n```\n### Rationale:\n\n`[ .. ]` should not be used to group subexpressions inside `[[ .. ]]` or `[ .. ]` statements.\n\nFor `[[ .. ]]`, use regular parentheses.\n\nFor `[ .. ]`, either use escaped parentheses, or preferably rewrite the expression into multiple `[ .. ]` joined with `&&`, `||` and `{ ..; }` groups. The latter is preferred because `[ .. ]` is undefined for more than 4 arguments in POSIX.\n\n### Exceptions:\n\nNone\n\n### Related resources:\n\n* [Bash Pitfalls: `if [ [ a = b ] && [ c = d ] ]; then ...`](https://mywiki.wooledge.org/BashPitfalls#pf11)\n* [POSIX `test`](http://pubs.opengroup.org/onlinepubs/9699919799/utilities/test.html)\n[Source](https://github.com/koalaman/shellcheck/wiki/SC1026)"},{"id":"shellcheck_SC1028","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"In [..] you have to escape \\\\( \\\\) or preferably combine [..] expressions.","description":"In [..] you have to escape \\\\( \\\\) or preferably combine [..] expressions.","explanation":"## In [..] you have to escape \\\\( \\\\) or preferably combine [..] expressions.\n\n### Problematic code:\n\n```sh\n[ -e ~/.bashrc -a ( -x /bin/dash -o -x /bin/ash ) ]\n```\n\n### Correct code:\n\nIn POSIX:\n```sh\n[ -e ~/.bashrc ] &&  { [ -x /bin/dash ] || [ -x /bin/ash ]; }\n```\n\nObsolete XSI syntax:\n```sh\n[ -e ~/.bashrc -a \\( -x /bin/dash -o -x /bin/ash \\) ]\n```\n\n### Rationale:\n\n`[` is implemented as a regular command, so `(` is not special.\n\nThe preferred way is not to group inside `[ .. ]` and instead compose multiple `[ .. ]` statments using the shell's `&&`, `||` and `{ ..; }` syntax, since this is well defined by POSIX.\n\nSome shells, such as Bash, support grouping with `\\( .. \\)`, but this is an obsolete XSI-only extension.\n\n### Exceptions:\n\nNone\n[Source](https://github.com/koalaman/shellcheck/wiki/SC1028)"},{"id":"shellcheck_SC1029","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"In `[[..]]` you shouldn't escape `(` or `)`.","description":"In `[[..]]` you shouldn't escape `(` or `)`.","explanation":"## In `[[..]]` you shouldn't escape `(` or `)`.\n\n### Problematic code:\n\n```sh\n[[ -e ~/.bashrc -a \\( -x /bin/dash -o -x /bin/ash \\) ]]\n```\n\n### Correct code:\n\n```sh\n[[ -e ~/.bashrc -a ( -x /bin/dash -o -x /bin/ash ) ]]\n```\n\n### Rationale:\n\nYou don't have to -- and can't -- escape `(` or `)` inside a `[[ .. ]]` expression like you do in `[ .. ]`. Just remove the escaping.\n\n### Exceptions:\n\nNone.\n[Source](https://github.com/koalaman/shellcheck/wiki/SC1029)"},{"id":"shellcheck_SC1033","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"Test expression was opened with double `[[` but closed with single `]`. Make sure they match.","description":"Test expression was opened with double `[[` but closed with single `]`. Make sure they match.","explanation":"## Test expression was opened with double `[[` but closed with single `]`. Make sure they match.\n\n(or SC1034 for vice versa)\n\n### Problematic code:\n\n```sh\n[[ -z \"$var\" ]\n```\n\n### Correct code:\n\n```sh\n[[ -z \"$var\" ]]\n```\n### Rationale:\n\nShellCheck found a test expression `[ ... ]` (POSIX) or `[[ ... ]]` (ksh/bash), but where the opening and closing brackets did not match (i.e. `[[ .. ]` or `[ .. ]]`). The brackets need to match up to work.\n\nNote in particular that `[..]` do *not* work like parentheses in other languages. You can not do:\n\n```sh\n# Invalid\n[[ x ] || [ y ]]\n```\nYou would instead use two separate test expressions joined by `||`:\n\n```sh\n# Valid basic test expressions (sh/bash/ksh)\n[ x ] || [ y ]\n\n# Valid extended test expressions (bash/ksh)\n[[ x ]] || [[ y ]]\n```\n\n### Exceptions:\n\nNone\n\n### Related resources:\n\n* Help by adding links to BashFAQ, StackOverflow, man pages, POSIX, etc!\n[Source](https://github.com/koalaman/shellcheck/wiki/SC1033)"},{"id":"shellcheck_SC1034","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"Test expression was opened with double `[` but closed with single `]]`. Make sure they match.","description":"Test expression was opened with double `[` but closed with single `]]`. Make sure they match.","explanation":"## Test expression was opened with double `[` but closed with single `]]`. Make sure they match.\nSee similar error [[SC1033]]\n[Source](https://github.com/koalaman/shellcheck/wiki/SC1034)"},{"id":"shellcheck_SC1035","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"You need a space here","description":"You need a space here","explanation":"## You need a space here\n\n### Problematic code:\n\n```sh\nif ![-z foo ]; then true; fi # if command `[-z' w/ args `foo', `]' fails..\n```\n### Correct code:\n\n```sh\nif ! [ -z foo ]; then true; fi # if command `[' w/ args `-z', `foo', `]' fails..\n```\n\n### Rationale:\n\nBourne shells are very whitespace sensitive. Adding or removing spaces can drastically alter the meaning of a script. In these cases, ShellCheck has noticed that you're missing a space at the position indicated.\n\n### Exceptions\n\nShellCheck does not understand [Bash History Expansion](https://www.gnu.org/software/bash/manual/html_node/History-Interaction.html), an interactive shell feature also using `!` (such as `!!` to expand to the previous command). \n\nThese features are disabled by default in shells and very rarely used in scripts, but may occasionally be found in interactively sourced files like `.bashrc`. Please ignore the error in these cases.\n[Source](https://github.com/koalaman/shellcheck/wiki/SC1035)"},{"id":"shellcheck_SC1036","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"`(` is invalid here. Did you forget to escape it?","description":"`(` is invalid here. Did you forget to escape it?","explanation":"## `(` is invalid here. Did you forget to escape it?\n\n### Problematic code:\n\n```sh\necho (foo) bar\n```\n\n### Correct code:\n\nDepends on your intention:\n\n```sh\necho \"(foo) bar\"  # Literal parentheses\necho \"$(foo) bar\" # Command expansion\necho \"foo bar\"    # Tried to use parentheses for grouping or function invocation\n```\n\n### Rationale:\n\nShellCheck expected an ordinary shell word but found an opening parenthesis instead.\n\nDetermine what you intended the parenthesis to do and rewrite accordingly. Common issues include:\n\n* Wanting them to be literal, as in `echo (FAIL) Some tests failed`. In this case, it requires quoting.\n* Wanting command expansion, as in `echo Today is (date)`. Add the missing `$`: `echo \"Today is $(date)\"`\n* Adding parentheses because other languages need them in that context, such as `foo (bar, 42)` to call a function. This should be `foo bar 42`. Also, shells do not support tuples or passing arrays as single parameters.\n\n### Exceptions:\n\nBash allows some parentheses as part of assignment-like tokens to certain commands, including `export` and `eval`. This is a workaround in Bash to allow commands that normally would not be valid:\n\n    eval foo=(bar)       # Valid command\n    echo foo=(bar)       # Invalid syntax\n    f=foo; eval $f=(bar) # Also invalid\n\nIn these cases, please quote the command, such as `eval \"foo=(bar)\". This does not change the behavior, but stops relying on bash specific parsing quirks.\n\n### Related resources:\n\n* Help by adding links to BashFAQ, StackOverflow, man pages, POSIX, etc!\n[Source](https://github.com/koalaman/shellcheck/wiki/SC1036)"},{"id":"shellcheck_SC1037","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"Braces are required for positionals over 9, e.g. ${10}.","description":"Braces are required for positionals over 9, e.g. ${10}.","explanation":"## Braces are required for positionals over 9, e.g. ${10}.\n\n### Problematic code:\n\n```sh\necho \"Ninth parameter: $9\"\necho \"Tenth parameter: $10\"\n```\n\n### Correct code:\n\n```sh\necho \"Ninth parameter: $9\"\necho \"Tenth parameter: ${10}\"\n```\n\n### Rationale:\n\nFor legacy reasons, `$10` is interpreted as the variable `$1` followed by the literal string `0`.\n\nCurly braces are needed to tell the shell that both digits are part of the parameter expansion.\n\n### Exceptions\n\nIf you wanted the trailing digits to be literal, `${1}0` will make this clear to both humans and shellcheck.\n\nIn `dash`, `$10` is ([wrongly](https://gnu.org/s/autoconf/manual/html_node/Shell-Substitutions.html)) interpreted as `${10}`, so some 'reversed' care should also be taken:\n\n```sh\nbash -c 'set a b c d e f g h i j; echo $10 ${1}0' # POSIX: a0 a0\ndash -c 'set a b c d e f g h i j; echo $10 ${1}0' # WRONG: j a0\n```\n\n### Related resources:\n\n* [BashFaq: How can I access positional parameters after $9?](https://mywiki.wooledge.org/BashFAQ/025)\n* [StackOverflow: How to handle more than 10 parameters in shell\n](https://stackoverflow.com/questions/4912733/how-to-handle-more-than-10-parameters-in-shell)\n* [Autoconf Manual: Shell Substitutions](https://www.gnu.org/savannah-checkouts/gnu/autoconf/manual/html_node/Shell-Substitutions.html) - documents some non-POSIX older shells too\n\n[Source](https://github.com/koalaman/shellcheck/wiki/SC1037)"},{"id":"shellcheck_SC1038","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"Shells are space sensitive. Use '< <(cmd)', not '<<(cmd)'.","description":"Shells are space sensitive. Use '< <(cmd)', not '<<(cmd)'.","explanation":"## Shells are space sensitive. Use '< <(cmd)', not '<<(cmd)'.\n\n### Problematic code:\n\n```sh\nwhile IFS= read -r line\ndo\n  printf \"%q\\n\" \"$line\"\ndone <<(curl -s http://example.com)\n```\n\n### Correct code:\n\n```sh\nwhile IFS= read -r line\ndo\n  printf \"%q\\n\" \"$line\"\ndone <  <(curl -s http://example.com)\n```\n\n### Rationale:\n\nYou are using `<<(` which is an invalid construct.\n\nYou probably meant to redirect `<` from process substitution `<(..)` instead. To do this, a space is needed between the `<` and `<(..)`, i.e. `< <(cmd)`.\n\n### Exceptions:\n\nNone.\n\n[Source](https://github.com/koalaman/shellcheck/wiki/SC1038)"},{"id":"shellcheck_SC1039","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"Remove indentation before end token (or use `<<-` and indent with tabs).","description":"Remove indentation before end token (or use `<<-` and indent with tabs).","explanation":"## Remove indentation before end token (or use `<<-` and indent with tabs).\n\n### Problematic code:\n\n```sh\nfor f in *.png\ndo\n  cat << EOF\n     <img src=\"$f\" /><br/>\n  EOF\ndone > index.html\n```\n\n### Correct code:\n\n```sh\nfor f in *.png\ndo\n  cat << EOF\n     <img src=\"$f\" /><br/>\nEOF\ndone > index.html\n```\n### Rationale:\n\nThe here document delimiter will not be recognized if it is indented.\n\nYou can fix it in one of two ways:\n\n1. Simply remove the indentation, even though this may break formatting.\n2. Use `<<-` instead of `<<`, and indent the script with tabs only (spaces will not be recognized).\n\nRemoving the indentation is preferred, since the script won't suddenly break if it's reformatted, copy-pasted, or saved with a different editor.\n\n### Exceptions:\n\nIf the line was supposed to be a literal part of the here document, consider choosing a less ambiguous token.\n[Source](https://github.com/koalaman/shellcheck/wiki/SC1039)"},{"id":"shellcheck_SC1040","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"When using <<-, you can only indent with tabs.","description":"When using <<-, you can only indent with tabs.","explanation":"## When using <<-, you can only indent with tabs.\n\n### Problematic code:\n\nAny code using `<<-` that is indented with spaces. `cat -T script` shows\n\n```sh\n    cat <<- foo\n        Hello world\n    foo\n```\n\n### Correct code:\n\nCode using `<<-` must be indented with tabs. `cat -T script` shows\n\n```sh\n^Icat <<- foo\n^I^IHello world\n^Ifoo\n```\n\nOr simply don't indent the end token:\n\n```sh\n    cat <<- foo\n      Hello World\nfoo\n```\n\n### Rationale:\n\n`<<-`, by design, only strips tabs. Not spaces.\n\nYour editor may be automatically replacing tabs with spaces, either when you type them or when you save the file or both. If you're unable to make it stop, just don't indent the end token.\n\n### Exceptions\n\nNone. But note that copy-pasting code to [shellcheck.net](http://www.shellcheck.net) may also turn correct tabs into spaces on some OS.\n\n[Source](https://github.com/koalaman/shellcheck/wiki/SC1040)"},{"id":"shellcheck_SC1041","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"Found 'eof' further down, but not on a separate line.","description":"Found 'eof' further down, but not on a separate line.","explanation":"## Found 'eof' further down, but not on a separate line.\n\n    Close matches include '-eof' (!= 'eof').\n\n### Problematic code:\n\n```sh\ncat <<-eof\nHello World\n-eof\n```\n\n### Correct code:\n\n```sh\ncat <<- eof\nHello World\neof\n```\n### Rationale:\n\nYour here document isn't properly terminated.\n\nThere is a line containing the terminator you've chosen, but it's not by itself on a separate line.\n\nIn the example code, the script uses `<<-eof`, which is the operator `<<-` followed by `eof`. The script therefore looks for `eof` and skips right past the intended terminator because it starts with a dash.\n\nYou will get some companion SC1042 errors mentioning lines that contain the string as a substring, though they all point to the start of the here document and not the relevant line:\n\n```\nIn foo line 4:\nHello\n^-- SC1041: Found 'eof' further down, but not on a separate line.\n^-- SC1042: Close matches include '-eof' (!= 'eof').\n```\n\nLook at your here document and see which line was supposed to terminate it. Then ensure it matches the token exactly, and that it's on its own line with no text before or after.\n\nUnder Windows the error might occur due to the standard CRLF line-ending, which is Windows-specific.\nTry to change the line ending into LF.\n\n### Exceptions:\n\nNone.\n\n---\nNote that SC1041 and SC1042 swapped numbers after v0.4.6 to improve the display order. This rare instance of number reuse was justified by them always occuring together on the same line.\n[Source](https://github.com/koalaman/shellcheck/wiki/SC1041)"},{"id":"shellcheck_SC1042","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"Close matches include '-eof' (!= 'eof').","description":"Close matches include '-eof' (!= 'eof').","explanation":"## Close matches include '-eof' (!= 'eof').\n\n### Problematic code:\n\n```bash\n#!/bin/bash\ncat <<-eof\nHello World\n-eof\n```\n\n### Correct code:\n\n```bash\n#!/bin/bash\ncat <<-eof\nHello World\neof\n```\n\n## Rationale:\nSee companion error [[SC1041]]. This error occurs at the same time it.\n[Source](https://github.com/koalaman/shellcheck/wiki/SC1042)"},{"id":"shellcheck_SC1044","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"Couldn't find end token `EOF' in the here document.","description":"Couldn't find end token `EOF' in the here document.","explanation":"## Couldn't find end token `EOF' in the here document.\n\n### Problematic code:\n\n```sh\ncat << EOF\n  Hello World\n```\n\n### Correct code:\n\n```sh\ncat << EOF\n  Hello World\nEOF\n```\n### Rationale:\n\nThe `<<` here document (aka heredoc) was not properly terminated. The terminating token needs to be on a separate line without indenting (or indented with tabs only when using `<<-`).\n\nNote that you can not put here documents in one liners. For such use cases, use a `<<<` here string:\n\n    cat << EOF  hello world  EOF   # Wrong: data and terminator can not be on the same line\n    cat <<< \"hello world\"          # Correct\n\n### Exceptions:\n\nNone\n\n### Related resources:\n\n* Help by adding links to BashFAQ, StackOverflow, man pages, POSIX, etc!\n[Source](https://github.com/koalaman/shellcheck/wiki/SC1044)"},{"id":"shellcheck_SC1045","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"It's not 'foo &; bar', just 'foo & bar'.","description":"It's not 'foo &; bar', just 'foo & bar'.","explanation":"# It's not 'foo &; bar', just 'foo & bar'.\n\n### Problematic code:\n\n```sh\nfoo &; bar\n```\n\n### Correct code:\n\n```sh\nfoo & bar\n```\n\n### Rationale:\n\nBoth `&` and `;` terminate the command. You should only use one of them.\n\n\n\n### Exceptions\n\nNone.\n\n[Source](https://github.com/koalaman/shellcheck/wiki/SC1045)"},{"id":"shellcheck_SC1046","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"Couldn't find 'fi' for this 'if'.","description":"Couldn't find 'fi' for this 'if'.","explanation":"## Couldn't find 'fi' for this 'if'.\n\n### Problematic code:\n\n```sh\nif true\nthen\n  echo \"True\"\ndone\n```\n\n### Correct code:\n\n```sh\nif true\nthen\n  echo \"True\"\nfi\n```\n### Rationale:\n\nShellCheck has found an `if` statement that does not appear to have a matching terminating `fi`.\n\nThis could be because it's missing entirely, or because the `if` statement was incorrectly terminated by a mismatched `done`, `esac`, `)` or similar. A companion warning [[SC1047]] is emitted at the point where ShellCheck expected the `fi`.\n\nCheck that the `if` statement is completely and correctly terminated.\n\n### Exceptions:\n\nNone\n[Source](https://github.com/koalaman/shellcheck/wiki/SC1046)"},{"id":"shellcheck_SC1047","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"\"Expected 'fi' matching previously mentioned 'if'.","description":"\"Expected 'fi' matching previously mentioned 'if'.","explanation":"## \"Expected 'fi' matching previously mentioned 'if'.\n\nSee companion warning [[SC1046]].\n[Source](https://github.com/koalaman/shellcheck/wiki/SC1047)"},{"id":"shellcheck_SC1048","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"Can't have empty then clauses (use 'true' as a no-op).","description":"Can't have empty then clauses (use 'true' as a no-op).","explanation":"## Can't have empty then clauses (use 'true' as a no-op).\n\n### Problematic code:\n\n```sh\nif [ -e foo ]\nthen\n  # TODO: handle this\nfi\n```\n### Correct code:\n```sh\nif [ -e foo ]\nthen\n  # TODO: handle this\n  true\nfi\n\n# Or use the no-op colon operator \":\"\nif [ -e foo ]\nthen\n  # TODO: handle this\n  :\nfi\n```\n\n### Rationale:\n\nShells do not allow empty `then` clauses. They need at least one command (and comments are not commands).\n\nIf you want a `then` clause that does nothing, use a dummy command like `true`.\n\n### Exceptions:\n\nNone.\n[Source](https://github.com/koalaman/shellcheck/wiki/SC1048)"},{"id":"shellcheck_SC1049","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"Did you forget the 'then' for this 'if'?","description":"Did you forget the 'then' for this 'if'?","explanation":"## Did you forget the 'then' for this 'if'?\n\n### Problematic code:\n\n```sh\nif true\n  echo \"foo\"\nelif true\n  echo \"bar\"\nfi\n```\n\n### Correct code:\n\n```sh\nif true\nthen\n  echo \"foo\"\nelif true\nthen\n  echo \"bar\"\nfi\n```\n\n### Rationale:\n\nShellCheck found a parsing error in the script, and determined that it's most likely due to a missing `then` keyword for the `if` or `elif` indicated.\n\nMake sure the `then` is there. \n\nNote that the `then` needs a `;` or linefeed before it. `if true then` is invalid, while `if true; then` is correct.\n\n### Exceptions:\n\nNone\n[Source](https://github.com/koalaman/shellcheck/wiki/SC1049)"},{"id":"shellcheck_SC1050","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"Expected 'then'.","description":"Expected 'then'.","explanation":"## Expected 'then'.\n\n### Problematic code:\n\n```sh\nif true\n  echo \"True\"\nfi\n```\n\n### Correct code:\n\n```sh\nif true\nthen\n  echo \"True\"\nfi\n```\n### Rationale:\n\nShellCheck has found an `if` statement that appears to be missing a `then`.\n\nMake sure the `then` exists, and that it is the first word of the line (or immediately preceded by a semicolon).\n\n### Exceptions:\n\nNone\n[Source](https://github.com/koalaman/shellcheck/wiki/SC1050)"},{"id":"shellcheck_SC1051","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"Semicolons directly after 'then' are not allowed. Just remove it.","description":"Semicolons directly after 'then' are not allowed. Just remove it.","explanation":"## Semicolons directly after 'then' are not allowed. Just remove it.\n\n### Problematic code:\n\n```sh\nif true; then; echo \"Hi\"; fi\n```\n\n### Correct code:\n\n```sh\nif true; then echo \"Hi\"; fi\n```\n### Rationale:\n\n`then` keywords should not be followed by semicolons. It's not valid shell syntax.\n\nYou can follow them directly with a line break or another command.\n\n### Exceptions:\n\nNone\n[Source](https://github.com/koalaman/shellcheck/wiki/SC1051)"},{"id":"shellcheck_SC1052","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"Semicolons directly after 'then' are not allowed. Just remove it.","description":"Semicolons directly after 'then' are not allowed. Just remove it.","explanation":"## Semicolons directly after 'then' are not allowed. Just remove it.\n\n### Problematic code:\n\n```sh\nif true; then; echo \"Hi\"; fi\n```\n\n### Correct code:\n\n```sh\nif true; then echo \"Hi\"; fi\n```\n### Rationale:\n\n`then` keywords should not be followed by semicolons. It's not valid shell syntax.\n\nYou can follow them directly with a line break or another command.\n\n### Exceptions:\n\nNone\n[Source](https://github.com/koalaman/shellcheck/wiki/SC1052)"},{"id":"shellcheck_SC1053","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"Semicolons directly after 'else' are not allowed. Just remove it.","description":"Semicolons directly after 'else' are not allowed. Just remove it.","explanation":"## Semicolons directly after 'else' are not allowed. Just remove it.\n\n### Problematic code:\n\n```sh\nif mycommand; then echo \"True\"; else; echo \"False\"; fi\n```\n\n### Correct code:\n\n```sh\nif mycommand; then echo \"True\"; else echo \"False\"; fi\n```\n\n### Rationale:\n\n`else` keywords should not be followed by semicolons. It's not valid shell syntax.\n\nYou can follow them directly with a line break or another command.\n\n### Exceptions:\n\nNone\n[Source](https://github.com/koalaman/shellcheck/wiki/SC1053)"},{"id":"shellcheck_SC1054","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"You need a space after the '{'.","description":"You need a space after the '{'.","explanation":"## You need a space after the '{'.\n\n### Problematic code:\n\n```sh\nfoo() {echo \"hello world;}\n```\n\n### Correct code:\n\n```sh\nfoo() { echo \"hello world;}\n```\n### Rationale:\n\n`{` is only recognized as the start of a command group when it's a separate token.\n\nIf it's not a separate token, like in the problematic example, it will be considered a literal character, as if writing `\"{echo\"` with quotes, and therefore usually cause a syntax error.\n\n### Exceptions:\n\nNone.\n[Source](https://github.com/koalaman/shellcheck/wiki/SC1054)"},{"id":"shellcheck_SC1056","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"Expected a '}'. If you have one, try a ; or \\\\n in front of it.","description":"Expected a '}'. If you have one, try a ; or \\\\n in front of it.","explanation":"## Expected a '}'. If you have one, try a ; or \\\\n in front of it.\n\n### Problematic code:\n\n```sh\n#!/bin/bash\nbar() { echo \"hello world\" }\n```\n\n### Correct code:\n\n```sh\n#!/bin/bash\nbar() { echo \"hello world\";}\n```\n### Rationale:\n\n`}` is only recognized as the end of a command group when it's a separate token.\n\nIf it's not a separate token, like in the problematic example, it will be considered a literal character, as if writing `echo \"foo}\"` with quotes, and therefore usually cause a syntax error.\n[Source](https://github.com/koalaman/shellcheck/wiki/SC1056)"},{"id":"shellcheck_SC1058","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"Expected `do`.","description":"Expected `do`.","explanation":"## Expected `do`.\n\n### Problematic code:\n\n```sh\nfor file in *\n  echo \"$file\"\ndone\n```\n\n### Correct code:\n\n```sh\nfor file in *\ndo\n  echo \"$file\"\ndone\n```\n### Rationale:\n\nShellCheck has found a loop that appears to be missing a `do` statement. In the problematic code, it was simply forgotten.\n\nVerify that the `do` exists, and that it's in the correct place.\n\n### Exceptions:\n\nNone\n[Source](https://github.com/koalaman/shellcheck/wiki/SC1058)"},{"id":"shellcheck_SC1061","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"Couldn't find 'done' for this 'do'.","description":"Couldn't find 'done' for this 'do'.","explanation":"## Couldn't find 'done' for this 'do'.\n\n### Problematic code:\n\n```sh\nyes() {\n  while echo \"y\"\n  do\n    true\n}\n```\n\n### Correct code:\n\n```sh\nyes() {\n  while echo \"y\"\n  do\n    true\n  done\n}\n```\n### Rationale:\n\nShellCheck found a `do` without a corresponding `done`.\n\nDouble check that the `done` exists, and that it correctly matches the indicated `do`. A companion warning [[SC1062]] is emitted where ShellCheck first noticed it was missing. \n\n### Exceptions:\n\nNone.\n[Source](https://github.com/koalaman/shellcheck/wiki/SC1061)"},{"id":"shellcheck_SC1062","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"Expected 'done' matching previously mentioned 'do'.","description":"Expected 'done' matching previously mentioned 'do'.","explanation":"## Expected 'done' matching previously mentioned 'do'.\n\nSee companion warning [[SC1061]]\n[Source](https://github.com/koalaman/shellcheck/wiki/SC1062)"},{"id":"shellcheck_SC1064","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"Expected a { to open the function definition.","description":"Expected a { to open the function definition.","explanation":"## Expected a { to open the function definition.\n\n### Problematic code:\n\n```sh\nfoo() {\n  echo \"hello world\"\n}\nfoo()\n```\n\n### Correct code:\n\n```sh\nfoo() {\n  echo \"hello world\"\n}\nfoo\n```\n### Rationale:\n\nShellCheck found what appears to be the start of a function definition, but without a function body.\n\nOne common cause is that you are trying to call a function by appending parentheses, e.g. `foo()` like in C. Bash does not use or allow parentheses after a function name to call it. The function `foo` should be called using just `foo` like in the example. \n\nIf you are declaring a function, make sure it looks like the correct code above, and that it does not try to declare any parameters (parameters are instead accessed with `$1` and up). \n\nIf you are trying to do something else, look up the syntax for what you are trying to do.\n\n\n### Exceptions:\n\nPOSIX allows the body of a function to be any compound command, e.g. `foo() for i; do :; done`. Since this usage is rare, ShellCheck intentionally requires the body to be `{ ..; }` (or `( ..; )`):\n\n    foo() {\n      for i; do :; done\n    }\n\nThis additional structure requirement helps improve error messages and suggestions by not parsing down a path that less advanced users wouldn't expect.\n[Source](https://github.com/koalaman/shellcheck/wiki/SC1064)"},{"id":"shellcheck_SC1065","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"Trying to declare parameters? Don't. Use () and refer to params as $1, $2..","description":"Trying to declare parameters? Don't. Use () and refer to params as $1, $2..","explanation":"## Trying to declare parameters? Don't. Use () and refer to params as $1, $2..\n\n### Problematic code:\n\n```sh\nfoo(input) {\n  echo \"$input\"\n}\nfoo(\"hello world\");\n```\n\n### Correct code:\n\n```sh\nfoo() {\n  echo \"$1\"\n}\nfoo \"hello world\"\n```\n\n### Rationale:\n\nShell script functions behave just like scripts and other commands:\n\n  - They always take a 0 to N parameters, referred to with `$1`, `$2` etc. They can not declare parameters by name.\n  - They are executed using `name arg1 arg2`, and not with parentheses as C-like languages.\n\n### Exceptions:\n\nNone.\n\n[Source](https://github.com/koalaman/shellcheck/wiki/SC1065)"},{"id":"shellcheck_SC1066","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"Don't use $ on the left side of assignments.","description":"Don't use $ on the left side of assignments.","explanation":"## Don't use $ on the left side of assignments.\n\n### Problematic code:\n\n```sh\n$greeting=\"Hello World\"\n```\n\n### Correct code:\n\n```sh\ngreeting=\"Hello World\"\n```\n\nAlternatively, if the goal was to assign to a variable whose name is in another variable (indirection), use `declare`:\n\n```sh\nname=foo\ndeclare \"$name=hello world\"\necho \"$foo\"\n```\n\nOr if you actually wanted to compare the value, use a test expression:\n\n```sh\nif [ \"$greeting\" = \"hello world\" ]\nthen\n  echo \"Programmer, I presume?\"\nfi\n```\n\n### Rationale:\n\nUnlike Perl or PHP, `$` is not used when assigning to a variable.\n\n### Exceptions\n\nIf you wanted to\n\n[Source](https://github.com/koalaman/shellcheck/wiki/SC1066)"},{"id":"shellcheck_SC1069","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"You need a space before the [.","description":"You need a space before the [.","explanation":"## You need a space before the [.\n\n### Problematic code:\n\n```sh\nif[ -e file ]\nthen echo \"exists\"; fi\n```\n\n### Correct code:\n\n```sh\nif [ -e file ]\nthen echo \"exists\"; fi\n```\n### Rationale:\n\nShellCheck found a keyword immediately followed by a `[`. There needs to be a space between them.\n\n### Exceptions:\n\nNone\n[Source](https://github.com/koalaman/shellcheck/wiki/SC1069)"},{"id":"shellcheck_SC1070","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"Parsing stopped here. Mismatched keywords or invalid parentheses?","description":"Parsing stopped here. Mismatched keywords or invalid parentheses?","explanation":"## Parsing stopped here. Mismatched keywords or invalid parentheses?\n\n### Rationale\n\nShellcheck found a syntax error at the indicated location. Barring a bug in Shellcheck itself, your shell will also crash with a syntax error at the same location, so you cannot ignore this check.\n\n### Exceptions\n\nNone.\n[Source](https://github.com/koalaman/shellcheck/wiki/SC1070)"},{"id":"shellcheck_SC1071","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"ShellCheck only supports sh/bash/dash/ksh scripts. Sorry!","description":"ShellCheck only supports sh/bash/dash/ksh scripts. Sorry!","explanation":"## ShellCheck only supports sh/bash/dash/ksh scripts. Sorry!\n\n### Problematic code:\n\n```sh\n#!/usr/bin/python\nprint \"Hello\"\n```\n\n### Rationale:\n\nYou have specified the shebang of an unsupported language or shell dialect.\n\nShellCheck only supports a limited number of Bourne-based Unix shells: bash, ksh, dash and POSIX sh.\n\nIt does not support scripts written for other shells like Zsh, Csh, Tcsh or PowerShell, and it does not support other scripting languages like PHP, Python, JavaScript or SQL.\n[Source](https://github.com/koalaman/shellcheck/wiki/SC1071)"},{"id":"shellcheck_SC1072","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"Unexpected ..","description":"Unexpected ..","explanation":"# Unexpected ..\n\n*Note: There is a [known bug](../issues/1036) in the current version when [directives](../wiki/Directive) appear within `then` clauses of `if` blocks that causes Shellcheck to report SC1072 on otherwise valid code. Avoid using directives within `then` clauses - instead place them at the top of the `if` block or another enclosing block. This is fixed on the [online version](https://www.shellcheck.net/) and the next release.*\n\nSee [Parser Error](https://github.com/koalaman/shellcheck/wiki/Parser-Error).\n\n[Source](https://github.com/koalaman/shellcheck/wiki/SC1072)"},{"id":"shellcheck_SC1073","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"Couldn't parse this (thing). Fix to allow more checks.","description":"Couldn't parse this (thing). Fix to allow more checks.","explanation":"# Couldn't parse this (thing). Fix to allow more checks.\n\nThis parsing error points to the structure ShellCheck was trying to parse when a parser error occurred. \n\nMake any necessary fixes and check the script again, since most of ShellCheck's functionality can only be applied to scripts that parse successfully.\n\nSee [[Parser error]] for more information.\n\n[Source](https://github.com/koalaman/shellcheck/wiki/SC1073)"},{"id":"shellcheck_SC1074","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"Did you forget the `;;` after the previous case item?","description":"Did you forget the `;;` after the previous case item?","explanation":"## Did you forget the `;;` after the previous case item?\n\n### Problematic code:\n\n```bash\nwhile getoptions f option\ndo\n  case \"${options}\"\n  in\n  f) FTR=\"${ARG}\"\n    \\?) exit\n  esac\ndone\n```\n\n### Correct code:\n\n```bash\nwhile getoptions f option\ndo\n  case \"${options}\"\n  in\n  f) FTR=\"${ARG}\"\n    \\?) exit;;\n  esac\ndone\n```\n\n### Rationale:\nSyntax `case` needs `;;` after the previous case item. If not, syntax error will cause.\n[Source](https://github.com/koalaman/shellcheck/wiki/SC1074)"},{"id":"shellcheck_SC1075","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"Use 'elif' instead of 'else if'.","description":"Use 'elif' instead of 'else if'.","explanation":"## Use 'elif' instead of 'else if'.\n\n### Problematic code:\n\n```sh\nif [ \"$#\" -eq 0 ]\nthen\n  echo \"Usage: ...\"\nelse if [ \"$#\" -lt 2 ]\nthen\n  echo \"Missing operand\"\nfi\n  \n```\n\n### Correct code:\n\n```sh\nif [ \"$#\" -eq 0 ]\nthen\n  echo \"Usage: ...\"\nelif [ \"$#\" -lt 2 ]\nthen\n  echo \"Missing operand\"\nfi\n```\n### Rationale:\n\nMany languages allow alternate branches with `else if`, but `sh` is not one of them. Use `elif` instead.\n\n### Exceptions:\n\n`else if` is a valid (though confusing) way of nesting an `if` statement in a parent's `else`. If this is your intention, consider using canonical formatting by putting a linefeed between `else` and `if`.\n\nThis does not change the behavior of the script, but merely makes it more obvious to ShellCheck (and other humans) that you didn't expect the `else if` to behave the way it does in C. Alternatively, you can [[ignore]] it with no ill effects.\n\n```sh\n\nif x\nthen\n  echo \"x\"\nelse     # line break here\n  if y\n  then\n    echo \"y\"\n   fi \nfi\n```\n[Source](https://github.com/koalaman/shellcheck/wiki/SC1075)"},{"id":"shellcheck_SC1077","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"For command expansion, the tick should slant left (` vs ยด).","description":"For command expansion, the tick should slant left (` vs ยด).","explanation":"# For command expansion, the tick should slant left (` vs ยด).\n\n\n### Problematic code:\n\n```sh\necho \"Your username is ยดwhoamiยด\"\n```\n\n### Correct code:\n\n```sh\necho \"Your username is $(whoami)\" # Preferred\necho \"Your username is `whoami`\"  # Deprecated, will give [SC2006]\n```\n\n### Rationale:\n\nIn some fonts it's hard to tell ticks apart, but Bash strongly distinguishes between backticks (grave accent `` ` ``), forward ticks (acute accent `ยด`) and regular ticks (apostrophe `'`).\n\nBackticks start command expansions, while forward ticks are literal. To help spot bugs, ShellCheck parses backticks and forward ticks interchangeably.\n\n### Exceptions\n\nIf you want to write out literal forward ticks, such as fancyful ascii quotation marks:\n\n```sh\necho \"``Proprietary software is an injustice.ยดยด  - Richard Stallman\"\n```\n\nuse single quotes instead:\n\n```sh\necho '``Proprietary software is an injustice.ยดยด  - Richard Stallman'\n```\n\nTo nest forward ticks in command expansion, use `$(..)` instead of `` `..` ``.\n\n[Source](https://github.com/koalaman/shellcheck/wiki/SC1077)"},{"id":"shellcheck_SC1078","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"Did you forget to close this double quoted string?","description":"Did you forget to close this double quoted string?","explanation":"# Did you forget to close this double quoted string?\n\n### Problematic code:\n\n```sh\ngreeting=\"hello\ntarget=\"world\"\n```\n\n### Correct code:\n\n```sh\ngreeting=\"hello\"\ntarget=\"world\"\n```\n\n### Rationale:\n\nThe first line is missing a quote.\n\nShellCheck warns when it detects multi-line double quoted, single quoted or backticked strings when the character that follows it looks out of place (and gives a companion warning [[SC1079]] at that spot).\n\n### Exceptions\n\nIf you do want a multiline variable, just make sure the character after it is a quote, space or line feed.\n\n```sh\nvar='multiline\n'value\n```\n\ncan be rewritten for readability and to remove the warning:\n\n```sh\nvar='multiline\nvalue'\n```\n\nAs always `` `..` `` should be rewritten to ``$(..)``.\n\n[Source](https://github.com/koalaman/shellcheck/wiki/SC1078)"},{"id":"shellcheck_SC1079","category":"CodeStyle","level":"Info","severityLevel":"Info","enabled":false,"parameters":[],"title":"This is actually an end quote, but due to next char it looks suspect.","description":"This is actually an end quote, but due to next char it looks suspect.","explanation":"## This is actually an end quote, but due to next char it looks suspect.\n\nSee companion warning [[SC1078]].\n\n[Source](https://github.com/koalaman/shellcheck/wiki/SC1079)"},{"id":"shellcheck_SC1081","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"Scripts are case sensitive. Use 'if', not 'If'.","description":"Scripts are case sensitive. Use 'if', not 'If'.","explanation":"## Scripts are case sensitive. Use 'if', not 'If'.\n\n### Problematic code:\n\n```sh\nIf true\nThen\n  echo \"hello\"\nFi\n```\n\n### Correct code:\n\n```sh\nif true\nthen\n  echo \"hello\"\nfi\n```\n\n### Rationale:\n\nShells are case sensitive and do not accept `If` or `IF` in place of lowercase `if`.\n\n### Exceptions\n\nIf you're aware of this and insist on naming a function `WHILE`, you can quote the name to prevent shellcheck from thinking you meant `while`. Or if you really want the names, add things like `alias If=if IF=if` to replace those keywords and ask shellcheck to ignore them.\n\n[Source](https://github.com/koalaman/shellcheck/wiki/SC1081)"},{"id":"shellcheck_SC1082","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"This file has a UTF-8 BOM. Remove it with: LC_CTYPE=C sed '1s/^...//' < yourscript .","description":"This file has a UTF-8 BOM. Remove it with: LC_CTYPE=C sed '1s/^...//' < yourscript .","explanation":"##  This file has a UTF-8 BOM. Remove it with: LC_CTYPE=C sed '1s/^...//' < yourscript .\n\n### Problematic code:\n\nThis is an encoding error that can't be seen in the script itself, but `cat -v` will show three bytes of garbage at the start of the file:\n\n```\n$ cat -v file\nM-oM-;M-?#!/bin/bash\necho \"hello world\"\n```\n\n### Correct code:\n\nThe code is correct when this garbage does not appear.\n\n### Rationale:\n\nSome editors may save a file with a [Byte Order Mark](https://en.wikipedia.org/wiki/Byte_order_mark) to mark the file as UTF-8. Shells do not understand this and will give errors on the first line:\n\n```\n$ bash myscript\nmyscript: line 1: #!/bin/sh: No such file or directory\n\n$ dash myscript\nmyscript: 1: myscript: #!/bin/sh: not found\n```\n\nTo fix it, remove the byte order mark. One way of doing this is `LC_CTYPE=C sed '1s/^...//' < yourscript`. Verify that it's not there with `cat -v`. \n\n### Exceptions:\n\nNone\n[Source](https://github.com/koalaman/shellcheck/wiki/SC1082)"},{"id":"shellcheck_SC1083","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"This `{`/`}` is literal. Check if `;` is missing or quote the expression.","description":"This `{`/`}` is literal. Check if `;` is missing or quote the expression.","explanation":"## This `{`/`}` is literal. Check if `;` is missing or quote the expression.\n\n### Problematic code:\n\n```sh\nrmf() { rm -f \"$@\" }\n```\n\nor\n\n```sh\neval echo \\${foo}\n```\n\n### Correct code:\n\n```sh\nrmf() { rm -f \"$@\"; }\n```\n\nand\n\n```sh\neval \"echo \\${foo}\"\n```\n\n### Rationale:\n\nCurly brackets are normally used as syntax in parameter expansion, command grouping and brace expansion.\n\nHowever, if they don't appear alone at the start of an expression or as part of a parameter or brace expansion, the shell silently treats them as literals. This frequently indicates a bug, so ShellCheck warns about it.\n\nIn the example function, the `}` is literal because it's not at the start of an expression. We fix it by adding a `;` before it.\n\nIn the example eval, the code works fine. However, we can quiet the warning and follow good practice by adding quotes around the literal data.\n\nShellCheck does not warn about `{}`, since this is frequently used with `find` and rarely indicates a bug.\n\n### Exceptions\n\nThis error is harmless when the curly brackets are supposed to be literal, in e.g. `awk {'print $1'}`. However, it's cleaner and less error prone to simply include them inside the quotes: `awk '{print $1}'`.\n[Source](https://github.com/koalaman/shellcheck/wiki/SC1083)"},{"id":"shellcheck_SC1084","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"Use #!, not !#, for the shebang.","description":"Use #!, not !#, for the shebang.","explanation":"## Use #!, not !#, for the shebang.\n\n### Problematic code:\n\n```sh\n!#/bin/sh\necho \"Hello World\"\n```\n\n### Correct code:\n\n```sh\n#!/bin/sh\necho \"Hello World\"\n```\n\n### Rationale:\n\nThe shebang has been accidentally swapped. The `#` should come first: `#!`, not `!#`.\n\n### Exceptions\n\nNone.\n\n[Source](https://github.com/koalaman/shellcheck/wiki/SC1084)"},{"id":"shellcheck_SC1086","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"Don't use $ on the iterator name in for loops.","description":"Don't use $ on the iterator name in for loops.","explanation":"## Don't use $ on the iterator name in for loops.\n\n### Problematic code:\n\n```sh\nfor $var in *\ndo\n  echo \"$var\"\ndone\n```\n\n### Correct code:\n\n```sh\nfor var in *\ndo\n  echo \"$var\"\ndone\n```\n\n### Rationale:\n\nThe variable is named `var`, and can be expanded to its value with `$var`.\n\nThe `for` loop expects the variable's name, not its value (and the name can not be specified indirectly).\n\n### Exceptions\n\nNone.\n\n[Source](https://github.com/koalaman/shellcheck/wiki/SC1086)"},{"id":"shellcheck_SC1087","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"\"Use braces when expanding arrays, e.g. ${array[idx]} (or ${var}[.. to quiet).\"","description":"\"Use braces when expanding arrays, e.g. ${array[idx]} (or ${var}[.. to quiet).\"","explanation":"## \"Use braces when expanding arrays, e.g. ${array[idx]} (or ${var}[.. to quiet).\"\n\n### Problematic code:\n\n```sh\necho \"$array[@]\"\n```\n\n### Correct code:\n\n```sh\necho \"${array[@]}\"\n```\n\n### Rationale:\n\nSome languages use the syntax `$array[index]` to access an index of an arrays, but a shell will interpret this as `$array` followed by the unrelated literal string (or glob) `[index]`.\n\nCurly braces are needed to tell the shell that the square brackets are part of the expansion.\n\n### Exceptions\n\nIf you want the square brackets to be treated literally or as a glob, use `${var}[idx]` to prevent this warning.\n\nThis does not change how the script works, but clarifies your intent to ShellCheck as well as other programmers.\n[Source](https://github.com/koalaman/shellcheck/wiki/SC1087)"},{"id":"shellcheck_SC1088","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"Parsing stopped here. Invalid use of parentheses?","description":"Parsing stopped here. Invalid use of parentheses?","explanation":"## Parsing stopped here. Invalid use of parentheses?\n\n### Problematic code:\n\n\n```sh\ngrep ^(.*)\\1$ file\n```\n\nor\n\n\n```sh\nvar=myfunction(value)\n```\n\n\n### Correct code:\n\n```sh\ngrep '^(.*)\\1$' file\n```\n\nor\n\n```sh\nvar=$(myfunction value)\n```\n\n### Rationale:\n\nParentheses are shell syntax and must be used correctly.\n\nFor commands that expect literal parentheses, such as `grep` or `find`, the parentheses need to be quoted or escaped so the shell does not interpret them, but instead passes them to the command.\n\nFor shell syntax, the shell does not use them the way most other languages do, so avoid guessing at syntax based on previous experience. In particular:\n\n- Parentheses are NOT used to call functions.\n- Parentheses are NOT used to group expressions, except in arithmetic contexts.\n- Parentheses are NOT used in conditional statements or loops.\n- Parentheses are used differently in different contexts. `( .. )`, `$( .. )`, `$(( .. ))` and `var=(..)` are completely separate and independent structures with different meanings, and can not be broken down into operations on expressions in parentheses.\n\n  In C-like languages, `++` can't be broken down into two `+` operations, so you can't e.g. use `+ +` or `+(+)`. In the same way, all of the above are completely unrelated so that you can't do `$(1+1)` or `$( (1+1) )` in place of `$(( 1+1 ))`.\n\nIf you are trying to use parentheses for shell syntax, look up the actual syntax of the statement you are trying to use.\n\n### Exceptions:\n\nNone.\n\n[Source](https://github.com/koalaman/shellcheck/wiki/SC1088)"},{"id":"shellcheck_SC1089","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"Parsing stopped here. Is this keyword correctly matched up?","description":"Parsing stopped here. Is this keyword correctly matched up?","explanation":"## Parsing stopped here. Is this keyword correctly matched up?\n\n### Problematic code:\n\n```sh\nif true\nthen\n  echo hello\nfi\nfi\n```\n\n### Correct code:\n\n```sh\nif true\nthen\n  echo hello\nfi\n```\n\n### Rationale:\n\nThis error is typically seen when there are too many `fi`, `done` or `esac`s, or when there's a `do` or `then` without a corresponding `while`, `for` or `if`. This is often due to deleting a loop or conditional statement but not its terminator.\n\nIn some cases, it can even be caused by bad quoting:\n\n```sh\nvar=\"foo\nif [[ $var = \"bar ]\nthen\n  echo true\nfi\n```\n\nIn this case, the `if` ends up inside the double quotes, leaving the `then` dangling.\n\n### Exceptions:\n\nNone.\n\n[Source](https://github.com/koalaman/shellcheck/wiki/SC1089)"},{"id":"shellcheck_SC1090","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"Can't follow non-constant source. Use a directive to specify location.","description":"Can't follow non-constant source. Use a directive to specify location.","explanation":"## Can't follow non-constant source. Use a directive to specify location.\n\n### Problematic code:\n\n```sh\n. \"${util_path}\"\n```\n\n### Correct code:\n\n```sh\n# shellcheck source=src/util.sh\n. \"${util_path}\"\n```\n\n### Rationale:\n\nShellCheck is not able to include sourced files from paths that are determined at runtime. The file will not be read, potentially resulting in warnings about unassigned variables and similar.\n\nUse a [[Directive]] to point shellcheck to a fixed location it can read instead.\n\nShellCheck v0.7.2+ will strip a single expansion followed by a slash, e.g. `${var}/util.sh` or `$(dirname \"${BASH_SOURCE[0]}\")/util.sh`, and treat them as `./util.sh`. This  allowing the use of `source-path` directives or `-P` flags to specify the a location.\n\n### Exceptions:\n\nIf you don't care that ShellCheck is unable to account for the file, specify `# shellcheck source=/dev/null`.\n[Source](https://github.com/koalaman/shellcheck/wiki/SC1090)"},{"id":"shellcheck_SC1091","category":"CodeStyle","level":"Info","severityLevel":"Info","enabled":false,"parameters":[],"title":"Not following: (error message here)","description":"Not following: (error message here)","explanation":"## Not following: (error message here)\n\nReasons include: file not found, no permissions, not included on the command line, not allowing `shellcheck` to follow files with `-x`, etc.\n\n### Problematic code:\n\n```sh\nsource somefile\n```\n\n### Correct code:\n\nIn case you have access to the file, e.g. if it is included in your source code repository:\n\n```sh\n# shellcheck source=somefile\nsource somefile\n```\n\nIn case you do not have access to the file:\n\n```sh\n# shellcheck source=/dev/null\nsource somefile\n```\n\n### Rationale:\n\nShellCheck, for whichever reason, is not able to access the source file.\n\nThis could be because you did not include it on the command line, did not use `shellcheck -x` to allow following other files, don't have permissions or a variety of other problems.\n\nFeel free to ignore the error with a [[directive]].\n\n### Exceptions:\n\nShellCheck is unable to follow dynamic paths, such as `source \"$somedir/file\"`. For these cases, see [[SC1090: Can't follow non-constant source. Use a directive to specify location|SC1090]] instead. You may be seeing SC1091 because ShellCheck tried to be helpful and strip a leading dynamic path element as described on that page. \n\nIf you're fine with it, ignore the message with a [[directive]].\n\n[Source](https://github.com/koalaman/shellcheck/wiki/SC1091)"},{"id":"shellcheck_SC1094","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"Parsing of sourced file failed. Ignoring it.","description":"Parsing of sourced file failed. Ignoring it.","explanation":"## Parsing of sourced file failed. Ignoring it.\n\n### Problematic code:\n\n```sh\nsource mylib\n```\n\n### Correct code:\n\n```sh\n# shellcheck disable=SC1094\nsource mylib\n```\n\n(or fix `mylib`)\n\n### Rationale:\n\nShellCheck encountered a parsing error in a sourced file, `mylib` in the example.\n\nFix parsing error, or just disable it with a directive.\n\n### Exceptions:\n\nIf the file is fine and this is due to a known `shellcheck` bug, you can ignore it with a [[directive]] as in the example.\n\n[Source](https://github.com/koalaman/shellcheck/wiki/SC1094)"},{"id":"shellcheck_SC1095","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"You need a space or linefeed between the function name and body.","description":"You need a space or linefeed between the function name and body.","explanation":"## You need a space or linefeed between the function name and body.\n\n### Problematic code:\n\n```sh\nfunction foo{\n  echo \"hello world\"\n}\n```\n\n### Correct code:\n\nPrefer POSIX syntax:\n```sh\nfoo() {\n  echo \"hello world\"\n}\n```\n\nAlternatively, add the missing space between function name and opening `{`:\n```sh\n#           v-- Here\nfunction foo {\n  echo \"hello world\"\n}\n```\n### Rationale:\n\nWhen using `function` keyword function definitions without `()`, a space is required between the function name and the opening `{`.\n\n### Exceptions:\n\nNone.\n[Source](https://github.com/koalaman/shellcheck/wiki/SC1095)"},{"id":"shellcheck_SC1097","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"Unexpected ==. For assignment, use =. For comparison, use [/[[.","description":"Unexpected ==. For assignment, use =. For comparison, use [/[[.","explanation":"## Unexpected ==. For assignment, use =. For comparison, use [/[[.\n\n### Problematic code:\n\n```sh\nvar==value\n```\n\n### Correct code:\n\nAssignment:\n\n```sh\nvar=value\n```\n\nComparison:\n\n```sh\n[ \"$var\" = value ]\n```\n\n### Rationale:\n\nShellCheck has noticed that you're using `==` in an unexpected way. The two most common reasons for this is:\n\n* You wanted to assign a value but accidentally used `==` instead of `=`.\n\n* You wanted to compare two values, but neglected to use `[ .. ]` or `[[ .. ]]`.\n\n### Exceptions:\n\nIf you wanted to assign a literal equals sign, use quotes to make this clear:\n\n```sh\nvar=\"=sum(A1:A10)\"\n```\n\n[Source](https://github.com/koalaman/shellcheck/wiki/SC1097)"},{"id":"shellcheck_SC1098","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"Quote/escape special characters when using eval, e.g. eval \"a=(b)\".","description":"Quote/escape special characters when using eval, e.g. eval \"a=(b)\".","explanation":"## Quote/escape special characters when using eval, e.g. eval \"a=(b)\".\n\n### Problematic code:\n\n```sh\neval $var=(a b)\n```\n\n### Correct code:\n\n```sh\neval \"$var=(a b)\"\n```\n\n### Rationale:\n\nShells differ widely in how they handle unescaped parentheses in `eval` expressions.\n\n* `eval foo=bar` is allowed by dash, bash and ksh.\n* `eval foo=(bar)` is allowed by bash and ksh, but not dash.\n* `eval $var=(bar)` is allowed by ksh, but not bash or dash.\n* `eval foo() ( echo bar; )` is not allowed by any shell.\n\nSince the expression is evaluated as shell script code anyways, it should be passed in as a literal string without relying on special case parsing rules in the target shell. Quote/escape the characters accordingly.\n\n### Exceptions:\n\nNone.\n\n[Source](https://github.com/koalaman/shellcheck/wiki/SC1098)"},{"id":"shellcheck_SC1099","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"You need a space before the #.","description":"You need a space before the #.","explanation":"## You need a space before the #.\n\n### Problematic code:\n\n```sh\nwhile sleep 1\ndo# show time\n  date\ndone\n```\n\n### Correct code:\n\n```sh\nwhile sleep 1\ndo # show time\n  date\ndone\n```\n\n### Rationale:\n\nShellCheck has noticed that you have a keyword immediately followed by a `#`. In order for the `#` to start a comment, it needs to come after a word boundary such as a space.\n\n### Exceptions:\n\nNone.\n\n[Source](https://github.com/koalaman/shellcheck/wiki/SC1099)"},{"id":"shellcheck_SC1100","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"This is a unicode dash. Delete and retype as ASCII minus.","description":"This is a unicode dash. Delete and retype as ASCII minus.","explanation":"## This is a unicode dash. Delete and retype as ASCII minus.\n\n### Problematic code:\n\n```sh\n[[ 3 โgt 2 ]] # Uses unicode en-dash character\n```\n\n### Correct code:\n\n```sh\n[[ 3 -gt 2 ]] # Uses regular ASCII hyphen-minus character\n```\n### Rationale:\n\nA character that looks similar to `-` has made its way into your code. This is usually due to copy-pasting from blogs and other websites that formatted code as text, replacing the ASCII hyphen-minus with a Unicode dash character.\n\nTo fix it, simply delete and retype it.\n\nFor a large script, you can use your editor's Search&Replace by copy-pasting the bad dash.\n\n### Exceptions:\n\nNone. If you want a literal Unicode dash character, just quote it.\n[Source](https://github.com/koalaman/shellcheck/wiki/SC1100)"},{"id":"shellcheck_SC1101","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"Delete trailing spaces after \\ to break line (or use quotes for literal space).","description":"Delete trailing spaces after \\ to break line (or use quotes for literal space).","explanation":"## Delete trailing spaces after \\ to break line (or use quotes for literal space).\n\n### Problematic code:\n\n```sh\n# There are spaces after the backslash:\necho hello \\  \n     world\n```\n\n### Correct code:\n\n```sh\n# No spaces after the backslash:\necho hello \\\n     world\n```\n### Rationale:\n\nTo break a line you can use `\\` before the line break. However, if there are spaces after the backslash, the escape will apply to them instead of the line break, and the command will not continue on the next line.\n\nDelete the trailing spaces to make the line break work correctly.\n\n### Exceptions:\n\nIf you do want a literal escaped space at the end of a line you can ignore this error, but please reconsider and use quotes instead. Trailing whitespace is invisible and frequently stripped on purpose (by editor settings / precommits) or accident (copy-paste), and so should not be relied upon for correctness.\n[Source](https://github.com/koalaman/shellcheck/wiki/SC1101)"},{"id":"shellcheck_SC1102","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"Shells disambiguate `$((` differently or not at all. For `$(command substition)`, add space after `$(` . For `$((arithmetics))`, fix parsing errors.","description":"Shells disambiguate `$((` differently or not at all. For `$(command substition)`, add space after `$(` . For `$((arithmetics))`, fix parsing errors.","explanation":"## Shells disambiguate `$((` differently or not at all. For `$(command substition)`, add space after `$(` . For `$((arithmetics))`, fix parsing errors.\n\n### Problematic code:\n\n```sh\necho \"$((cmd \"$@\") 2>&1)\"\n```\n\n### Correct code:\n\n```sh\necho \"$( (cmd \"$@\") 2>&1)\"\n```\n### Rationale:\n\nYou appear to be using `$((` with two (or more) parentheses in a row, where the first `$(` should open a subshell. \n\nThis is an ill-defined structure that is parsed differently between different shells and shell versions. Prefer adding spaces to make it unambiguous, both to shells and humans.\n\nConsider the `$(((` in `$(((1)) )`:\n\nAsh, dash and Bash 1 parses it as `$(( (` and subsequently fail to find the matching `))`. Zsh and Bash 2+ looks ahead and parses it as `$( ((`. Ksh parses it as `$( ( (`. \n\n### Exceptions:\n\n**Alternatively**, you may indeed have correctly spaced your parentheses, but ShellCheck failed to parse `$((` as an arithmetic expression while accidentally succeeding in parsing it as `$(` + `(`. \n\nIn these cases, double check the syntax to ensure ShellCheck can parse the `$((`, or ignore this error and hope that it won't affect analysis too severely. \n[Source](https://github.com/koalaman/shellcheck/wiki/SC1102)"},{"id":"shellcheck_SC1104","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"Use #!, not just !, for the shebang.","description":"Use #!, not just !, for the shebang.","explanation":"## Use #!, not just !, for the shebang.\n\n### Problematic code:\n\n```sh\n!/bin/sh\necho \"Hello\"\n```\n\n### Correct code:\n\n```sh\n#!/bin/sh\necho \"Hello\"\n```\n\n### Rationale:\n\nYou appear to be specifying an interpreter in a shebang, but it's missing the hash part. The shebang must always start with `#!`. \n\nEven the name \"shebang\" itself comes from \"hash\" (`#`) + \"bang\" (`!`). \n\n### Exceptions:\n\nNone.\n[Source](https://github.com/koalaman/shellcheck/wiki/SC1104)"},{"id":"shellcheck_SC1105","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"Shells disambiguate (( differently or not at all. If the first ( should start a subshell, add a space after it.","description":"Shells disambiguate (( differently or not at all. If the first ( should start a subshell, add a space after it.","explanation":"## Shells disambiguate (( differently or not at all. If the first ( should start a subshell, add a space after it.\n\nSee [[SC1102]], the similar warning for ambiguous `$((`.\n[Source](https://github.com/koalaman/shellcheck/wiki/SC1105)"},{"id":"shellcheck_SC1106","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"In arithmetic contexts, use `<` instead of `-lt`","description":"In arithmetic contexts, use `<` instead of `-lt`","explanation":"## In arithmetic contexts, use `<` instead of `-lt`\n\nSimilarly, `>` instead of `-gt`, `<=` instead of `-le`, `>=` instead of `-ge`, `==` instead of `-eq`, `!=` instead of `-ne`.\n\n### Problematic code:\n\n```sh\nif (( 2 -lt 3 ))\nthen\n  echo \"True\"\nfi\n```\n\n### Correct code:\n\n```sh\nif (( 2 < 3 ))\nthen\n  echo \"True\"\nfi\n```\n\n### Rationale:\n\nThe comparators `-lt`, `-ge`, `-eq` and friends are flags for the `test` command aka `[`. You are instead using it in an arithmetic context, such as `(( .. ))` or `$(( .. ))`, where you should be using `<`, `>=`, `==` etc instead. \n\nIn arithmetic contexts, `-lt` is simply interpreted as \"subtract the value of `$lt`\", which is clearly not the intention.\n \n### Exceptions:\n\nIf you do want to subtract `$lt` you can add a space to make this clear to ShellCheck: `echo $((3 - lt))`\n\n### Related resources:\n\n* Help by adding links to BashFAQ, StackOverflow, man pages, POSIX, etc!\n[Source](https://github.com/koalaman/shellcheck/wiki/SC1106)"},{"id":"shellcheck_SC1107","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"This directive is unknown. It will be ignored.","description":"This directive is unknown. It will be ignored.","explanation":"## This directive is unknown. It will be ignored.\n\n### Problematic code:\n\n```sh\n# shellcheck foobar=baz\necho \"Hello World\"\n```\n\n### Correct code:\n\nDepends on your intention.\n\n### Rationale:\n\nShellCheck doesn't recognize the [[directive]] you're trying to use in a `# shellcheck` comment. See the [[Directive]]s page for supported directives.\n\nIt could be misspelled, or you could be using an older version of shellcheck that doesn't support it yet.\n\n### Exceptions:\n\nNone. If you wish to ignore this warning and continue without it, you need version 0.4.5 (commit 88c56ec) or later and a command grouping:\n\n```\n# Ignore an unrecognized directive in 0.4.5 or later:\n# shellcheck disable=SC1107\n{\n  # shellcheck unrecognized=directive\n  echo \"Hello World\"\n}\n```\n\nBefore 0.4.5, unrecognized directives are considered parse errors.\n[Source](https://github.com/koalaman/shellcheck/wiki/SC1107)"},{"id":"shellcheck_SC1108","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"You need a space before and after the = .","description":"You need a space before and after the = .","explanation":"## You need a space before and after the = .\n\n### Problematic code:\n\n```sh\n[ \"$var\"= 2 ]\n```\n\n### Correct code:\n\n```sh\n[ \"$var\" = 2 ]\n```\n### Rationale:\n\nYou appear to be missing the space on the left side of the operator. Shell in general, and `[` in particular, is space sensitive. Operators and operands must be separate tokens. \n\nPlease ensure that the operator, like the `=` in the example, has a space both before and after it.\n\n### Exceptions:\n\nNone. If you're comparing values in C style reverse order like `[ -eq == $1 ]`, use quotes: `[ \"-eq\" == \"$1\" ]`. Also, it's pointless since `[ a = b ]` doesn't assign.\n[Source](https://github.com/koalaman/shellcheck/wiki/SC1108)"},{"id":"shellcheck_SC1109","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"This is an unquoted HTML entity. Replace with corresponding character.","description":"This is an unquoted HTML entity. Replace with corresponding character.","explanation":"## This is an unquoted HTML entity. Replace with corresponding character.\n\n### Problematic code:\n\n```sh\nfoo &amp;&amp; bar\n```\n\n### Correct code:\n\n```sh\nfoo && bar\n```\n\n### Rationale:\n\nThere is an unquoted HTML entity, such as `&amp;`, `&gt;` or `&lt;` (instead of `&`, `>` and `<`) in your code. This usually happens when copy-pasting from a web site that has mismanaged its code formatting.\n\nYou should go through the entire script and replace HTML entities with their corresponding characters. \n\nDon't rely on ShellCheck to detect all of them. ShellCheck only warns about certain cases in certain contexts, while this issue tends to affect the entire script.\n\n### Exceptions:\n\nIf you want to run a command called `amp` after backgrounding another command, add a space: `foo & amp;`.\n[Source](https://github.com/koalaman/shellcheck/wiki/SC1109)"},{"id":"shellcheck_SC1110","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"This is a unicode quote. Delete and retype it (or quote to make literal).","description":"This is a unicode quote. Delete and retype it (or quote to make literal).","explanation":"## This is a unicode quote. Delete and retype it (or quote to make literal).\n\n### Problematic code:\n\n```sh\necho โhello worldโ\n```\n\n### Correct code:\n\n```sh\necho 'hello world'\n```\n\n### Rationale:\n\nSome software, like OS X, Word and WordPress, may automatically replace your regular quotes with slanted Unicode quotes. Try deleting and retyping them, and/or disable โsmart quotesโ in your editor or OS.\n\n### Exceptions\n\nIf you want to use typographic single quotes, you can put them in double quotes (or typographic double quotes in single quotes) to make shellcheck ignore them, e.g.,\n\n```sh\nprintf \"Warning: โwakeonlanโ is not installed.\\n\"\n```\n[Source](https://github.com/koalaman/shellcheck/wiki/SC1110)"},{"id":"shellcheck_SC1111","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"This is a unicode quote. Delete and retype it (or ignore/singlequote for literal).","description":"This is a unicode quote. Delete and retype it (or ignore/singlequote for literal).","explanation":"## This is a unicode quote. Delete and retype it (or ignore/singlequote for literal).\n\n### Problematic code:\n\n```sh\necho \"hello worldโ\n```\n\n### Correct code:\n\n```sh\necho \"hello world\"\n```\n\n### Rationale:\n\nSome software, like OS X, Word and WordPress, may automatically replace your regular quotes with slanted Unicode quotes. The shell does not recognize these quotes and will not respect them.\n\nIn this case, you have slanted double quotes in a double quoted string. Try deleting and retyping them, and/or disable โsmart quotesโ in your editor or OS.\n\n### Exceptions\n\nIf you want to use literal slanted double quotes for typographic reasons, you can put them in single quotes to make ShellCheck ignore them:\n\n```sh\nprintf 'Warning: โwakeonlanโ is not installed.\\n'\n```\n\nAlternatively, use single slanted Unicode quotes like so:\n\n```sh\nprintf \"Warning: โwakeonlanโ is not installed.\\n\"\n```\n\nYou can also just [[ignore]] this warning.\n[Source](https://github.com/koalaman/shellcheck/wiki/SC1111)"},{"id":"shellcheck_SC1112","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"This is a unicode quote. Delete and retype it (or ignore/doublequote for literal).","description":"This is a unicode quote. Delete and retype it (or ignore/doublequote for literal).","explanation":"## This is a unicode quote. Delete and retype it (or ignore/doublequote for literal).\n\n### Problematic code:\n\n```sh\necho 'hello worldโ\n```\n\n### Correct code:\n\n```sh\necho 'hello world'\n```\n\n### Rationale:\n\nSome software, like OS X, Word and WordPress, may automatically replace your regular quotes with slanted Unicode quotes. The shell does not recognize these quotes and will not respect them.\n\nIn this case, you have slanted single quotes in a single quoted string. Try deleting and retyping them, and/or disable โsmart quotesโ in your editor or OS.\n\n### Exceptions\n\nIf you want to use literal slanted single quotes for typographic reasons, you can put them in double quotes to make ShellCheck ignore them:\n\n```sh\nprintf \"Warning: โwakeonlanโ is not installed.\\\\n\"\n```\n\nYou can also just [[ignore]] this warning.\n[Source](https://github.com/koalaman/shellcheck/wiki/SC1112)"},{"id":"shellcheck_SC1113","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"Use #!, not just #, for the shebang.","description":"Use #!, not just #, for the shebang.","explanation":"## Use #!, not just #, for the shebang.\n\n### Problematic code:\n\n```sh\n# /bin/bash\necho \"Hello World\"\n```\n\n### Correct code:\n\n```sh\n#! /bin/bash\necho \"Hello World\"\n```\n### Rationale:\n\nYou appear to be specifying a shebang, but missing the bang (i.e. `!`). The shebang should always be on the form `#!/path/shell`.\n\n### Exceptions:\n\nNone.\n[Source](https://github.com/koalaman/shellcheck/wiki/SC1113)"},{"id":"shellcheck_SC1114","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"Remove leading spaces before the shebang.","description":"Remove leading spaces before the shebang.","explanation":"## Remove leading spaces before the shebang.\n\n### Problematic code:\n\n```sh\n  #!/bin/sh\necho \"Hello world\"\n```\n\n### Correct code:\n\n```sh\n#!/bin/sh\necho \"Hello World\"\n```\n### Rationale:\n\nThe script has leading spaces before the shebang (`#!`). This is not allowed. \n\nThe `#!` should be the first two bytes in the file, as they're used as a file signature by the OS to determine whether a file is a script.\n\n### Exceptions:\n\nNone.\n[Source](https://github.com/koalaman/shellcheck/wiki/SC1114)"},{"id":"shellcheck_SC1115","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"Remove spaces between # and ! in the shebang.","description":"Remove spaces between # and ! in the shebang.","explanation":"## Remove spaces between # and ! in the shebang.\n\n### Problematic code:\n\n```sh\n# !/bin/sh\necho \"Hello World\"\n```\n\n### Correct code:\n\n```sh\n#!/bin/sh\necho \"Hello World\"\n```\n### Rationale:\n\nThe script has spaces between the `#` and `!` in the shebang. This is not valid.\n\nRemove the spaces so the OS can correctly recognize the file as a script.\n\n### Exceptions:\n\nNone.\n[Source](https://github.com/koalaman/shellcheck/wiki/SC1115)"},{"id":"shellcheck_SC1116","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"Missing $ on a $((..)) expression? (or use ( ( for arrays).","description":"Missing $ on a $((..)) expression? (or use ( ( for arrays).","explanation":"## Missing $ on a $((..)) expression? (or use ( ( for arrays).\n\n### Problematic code:\n\n```sh\nvar=((foo+1))\n```\n\n### Correct code:\n\n```sh\nvar=$((foo+1))\n```\n\n### Rationale:\n\nYou appear to be missing the `$` on an assignment from an arithmetic expression `var=$((..))` .\n\nWithout the `$`, this is an array expression which is either nested (ksh) or invalid (bash). \n\n### Exceptions:\n\nIf you are trying to define a multidimensional Ksh array, add spaces between the `( (` to clarify:\n\n    var=( (1 2 3) (4 5 6) )\n\n[Source](https://github.com/koalaman/shellcheck/wiki/SC1116)"},{"id":"shellcheck_SC1117","category":"CodeStyle","level":"Info","severityLevel":"Info","enabled":false,"parameters":[],"title":"Backslash is literal in `\"\\n\"`. Prefer explicit escaping: `\"\\\\n\"`.","description":"Backslash is literal in `\"\\n\"`. Prefer explicit escaping: `\"\\\\n\"`.","explanation":"## Backslash is literal in `\"\\n\"`. Prefer explicit escaping: `\"\\\\n\"`.\n\n**Note: this warning has been retired due to being too pedantic**\n\n### Problematic code:\n\n```sh\nprintf \"%s\\n\" \"Hello\"\n```\n\n### Correct code:\n\n```sh\nprintf \"%s\\\\n\" \"Hello\"\n```\n\nor alternatively, with single quotes:\n\n```sh\nprintf '%s\\n' \"Hello\"\n```\n\n### Rationale:\n\nIn a double quoted string, you have escaped a character that has no special behavior when escaped. Instead, it's invoking the fallback behavior of being interpreted literally.\n\nInstead of relying on this implicit fallback, you should escape the backslash explicitly. This makes it clear that it's meant to be passed as a literal backslash in the string parameter.\n\n### Exceptions:\n\nNone. This is a stylistic issue which can be [[ignored]]. But can you name the 5 characters that *are* special when escaped in double quotes? \n\nThey are $, `, \", \\\\, or newline. More infos are available in the [bash manual].\n\n[bash manual]: https://www.gnu.org/software/bash/manual/html_node/Double-Quotes.html\n\n### Retired:\n\nThis warning is no longer emitted as of d8a32da07 (strictly after v0.5).\n\nThe number of harmlessly affected `printf`, `sed` and `grep` statements was significantly higher than the number of actual unexpanded escape sequences. It may return some day under a `-pedantic` type flag.\n[Source](https://github.com/koalaman/shellcheck/wiki/SC1117)"},{"id":"shellcheck_SC1118","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"Delete whitespace after the here-doc end token.","description":"Delete whitespace after the here-doc end token.","explanation":"## Delete whitespace after the here-doc end token.\n\n### Problematic code:\n\n\"โญ\" below indicates an otherwise invisible space:\n\n```sh\ncat << \"eof\"\nHello\neofโญ   \n```\n\n### Correct code:\n\n```sh\ncat << \"eof\"\nHello\neof\n```\n### Rationale:\n\nThe end token of your here document has trailing whitespace. This is invisible to the naked eye, but shells do not accept it.\n\nRemove the trailing whitespace.\n\n### Exceptions:\n\nNone.\n[Source](https://github.com/koalaman/shellcheck/wiki/SC1118)"},{"id":"shellcheck_SC1119","category":"CodeStyle","level":"Info","severityLevel":"Info","enabled":false,"parameters":[],"title":"Add a linefeed between end token and terminating ')'.","description":"Add a linefeed between end token and terminating ')'.","explanation":"## Add a linefeed between end token and terminating ')'.\n\n### Problematic code:\n\n```sh\nvar=$(fmt -s \"$COLUMNS\" << \"eof\"\nThis is a bunch of text\neof)\n\n```\n\n### Correct code:\n\n```sh\nvar=$(fmt -s \"$COLUMNS\" << \"eof\"\nThis is a bunch of text\neof\n)\n```\n### Rationale:\n\nWhen embedding a here document in `$(..)` or `(..)`, there needs to be a linefeed (newline) between the here doc token and the closing `)`. Please insert one.\n\nFailing to do so may cause warnings like this:\n\n    bash: warning: here-document at line 15 delimited by end-of-file (wanted `eof')`\n    dash: 5: Syntax error: end of file unexpected (expecting \")\")\n\n### Exceptions:\n\nThis error may be incorrectly emitted for `ksh`, where this is allowed. In this case, please either write it in a standard way or ignore this warning.\n[Source](https://github.com/koalaman/shellcheck/wiki/SC1119)"},{"id":"shellcheck_SC1120","category":"CodeStyle","level":"Info","severityLevel":"Info","enabled":false,"parameters":[],"title":"No comments allowed after here-doc token. Comment the next line instead.","description":"No comments allowed after here-doc token. Comment the next line instead.","explanation":"## No comments allowed after here-doc token. Comment the next line instead.\n\n### Problematic code:\n\n```sh\ncat << eof  # --- Start greeting --\nHello\neof         # --- End greeting ---\n```\n\n### Correct code:\n\n```sh\ncat << eof  # --- Start greeting --\nHello\neof\n            # --- End greeting ---\n```\n### Rationale:\n\nThe terminator token for a here document must be on an entirely separate line. No comments are allowed on this line.\n\nPlace the comment somewhere else, such as on the following line.\n\n### Exceptions:\n\nNone\n[Source](https://github.com/koalaman/shellcheck/wiki/SC1120)"},{"id":"shellcheck_SC1121","category":"CodeStyle","level":"Info","severityLevel":"Info","enabled":false,"parameters":[],"title":"Add ;/& terminators (and other syntax) on the line with the <<, not here.","description":"Add ;/& terminators (and other syntax) on the line with the <<, not here.","explanation":"## Add ;/& terminators (and other syntax) on the line with the <<, not here.\n\n### Problematic code:\n\n```sh\nsudo bash -s << \"END\"\n  cmd1\n  cmd2\nEND &\n\n```\n\n### Correct code:\n\n```sh\nsudo bash -s << \"END\" &\n  cmd1\n  cmd2\nEND\n```\n### Rationale:\n\nYou are using `&`, `;`, `&>` or similar after a here document. This is not allowed.\n\nThis should instead be part of the line that initiated the here document, i.e. the one with the `<<`. \n\nIf it helps, look at `<< \"END\"` as if it was `< file`, and make sure the resulting command is valid. This is what the shell does. You can then append here document data after the command.\n\n### Exceptions:\n\nNone.\n[Source](https://github.com/koalaman/shellcheck/wiki/SC1121)"},{"id":"shellcheck_SC1122","category":"CodeStyle","level":"Info","severityLevel":"Info","enabled":false,"parameters":[],"title":"Nothing allowed after end token. To continue a command, put it on the line with the `<<`.","description":"Nothing allowed after end token. To continue a command, put it on the line with the `<<`.","explanation":"## Nothing allowed after end token. To continue a command, put it on the line with the `<<`.\n\n### Problematic code:\n\n```sh\ncat << EOF\nHello\nEOF | nl\n```\n\n### Correct code:\n\n```sh\ncat << EOF | nl\nHello\nEOF\n```\n### Rationale:\n\nYou have a here document, and appear to have added text after the terminating token.\n\nThis is not allowed. If it was meant to continue the command, put it on the line with the `<<`.\n\nIf it helps, look at << \"END\" as if it was < file, and make sure the resulting command is valid. This is what the shell does. You can then append here document data after the command.\n\n### Exceptions:\n\nNone\n[Source](https://github.com/koalaman/shellcheck/wiki/SC1122)"},{"id":"shellcheck_SC1123","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"ShellCheck directives are only valid in front of complete compound commands, like `if`, not e.g. individual `elif` branches.","description":"ShellCheck directives are only valid in front of complete compound commands, like `if`, not e.g. individual `elif` branches.","explanation":"## ShellCheck directives are only valid in front of complete compound commands, like `if`, not e.g. individual `elif` branches.\n\n### Problematic code:\n\n```sh\nif [ \"$prod\" = \"true\" ]\nthen\n  echo \"Prod mode\"\n# shellcheck disable=2154\nelif [ \"$debug\" = \"true\" ]\nthen\n  echo \"Debug mode\"\nfi\n```\n\n### Correct code:\n```sh\n# Applies to entire `if...fi` command\n# shellcheck disable=2154\nif [ \"$prod\" = \"true\" ]\nthen\n  echo \"Prod mode\"\nelif [ \"$debug\" = \"true\" ]\nthen\n  echo \"Debug mode\"\nfi\n```\n\nor \n\n```sh\nif [ \"$prod\" = \"true\" ]\nthen\n  echo \"Prod mode\"\nelif  # Applies only to this [ .. ] command\n      # shellcheck disable=2154\n      [ \"$debug\" = \"true\" ]\nthen\n  echo \"Debug mode\"\nfi\n```\n\n\n### Rationale:\n\nYou appear to have put a directive before a non-command keyword, such as `elif`, `else`, `do`, `;;` or similar. \n\nUnlike many other linters, ShellCheck comment directives apply to the next shell command, rather than to the next line of text.\n\nThis means that you can put a directive in front of a `while` loop, `if` statement or function definition, and it will apply to that entire structure.\n\nHowever, it also means that you can not apply the directive to non-commands like an individual `elif` or `else` block since these are not commands by themselves, and rather just parts of an `if` compound command.\n\nPlease move the directive in front of the nearest applicable command that contains the code you want to apply it to, such as before the `if`. \n\n### Exceptions:\n\nNone.\n[Source](https://github.com/koalaman/shellcheck/wiki/SC1123)"},{"id":"shellcheck_SC1124","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"ShellCheck directives are only valid in front of complete commands like 'case' statements, not individual case branches.","description":"ShellCheck directives are only valid in front of complete commands like 'case' statements, not individual case branches.","explanation":"## ShellCheck directives are only valid in front of complete commands like 'case' statements, not individual case branches.\n\n### Problematic code:\n\n```sh\ncase $? in\n  0) echo \"Success\" ;;\n  # shellcheck disable=2154\n  *) echo \"$cmd $flag returned failure\" ;;\nesac\n\n```\n\n### Correct code:\n```sh\n# Applies to everything in the `case` statement\n# shellcheck disable=2154\ncase $? in\n  0) echo \"Success\" ;;\n  *) echo \"$cmd $flag returned failure\" ;;\nesac\n```\n\nor \n\n```sh\ncase $? in\n  0) echo \"Success\" ;;\n  *)\n     # Applies to a single command within the `case`\n     # shellcheck disable=2154\n     echo \"$cmd $flag returned failure\"\n     ;;\nesac\n```\n\n\n### Rationale:\n\nYou appear to have put a directive before a branch in a case statement.\n\nShellCheck directives can not be scoped to individual branches of `case` statements, only to the entire `case`, or to individual commands within it. Please move the directive as appropriate.\n\n(It is possible to apply directives to all commands within a `{ ..: }` command group, if you truly wish to apply a directive to multiple commands but not the full `case` statement.)\n    \n### Exceptions:\n\nNone.\n[Source](https://github.com/koalaman/shellcheck/wiki/SC1124)"},{"id":"shellcheck_SC1125","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"Invalid key=value pair in directive","description":"Invalid key=value pair in directive","explanation":"## Invalid key=value pair in directive\n\n### Problematic code:\n\n```sh\n# shellcheck disable=SC2153 (variable not a misspelling)\n```\n\n### Correct code:\n\n```sh\n# shellcheck disable=SC2153 # variable not a misspelling\n```\n\n### Rationale:\n\nA comment at the end of a directive must be preceded by a `#`\nto avoid it being interpreted as an instruction.\nThe [directive page](Directive#documenting-directive-use)\ncontains more guidance about commenting style.\n[Source](https://github.com/koalaman/shellcheck/wiki/SC1125)"},{"id":"shellcheck_SC1126","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"Place shellcheck directives before commands, not after.","description":"Place shellcheck directives before commands, not after.","explanation":"## Place shellcheck directives before commands, not after.\n\n### Problematic code:\n\n```sh\nvar=1 # shellcheck disable=SC2034\n```\n\n### Correct code:\n\n```sh\n# shellcheck disable=SC2034\nvar=1 \n```\n### Rationale:\n\nShellCheck expects directives to come before the relevant command. They are not allowed after.\n\n### Exceptions:\n\nIf this is not a directive and just a comment mentioning ShellCheck, please rewrite or capitalize:\n\n    var=1 # ShellCheck encourages lowercase variable names\n[Source](https://github.com/koalaman/shellcheck/wiki/SC1126)"},{"id":"shellcheck_SC1127","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"Was this intended as a comment? Use `#` in sh.","description":"Was this intended as a comment? Use `#` in sh.","explanation":"## Was this intended as a comment? Use `#` in sh.\n\n### Problematic code:\n\n```C\n// This is a comment.\n/* This too. */\n```\n\n### Correct code:\n\n```sh\n# This is a comment.\n# This too.\n```\n### Rationale:\n\nShellCheck found what appears to be a C-style comment, a line starting with `//` or `/*`.\n\nIn Bourne based shell scripts, the comment character is `#`\n\n### Exceptions:\n\nNone.\n[Source](https://github.com/koalaman/shellcheck/wiki/SC1127)"},{"id":"shellcheck_SC1128","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"The shebang must be on the first line. Delete blanks and move comments.","description":"The shebang must be on the first line. Delete blanks and move comments.","explanation":"## The shebang must be on the first line. Delete blanks and move comments.\n\n### Problematic code:\n\n```sh\n# Copyright 2018 Foobar, All rights reserved\n#!/bin/bash\n```\n\n### Correct code:\n\n```sh\n#!/bin/bash\n# Copyright 2018 Foobar, All rights reserved\n```\n\n### Rationale:\n\nA shebang only has an effect when it appears as the first line in a script. Specifically, the first two bytes of the file must be `#!`.\n\nAdding comments, copyright notices or simply an accidental blank line before it will turn a shebang into an ineffectual comment. This means that the script is no longer in charge of its own interpreter, and may fail to run or produce different results depending on the context it's run (e.g. it may work from `bash` but not from `zsh` or via `sudo`).\n\nDelete any leading blank lines, and move all comments after the shebang.\n\n### Exceptions:\n\nNone\n\n### Related resources:\n\n* Help by adding links to BashFAQ, StackOverflow, man pages, POSIX, etc!\n[Source](https://github.com/koalaman/shellcheck/wiki/SC1128)"},{"id":"shellcheck_SC1129","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"You need a space before the !.","description":"You need a space before the !.","explanation":"## You need a space before the !.\n\n### Problematic code:\n\n```sh\nwhile! [ -f file ]\ndo sleep 1; done\n```\n\n### Correct code:\n\n```sh\nwhile ! [ -f file ]\ndo sleep 1; done\n```\n### Rationale:\n\nShellCheck found a keyword immediately followed by a `!`. There needs to be a space between them.\n\n### Exceptions:\n\nNone\n[Source](https://github.com/koalaman/shellcheck/wiki/SC1129)"}],"pagination":{"cursor":"MTAw","limit":100,"total":411}}