{"data":[{"id":"shellcheck_SC1130","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"You need a space before the :.","description":"You need a space before the :.","explanation":"## You need a space before the :.\n\n### Problematic code:\n\n```sh\nuntil make\ndo:; done\n```\n\n### Correct code:\n\n```sh\nuntil make\ndo :; done\n```\n### Rationale:\n\nShellCheck found a keyword immediately followed by a `:`. `:` is a synonym for `true`, the command that \"does nothing, successfully\", and as a command name it needs a space. \n\n`do:` is as invalid as `dotrue`. Use `do :`, or preferably, `do true` for readability.\n\n### Exceptions:\n\nNone\n[Source](https://github.com/koalaman/shellcheck/wiki/SC1130)"},{"id":"shellcheck_SC1131","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"Use `elif` to start another branch.","description":"Use `elif` to start another branch.","explanation":"## Use `elif` to start another branch.\n\n### Problematic code:\n\n```sh\nif false\nthen\n  echo \"hi\"\nelseif true\nthen\n  echo \"ho\"\nfi\n```\n\n### Correct code:\n\n```sh\nif false\nthen\n  echo \"hi\"\nelif true\nthen\n  echo \"ho\"\nfi\n```\n### Rationale:\n\nShellCheck noticed that you appear to be using `elseif` or `elsif` as a keyword. This is not valid.\n\n`sh` instead uses `elif` as its alternative branch keyword.\n\n### Exceptions:\n\nIf you have made your own function called `elseif` and intend to call it, you can ignore this message.\n\n### Related resources:\n\n* Help by adding links to BashFAQ, StackOverflow, man pages, POSIX, etc!\n[Source](https://github.com/koalaman/shellcheck/wiki/SC1131)"},{"id":"shellcheck_SC1132","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"This `&` terminates the command. Escape it or add space after `&` to silence.","description":"This `&` terminates the command. Escape it or add space after `&` to silence.","explanation":"## This `&` terminates the command. Escape it or add space after `&` to silence.\n\n### Problematic code:\n\n```sh\ncurl https://www.google.com/search?q=cats&tbm=isch\n```\n\n### Correct code:\n\n```sh\ncurl \"https://www.google.com/search?q=cats&tbm=isch\"\n```\n### Rationale:\n\nAn unescaped and unquoted `&` terminates the command, but here it's used in the middle of what would otherwise be a shell word. This most commonly happens when copying a URL with query string parameters without escaping the `&`. \n\nEither quote or escape the `&` if you wanted it as a literal ampersand, or add a space after it to make it easier to see where the previous command stopped.\n\n### Exceptions:\n\nIf you do want to background one command and run another, e.g. `sleep 10&wait`, just add a space or linefeed after the `&` to make this more obvious: `sleep 10& wait`\n\nThis does not change the meaning of the script, it just makes it clear to ShellCheck (and other humans) that the `&` isn't supposed to be a part of the shell world.\n\n### Related resources:\n\n* Help by adding links to BashFAQ, StackOverflow, man pages, POSIX, etc!\n[Source](https://github.com/koalaman/shellcheck/wiki/SC1132)"},{"id":"shellcheck_SC1133","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"Unexpected start of line. If breaking lines, |/||/&& should be at the end of the previous one.","description":"Unexpected start of line. If breaking lines, |/||/&& should be at the end of the previous one.","explanation":"## Unexpected start of line. If breaking lines, |/||/&& should be at the end of the previous one.\n\n### Problematic code:\n\n```sh\ndmesg\n  | grep \"error\"\n```\n\n### Correct code:\n\n```sh\ndmesg |\n  grep \"error\"\n```\n\n### Rationale:\n\nShellCheck has found a line that unexpectedly started with `|`, `||` or `&&`. This usually happens when a line is broken incorrectly.\n\nWhen breaking around a `|`, `||` or `&&`, there are two options:\n\n* Break the line *after* this token. `dmesg` is a complete command by itself, but `dmesg |` is not so the shell knows to continue on the next line.\n* Use a `\\` at the end of the previous line to explicitly tell the shell to continue on the next.\n\n### Exceptions:\n\nIn v0.7.2 and below, this warning triggered incorrectly when starting a line with `&>`. In these versions, you can either [[ignore]] the warning, or move the redirection after the command name.\n\n### Related resources:\n\n* Help by adding links to BashFAQ, StackOverflow, man pages, POSIX, etc!\n[Source](https://github.com/koalaman/shellcheck/wiki/SC1133)"},{"id":"shellcheck_SC1135","category":"CodeStyle","level":"Info","severityLevel":"Info","enabled":false,"parameters":[],"title":"Prefer escape over ending quote to make `$` literal. Instead of `\"It costs $\"5`, use `\"It costs \\$5\"`","description":"Prefer escape over ending quote to make `$` literal. Instead of `\"It costs $\"5`, use `\"It costs \\$5\"`","explanation":"## Prefer escape over ending quote to make `$` literal. Instead of `\"It costs $\"5`, use `\"It costs \\$5\"`\n\n### Problematic code:\n\n```sh\necho \"The apples are $\"\"1 each\"\neval \"var=$\"name\n```\n\n### Correct code:\n\n```sh\necho \"The apples are \\$1 each\"\neval \"var=\\$name\"\n# or better yet: var=\"${!name}\"\n```\n\n### Rationale:\n\nThe script appears to be closing a double quoted string for the sole purpose of making a dollar sign `$` literal.\n\nWhile this happens to work, the better solution is instead to escape it with a backslash. This allows the double quoted string to continue uninterrupted, thereby reducing the visual noise of stopping and starting quotes in the middle of a shell word.\n\n### Exceptions:\n\nNone\n\n### Related resources:\n\n* Help by adding links to BashFAQ, StackOverflow, man pages, POSIX, etc!\n[Source](https://github.com/koalaman/shellcheck/wiki/SC1135)"},{"id":"shellcheck_SC1139","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"Use || instead of '-o' between test commands.","description":"Use || instead of '-o' between test commands.","explanation":"## Use || instead of '-o' between test commands.\n\nAnd variations, like \"Use `&&` instead of `and`\".\n\n### Problematic code:\n\n```sh\nif [ \"$1\" = \"-v\" ] -o [ -n \"$VERBOSE\" ]\nthen\n  echo \"Verbose log\"\nfi\n```\n\n### Correct code:\n\n```sh\nif [ \"$1\" = \"-v\" ] || [ -n \"$VERBOSE\" ]\nthen\n  echo \"Verbose log\"\nfi\n```\n### Rationale:\n\nYou have a `[ .. ]` or `[[ .. ]]` test expression followed by `-o`/`-a` (or by Python-style `or`/`and`).\n\n`-o` and `-a` work *inside* `[ .. ]`, but they do not work *between* them. The Python operators `or` and `and` are never recognized in Bash.\n\nTo join two separate test expressions, instead use `||` for \"logical OR\", or `&&` for \"logical AND\".\n\n### Exceptions:\n\nNone\n\n### Related resources:\n\n* Help by adding links to BashFAQ, StackOverflow, man pages, POSIX, etc!\n[Source](https://github.com/koalaman/shellcheck/wiki/SC1139)"},{"id":"shellcheck_SC1140","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"Unexpected parameters after condition. Missing &&/||, or bad expression?","description":"Unexpected parameters after condition. Missing &&/||, or bad expression?","explanation":"## Unexpected parameters after condition. Missing &&/||, or bad expression?\n\n### Problematic code:\n\n```sh\n[ \"$1\" ] input=\"$1\"\n```\n\n### Correct code:\n\n```sh\n[ \"$1\" ] && input=\"$1\"\n```\n### Rationale:\n\nShellCheck found characters (other than redirections) after the `]` or `]]` in a test expression. This is not valid.\n\nThis sometimes happens when there was an additional expression or command, but joining `||` or `&&` is missing. Alternatively, it could happen due to typos (like `[[ $1 ]]]` with an extra `]`), or generally from malformed test expressions.\n\n### Exceptions:\n\nNone\n\n### Related resources:\n\n* Help by adding links to BashFAQ, StackOverflow, man pages, POSIX, etc!\n[Source](https://github.com/koalaman/shellcheck/wiki/SC1140)"},{"id":"shellcheck_SC1141","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"Unexpected tokens after compound command. Bad redirection or missing ;/&&/||/|?","description":"Unexpected tokens after compound command. Bad redirection or missing ;/&&/||/|?","explanation":"## Unexpected tokens after compound command. Bad redirection or missing ;/&&/||/|?\n\n### Problematic code:\n\n```sh\nwhile echo \"$2\"; do true; done \\\n  head -n \"$1\"\n\nwhile sleep 1; do date; done > my file\n```\n\n### Correct code:\n\n```sh\nwhile echo \"$2\"; do true; done \\\n  | head -n \"$1\"\n\nwhile sleep 1; do date; done > \"my file\"\n```\n### Rationale:\n\nShellCheck found unexpected trailing characters after a compound command.\n\nThe only things allowed after compound commands are redirections, shell keywords, and the various command separators (`;`, `&`, `|`, `&&`, `||`).\n\nIn the first example, a `|` was missing, causing `head` to appear as an unexpected trailing word, instead of being piped to. In the second example, a lack of quoting caused `file` to appear as an unexpected trailing word, instead of being part of the redirection.\n\nExamine your statement and correct the problem.\n\n### Exceptions:\n\nNone\n\n### Related resources:\n\n* Help by adding links to BashFAQ, StackOverflow, man pages, POSIX, etc!\n[Source](https://github.com/koalaman/shellcheck/wiki/SC1141)"},{"id":"shellcheck_SC1142","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"Use 'done < <(cmd)' to redirect from process substitution (currently missing one '<').","description":"Use 'done < <(cmd)' to redirect from process substitution (currently missing one '<').","explanation":"##  Use 'done < <(cmd)' to redirect from process substitution (currently missing one '<').\n\n### Problematic code:\n\n```sh\nsum=0\nwhile IFS=\"\" read -r n\ndo\n  (( sum += n ))\ndone <(file) \n```\n\n### Correct code:\n\n```sh\nsum=0\nwhile IFS=\"\" read -r n\ndo\n  (( sum += n ))\ndone < <(file) \n```\n### Rationale:\n\nShellCheck found a `done` keyword followed by a process substitution, e.g. `done <(cmd)`.\n\nThe intention was most likely to redirect from this process substitution, in which case you will need one extra `<`: `done < <(cmd)`.\n\nThis is because `<(cmd)` expands to a filename (e.g. `/dev/fd/63`), and you need a `<` to redirect from filenames.\n   \n### Exceptions:\n\nNone\n\n### Related resources:\n\n* Help by adding links to BashFAQ, StackOverflow, man pages, POSIX, etc!\n[Source](https://github.com/koalaman/shellcheck/wiki/SC1142)"},{"id":"shellcheck_SC1143","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"This backslash is part of a comment and does not continue the line.","description":"This backslash is part of a comment and does not continue the line.","explanation":"## This backslash is part of a comment and does not continue the line.\n\n### Problematic code:\n\n```sh\nsed \\\n  -e \"s/HOST/$HOSTNAME/g\"   \\\n# -e \"s/USER/$USER/g\"       \\\n  -e \"s/ARCH/$(uname -m)/g\" \\\n  \"$buildfile\"\n```\n\n### Correct code:\n\n\n```sh\nsed \\\n  -e \"s/HOST/$HOSTNAME/g\"   \\\n  -e \"s/ARCH/$(uname -m)/g\" \\\n  \"$buildfile\"\n\n# This comment is moved out:\n# -e \"s/USER/$USER/g\"       \\\n```\n\nor using backticked, inlined comments:\n\n```sh\nsed \\\n  -e \"s/HOST/$HOSTNAME/g\"   \\\n`# -e \"s/USER/$USER/g\"`     \\\n  -e \"s/ARCH/$(uname -m)/g\" \\\n  \"$buildfile\"\n```\n\n(ShellCheck recognizes this idiom and does not suggest quotes or `$()`, neither of which would have worked)\n\n### Rationale:\n\nShellCheck found a line continuation followed by a commented line that appears to try to do the same.\n\nBackslash line continuations are not respected in comments, and the line instead simply terminates. This is a problem when commenting out one line in a multi-line command like the example.\n\nInstead, either move the line away from its statement, or use an `` `# inline comment` `` in an unquoted backtick command substitution. \n\n### Exceptions:\n\nNone.\n\n### Related resources:\n\n* Help by adding links to BashFAQ, StackOverflow, man pages, POSIX, etc!\n[Source](https://github.com/koalaman/shellcheck/wiki/SC1143)"},{"id":"shellcheck_SC2000","category":"CodeStyle","level":"Info","severityLevel":"Info","enabled":false,"parameters":[],"title":"See if you can use ${#variable} instead","description":"See if you can use ${#variable} instead","explanation":"# See if you can use ${#variable} instead\n\n`${#variable}` will be equal to the number of characters in `\"${variable}\"`\n\nThis is the same result as `\"$( echo \"$variable\" | wc -m )\"`\nWhen \"$variable\" only contains single-byte characters, it's also the same as `\"$( echo \"$variable\" | wc -c )\"`\n\n## example code\n\n``` bash\n#!/usr/bin/env  bash\n\nif [ \"$( echo \"$1\" | wc -c )\" -gt 1 ]; then\n  echo \"greater than 1\"\nfi\n\nif [ \"$( echo \"$1\" | wc -m )\" -gt 1 ]; then\n  echo \"greater than 1\"\nfi\n\nif [ \"${#1}\" -gt 1 ]; then\n  echo \"greater than 1\"\nfi\n```\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2000)"},{"id":"shellcheck_SC2001","category":"CodeStyle","level":"Info","severityLevel":"Info","enabled":true,"parameters":[],"title":"SC2001: See if you can use ${variable//search/replace} instead.","description":"SC2001: See if you can use ${variable//search/replace} instead.","explanation":"## SC2001: See if you can use ${variable//search/replace} instead.\n\n### Problematic code:\n\n```sh\nstring=\"stirng\" ; echo \"$string\" | sed -e \"s/ir/ri/\"\n```\n\n### Correct code:\n\n```sh\nstring=\"stirng\" ; echo \"${string//ir/ri}\"\n```\n\n### Rationale:\n\nLet's assume somewhere earlier in your code you have put data into a variable (Ex: $string). Now you want to do a search and replace inside the contents of $string and echo the contents out. You could pass this to sed as done in the example above, but for simple substitutions, parameter expansion can do it with less overhead.\n\n### Exceptions\n\nOccasionally a more complex sed substitution is required. For example, getting the last character of a string.\n\n```sh\nstring=\"stirng\" ; echo \"$string\" | sed -e \"s/^.*\\(.\\)$/\\1/\"\n```\n\nThis is a bit simple for the example and there are alternative ways of doing this in the shell, but this SC2001 flags on several of my crazy complex sed commands which are beyond the scope of this example. Utilizing some of the more complex capabilities of sed is required occasionally and it is safe to ignore SC2001.\n\n### Related resources:\n\n* Bash Manual: [Shell Parameter Expansion](https://www.gnu.org/software/bash/manual/bashref.html#Shell-Parameter-Expansion)\n* Wooledge BashGuide: [Parameter Expansion](https://mywiki.wooledge.org/BashGuide/Parameters#Parameter_Expansion).\n* Bash Hacker Wiki: [Parameter Expansion](http://wiki.bash-hackers.org/syntax/pe)\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2001)"},{"id":"shellcheck_SC2002","category":"Performance","level":"Info","severityLevel":"Info","enabled":true,"parameters":[],"title":"Useless cat. Consider 'cmd < file | ..' or 'cmd file | ..' instead.","description":"Useless cat. Consider 'cmd < file | ..' or 'cmd file | ..' instead.","explanation":"# Useless cat. Consider 'cmd < file | ..' or 'cmd file | ..' instead.\n\n### Problematic code:\n\n```sh\ncat file | tr ' ' _ | nl\ncat file | while IFS= read -r i; do echo \"${i%?}\"; done\n```\n\n### Correct code:\n\n```sh\n< file tr ' ' _ | nl  \nwhile IFS= read -r i; do echo \"${i%?}\"; done < file\n```\n\n### Rationale:\n\n`cat` is a tool for con\"cat\"enating files. Reading a single file as input to a program is considered a [Useless Use Of Cat (UUOC)](http://en.wikipedia.org/wiki/Cat_(Unix)#Useless_use_of_cat).\n\nIt's more efficient and less roundabout to simply use redirection. This is especially true for programs that can benefit from seekable input, like `tail` or `tar`.\n\nMany tools also accept optional filenames, e.g. `grep -q foo file` instead of `cat file | grep -q foo`.\n\n### Exceptions\n\nPointing out UUOC is a long standing shell programming tradition, and removing them from a short-lived pipeline in a loop can speed it up by 2x. However, it's not necessarily a good use of time in practice, and rarely affects correctness. [[Ignore]] as you see fit.\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2002)"},{"id":"shellcheck_SC2003","category":"CodeStyle","level":"Info","severityLevel":"Info","enabled":true,"parameters":[],"title":"expr is antiquated. Consider rewriting this using $((..)), ${} or __[[__ __]]__.","description":"expr is antiquated. Consider rewriting this using $((..)), ${} or __[[__ __]]__.","explanation":"# expr is antiquated. Consider rewriting this using $((..)), ${} or __[[__ __]]__.\n\n### Problematic code:\n\n```sh\ni=$(expr 1 + 2)\nl=$(expr length \"$var\")\n```\n\n### Correct code:\n\n```sh\ni=$((1+2))\nl=${#var}\n```\n\n**WARNING:** constants with a leading 0 are interpreted as octal numbers by bash, but not by expr. Then you should specify the base when a leading zero may occur:\n```sh\n$ x=08\n$ echo $(expr 1 + $x)\n9\n$ echo $((1 + $x))\n-bash: 1 + 08: value too great for base (error token is \"08\")\n$ echo $((1 + 10#$x))\n9\n```\nSee [issue #1910](https://github.com/koalaman/shellcheck/issues/1910#issuecomment-610439789)\n\n### Rationale:\n\n[To quote POSIX:](https://pubs.opengroup.org/onlinepubs/009695399/utilities/expr.html#tag_04_50_17)\n\n> The expr utility has a rather difficult syntax [...] In many cases, the arithmetic and string features provided as part of the shell command language are easier to use than their equivalents in expr. Newly written scripts should avoid expr in favor of the new features within the shell.\n\n### Exceptions\n\n`sh` doesn't have a great replacement for the `:` operator (regex match). ShellCheck tries not to warn when using expr with `:`, but e.g. `op=:; expr string \"$op\" regex` will still trigger it.\n\nOther than that, all uses of `expr` can be rewritten to use modern shell features instead.\n\nBash has `[[ string =~ regex ]]`, so not even `expr .. : ..` is necessary.\n\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2003)"},{"id":"shellcheck_SC2004","category":"CodeStyle","level":"Info","severityLevel":"Info","enabled":true,"parameters":[],"title":"$/${} is unnecessary on arithmetic variables.","description":"$/${} is unnecessary on arithmetic variables.","explanation":"# $/${} is unnecessary on arithmetic variables.\n\n### Problematic code:\n\n```sh\necho $(($n + ${arr[i]}))\n```\n\n### Correct code:\n\n```sh\necho $((n + arr[i]))\n```\n\n### Rationale:\n\nThe `$` or `${..}` on regular variables in arithmetic contexts is unnecessary, and can even lead to subtle bugs. This is because the contents of `$((..))` is first expanded into a string, and then evaluated as an expression:\n\n```sh\n$ a='1+1'\n$ echo $(($a * 5))    # becomes 1+1*5\n6\n$ echo $((a * 5))     # evaluates as (1+1)*5\n10\n```\n\nThe `$` is unavoidable for special variables like `$1` vs `1`, `$#` vs `#`. It's also required when adding modifiers to parameters expansions, like `${#var}` or `${var%-}`. ShellCheck does not warn about these cases.\n\nThe `$` is also required (and not warned about) when you need to specify the *base* for a variable value:\n\n```sh\n$ a=09\n$ echo $((a + 1))          # leading zero forces octal interpretation\nbash: 09: value too great for base (error token is \"09\")\n$ echo $((10#a + 1))\nbash: 10#a: value too great for base (error token is \"10#a\")\n$ echo $((10#$a + 1))\n10\n```\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2004)"},{"id":"shellcheck_SC2005","category":"CodeStyle","level":"Info","severityLevel":"Info","enabled":false,"parameters":[],"title":"Useless `echo`? Instead of `echo $(cmd)`, just use `cmd`","description":"Useless `echo`? Instead of `echo $(cmd)`, just use `cmd`","explanation":"Useless `echo`? Instead of `echo $(cmd)`, just use `cmd`\n--------------------------------------------------------\n\n### Problematic code:\n\n```sh\necho \"$(whoami)\"\n```\n\n### Correct code:\n\n```sh\nwhoami\n```\n\n### Rationale\n\nShellCheck found the unnecessary construct `echo \"$(somecommand here)\"`.\n\nThis is generally due to a misunderstanding about what `echo` does. It has no role in \"showing on screen\" or similar, but simply writes a string to standard output. This is also how all other programs output data.\n\n`echo \"$(somecommand)\"` will capture the output `somecommand` writes to standard output and write it to standard output, where it was already going. At best this is a no-op, but it may have several other negative effects:\n\n* It disables parallel processing in pipelines, such as `echo \"$(find . -name '*.iso')\" | xargs sha1sum` which does not allow iterating files and checksumming at the same time. Similarly, users don't see incremental updates as programs run.\n* It introduces shell and echo related pitfalls like being unable to output the string `-n`, stripping NUL bytes and trailing linefeeds, and expanding escape sequences in some shells but not others.\n* It suppresses the exit code of the command, so that `echo \"$(grep '^user:' /etc/passwd)\"` no longer returns with failure when the user is not found.\n* It does not allow programs to tailor their output for terminals, such as `ls` vs `echo \"$(ls)\"` where the former outputs columns and colors according to user preferences, while the latter doesn't.\n* It uses unnecessary memory to buffer up the data before writing it where it was already going.\n\nTo avoid all this, simply replace `echo \"$(somecommand)\"` with `somecommand` as in the example. It's shorter, faster, and more correct.\n\n### Exceptions\n\nIf you are relying on one of the otherwise detrimental effects for correctness, you can consider one of:\n\n```\n# Suppress exit code without the other negative effects\ncmd || true\n\n# Disable tty specific output without the other negative effects\ncmd | cat\n\n# Buffer up potentially large output without using more memory or modifying the content in any way\ncmd > file.tmp\ncat file.tmp\n\n# Exactly like `echo \"$(cmd)\"`, but allows output like `-n` and works the same across shells\nprintf '%s\\n' \"$(cmd)\"\n```\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2005)"},{"id":"shellcheck_SC2006","category":"CodeStyle","level":"Info","severityLevel":"Info","enabled":true,"parameters":[],"title":"Use `$(...)` notation instead of legacy backticked `` `...` ``.","description":"Use `$(...)` notation instead of legacy backticked `` `...` ``.","explanation":"# Use `$(...)` notation instead of legacy backticked `` `...` ``.\n\n### Problematic code\n\n```sh\necho \"You are running on `uname`\"\n```\n\n### Correct code\n\n```sh\necho \"You are running on $(uname)\"\n```\n\n### Rationale\n\nBacktick command substitution `` `...` `` is legacy syntax with several issues.\n\n1. It has a series of undefined behaviors related to quoting in POSIX.\n1. It imposes a custom escaping mode with surprising results.\n1. It's exceptionally hard to nest.\n\n`$(...)` command substitution has none of these problems, and is therefore strongly encouraged.\n\n### Exceptions\n\nNone.\n\n### Related resources:\n\n* [BashFaq: Why is `$(...)` preferred over `` `...` `` (backticks)?](http://mywiki.wooledge.org/BashFAQ/082)\n* [StackOverflow: What is the difference between $(command) and `` `command` `` in shell programming?](https://stackoverflow.com/questions/4708549/shell-programming-whats-the-difference-between-command-and-command)\n\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2006)"},{"id":"shellcheck_SC2007","category":"CodeStyle","level":"Info","severityLevel":"Info","enabled":false,"parameters":[],"title":"Use $((..)) instead of deprecated $[..]","description":"Use $((..)) instead of deprecated $[..]","explanation":"# Use $((..)) instead of deprecated $[..]\n\n### Problematic code\n\n```sh\nn=1\nn=$[n+1]\n```\n\n### Correct code\n\n```sh\nn=1\nn=$((n+1))\n```\n\n### Rationale\n\nThe `$[..]` syntax was deprecated in Bash 2.0 and replaced with the standard `$((..))` syntax from Korn shell\n\n### Exceptions\n\nNone.\n\n### See also\n\n- http://unix.stackexchange.com/questions/209833/what-does-a-dollar-sign-followed-by-a-square-bracket-mean-in-bash\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2007)"},{"id":"shellcheck_SC2009","category":"BestPractice","level":"Info","severityLevel":"Info","enabled":false,"parameters":[],"title":"SC2009 Consider using pgrep instead of grepping ps output.","description":"SC2009 Consider using pgrep instead of grepping ps output.","explanation":"## SC2009 Consider using pgrep instead of grepping ps output.\n\n### Problematic Code:\n\n```sh\nps ax | grep -v grep | grep \"$service\" > /dev/null\n```\n\n### Correct Code:\n\n```sh\npgrep -f \"$service\" > /dev/null\n```\n\n### Rationale:\n\nIf you are just after a pid from a running program, then pgrep is a much safer alternative. Especially if you are also looking for a pid belonging to a certain user or group. All of the parameters are in one command and it can eliminate multiple greps, cuts, seds, awks, etc.\n\nIf you want a field that's not the pid, consider doing this through `ps` + `pgrep` instead of `ps` + `grep`:\n\n```\nfor pid in $(pgrep '^python$')\ndo\n  user=$(ps -o user= -p \"$pid\")\n  echo \"The process $pid is run by $user\"\ndone\n```\n\nThis is more robust than `ps .. | grep python | cut ..` because it does not try to match against unrelated fields, such as if the user's name was `pythonguru`.\n\n### Exceptions\n\nYou can [[ignore]] this error if you are trying to match against something that `pgrep` doesn't support:\n\n```\n# pgrep does not support filtering by 'nice' value\n# shellcheck disable=SC2009\nps -axo nice=,pid= | grep -v '^  0'\n```\n\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2009)"},{"id":"shellcheck_SC2010","category":"BestPractice","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"Don't use ls | grep. Use a glob or a for loop with a condition to allow non-alphanumeric filenames.","description":"Don't use ls | grep. Use a glob or a for loop with a condition to allow non-alphanumeric filenames.","explanation":"## Don't use ls | grep. Use a glob or a for loop with a condition to allow non-alphanumeric filenames.\n\n### Problematic code:\n\n```sh\nls /directory | grep mystring\n```\n\nor\n\n```sh\nrm $(ls | grep -v '\\.c$')\n```\n\n### Correct code:\n\n```sh\nls /directory/*mystring*\n```\n\nor\n\n```sh\n# BASH\nshopt -s extglob\nrm -- !(*.c)\n\n# POSIX\nfor f in ./*\ndo\n  case $f in\n    *.c) true;;\n    *) rm \"$f\";;\n  esac\ndone\n```\n\n### Rationale:\n\n[Parsing ls](https://mywiki.wooledge.org/ParsingLs) is generally a bad idea because the output is fragile and human readable. To better handle non-alphanumeric filenames, use a glob. If you need more advanced matching than a glob can provide, use a `for` loop.\n\n### Exceptions:\n\n- `ls` has sorting options that are tricky to get right with other commands. If a specific order of files is needed, ls _\\<sort options\\>_ | grep might be the best alternative.\n- network shares like AFS behave much faster using ls\n\n### Related resources:\n\n* [BashFaq: How can I find and safely handle file names containing newlines, spaces or both?](https://mywiki.wooledge.org/BashFAQ/020)\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2010)"},{"id":"shellcheck_SC2011","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"Use `find -print0` or `find -exec` to better handle non-alphanumeric filenames.","description":"Use `find -print0` or `find -exec` to better handle non-alphanumeric filenames.","explanation":"## Use `find -print0` or `find -exec` to better handle non-alphanumeric filenames.\n\n### Problematic code:\n\n```sh\nls | xargs -n1 wc -w\n```\n\n### Correct code:\n\n```sh\nfind . -maxdepth 1 -print0 | xargs -0 -n1 wc -w\n```\n\n```sh\nfind . -maxdepth 1 -exec wc -w {} \\;\n```\n\n### Rationale:\n\nUsing `-print0` separates each output with a NUL character, rather than a newline, which is safer to pipe into `xargs`. Alternatively using `-exec` avoids the problem of piping and parsing filenames in the first place.\n\nSee [[SC2012]] for more details on this issue.\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2011)"},{"id":"shellcheck_SC2012","category":"BestPractice","level":"Info","severityLevel":"Info","enabled":false,"parameters":[],"title":"Use `find` instead of `ls` to better handle non-alphanumeric filenames.","description":"Use `find` instead of `ls` to better handle non-alphanumeric filenames.","explanation":"## Use `find` instead of `ls` to better handle non-alphanumeric filenames.\n\n### Problematic code:\n\n```sh\nls -l | grep \" $USER \" | grep '\\.txt$'\n```\n```sh\nNUMGZ=\"$(ls -l *.gz | wc -l)\"\n```\n\n### Correct code:\n\n```sh\nfind . -maxdepth 1 -name '*.txt' -user \"$USER\"  # Using the names of the files\n```\n```sh\ngz_files=(*.gz)\nnumgz=${#gz_files[@]} # Sometimes, you just need a count\n````\n### Rationale:\n\n`ls` is only intended for human consumption: it has a loose, non-standard format and may \"clean up\" filenames to make output easier to read.\n\nHere's an example:\n\n```sh\n$ ls -l\ntotal 0\n-rw-r----- 1 me me 0 Feb  5 20:11 foo?bar\n-rw-r----- 1 me me 0 Feb  5  2011 foo?bar\n-rw-r----- 1 me me 0 Feb  5 20:11 foo?bar\n```\n\nIt shows three seemingly identical filenames, and did you spot the time format change? How it formats and what it redacts can differ between locale settings, `ls` version, and whether output is a tty.\n\n### Tips for replacing `ls` with `find`:\n\n#### Just the filenames, ma'am\n\n`ls` can usually be replaced by `find` if it's just the filenames, or a count of them, that you're after. Note that if you are using `ls` to get at the contents of a directory, a straight substitution of `find` may not yield the same results as `ls`. Here is an example:\n\n```\n$ ls -c1 .snapshot\nrnapdev1-svm_4_05am_6every4hours.2019-04-01_1605\nrnapdev1-svm_4_05am_6every4hours.2019-04-01_2005\nrnapdev1-svm_4_05am_6every4hours.2019-04-02_0005\nrnapdev1-svm_4_05am_6every4hours.2019-04-02_0405\nrnapdev1-svm_4_05am_6every4hours.2019-04-02_0805\nrnapdev1-svm_4_05am_6every4hours.2019-04-02_1205\nsnapmirror.1501b4aa-3f82-11e8-9c31-00a098cef13d_2147868328.2019-04-01_190000\n```\nversus\n```\n$ find .snapshot -maxdepth 1\n.snapshot\n.snapshot/rnapdev1-svm_4_05am_6every4hours.2019-04-02_0005\n.snapshot/rnapdev1-svm_4_05am_6every4hours.2019-04-02_0405\n.snapshot/rnapdev1-svm_4_05am_6every4hours.2019-04-02_0805\n.snapshot/rnapdev1-svm_4_05am_6every4hours.2019-04-01_1605\n.snapshot/rnapdev1-svm_4_05am_6every4hours.2019-04-01_2005\n.snapshot/rnapdev1-svm_4_05am_6every4hours.2019-04-02_1205\n.snapshot/snapmirror.1501b4aa-3f82-11e8-9c31-00a098cef13d_2147868328.2019-04-01_190000\n```\nYou can see two differences here. The first is that the `find` output has the full paths to the found files, relative to the current working directory from which `find` was run whereas `ls` only has the filenames. You may have to adjust your code to not add the directory to the filenames as you process them when moving from `ls` to `find`, or (with GNU find) use `-printf '%P\\n'` to print just the filename.\n\nThe second difference in the two outputs is that the `find` command includes the searched directory as an entry. This can be eliminated by also using `-mindepth 1` to skip printing the root path, or using a negative name option for the searched directory:\n```\n$ find .snapshot -maxdepth 1 ! -name .snapshot\n.snapshot/rnapdev1-svm_4_05am_6every4hours.2019-04-02_0005\n.snapshot/rnapdev1-svm_4_05am_6every4hours.2019-04-02_0405\n.snapshot/rnapdev1-svm_4_05am_6every4hours.2019-04-02_0805\n.snapshot/rnapdev1-svm_4_05am_6every4hours.2019-04-01_1605\n.snapshot/rnapdev1-svm_4_05am_6every4hours.2019-04-01_2005\n.snapshot/rnapdev1-svm_4_05am_6every4hours.2019-04-02_1205\n.snapshot/snapmirror.1501b4aa-3f82-11e8-9c31-00a098cef13d_2147868328.2019-04-01_190000\n```\n\n**Note:** If the directory argument to `find` is a fully expressed path (`/home/somedir/.snapshot`), then you should use `basename` on the `-name` filter:\n\n```\n$ theDir=\"$HOME/.snapshot\"\n$ find \"$theDir\" -maxdepth 1 ! -name \"$(basename $theDir)\"\n/home/matt/.snapshot/rnapdev1-svm_4_05am_6every4hours.2019-04-02_0005\n/home/matt/.snapshot/rnapdev1-svm_4_05am_6every4hours.2019-04-02_0405\n/home/matt/.snapshot/rnapdev1-svm_4_05am_6every4hours.2019-04-02_0805\n/home/matt/.snapshot/rnapdev1-svm_4_05am_6every4hours.2019-04-01_1605\n/home/matt/.snapshot/rnapdev1-svm_4_05am_6every4hours.2019-04-01_2005\n/home/matt/.snapshot/rnapdev1-svm_4_05am_6every4hours.2019-04-02_1205\n/home/matt/.snapshot/snapmirror.1501b4aa-3f82-11e8-9c31-00a098cef13d_2147868328.2019-04-01_190000\n```\n\n#### All the other info\n\nIf trying to parse out any other fields, first see whether `stat` (GNU, OS X, FreeBSD) or `find -printf` (GNU) can give you the data you want directly. When trying to determine file size, try: `wc -c`. This is more portable as `wc` is a mandatory unix command, unlike `stat` and `find -printf`. It may be slower as unoptimized `wc -c` may read the entire file rather than just checking its properties. On some systems, `wc -c` adds whitespace to the file size which can be trimmed by double expansion: `$(( $(wc -c < \"filename\") )) `\n\n### Exceptions:\n\nIf the information is intended for the user and not for processing (`ls -l ~/dir | nl; echo \"Ok to delete these files?\"`) you can ignore this error with a [[directive]].\n\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2012)"},{"id":"shellcheck_SC2013","category":"BestPractice","level":"Info","severityLevel":"Info","enabled":false,"parameters":[],"title":"To read lines rather than words, pipe/redirect to a 'while read' loop.","description":"To read lines rather than words, pipe/redirect to a 'while read' loop.","explanation":"# To read lines rather than words, pipe/redirect to a 'while read' loop.\n\n### Problematic code:\n\n```sh\nfor line in $(cat file | grep -v '^ *#')\ndo\n  echo \"Line: $line\"\ndone\n```\n\n### Correct code:\n\n```sh\ngrep -v '^ *#' < file | while IFS= read -r line\ndo\n  echo \"Line: $line\"\ndone\n```\n\nor without a subshell (bash, zsh, ksh):\n\n```sh\nwhile IFS= read -r line\ndo\n  echo \"Line: $line\"\ndone < <(grep -v '^ *#' < file)\n```\n\nor without a subshell, with a pipe (more portable, but write a file on the filesystem):\n\n```sh\nmkfifo mypipe\ngrep -v '^ *#' < file > mypipe &\nwhile IFS= read -r line\ndo\n  echo \"Line: $line\"\ndone < mypipe\nrm mypipe\n```\n\n### Rationale:\n\nFor loops by default (subject to `$IFS`) read word by word. Additionally, glob expansion will occur.\n\nGiven this text file:\n\n```sh\nfoo *\nbar\n```\n\nThe for loop will print:\n\n```sh\nLine: foo\nLine: aardwark.jpg\nLine: bullfrog.jpg\n...\n```\n\nThe while loop will print:\n\n```sh\nLine: foo *\nLine: bar\n```\n\n\n### Exceptions\n\nIf you do want to read word by word, you can set `$IFS` appropriately and disable globbing with `set -f`, and then [[ignore]] this warning. Alternatively, you can pipe through `tr ' ' '\\n'` to turn words into lines, and then use `while read`. In Bash/Ksh, you can also use a `while read -a` loop to get an array of words per line.\n\n\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2013)"},{"id":"shellcheck_SC2014","category":"BestPractice","level":"Info","severityLevel":"Info","enabled":false,"parameters":[],"title":"This will expand once before find runs, not per file found.","description":"This will expand once before find runs, not per file found.","explanation":"## This will expand once before find runs, not per file found.\n\n### Problematic code:\n\n```sh\nfind . -name '*.tar' -exec tar xf {} -C \"$(dirname {})\" \\;\n```\n\n### Correct code:\n\n```sh\nfind . -name '*.tar' -exec sh -c 'tar xf \"$1\" -C \"$(dirname \"$1\")\"' _ {} \\;\n```\n\n### Rationale:\n\nBash evaluates any command substitutions before the command they feature in is executed. In this case, the command is `find`. This means that `$(dirname {})` will run **before** `find` runs, and not **while** `find` runs.\n\nTo run shell code for each file, we can write a tiny script and inline it with `sh -c`. We add `_` as a dummy argument that becomes `$0`, and a filename argument that becomes `$1` in the inlined script:\n\n```sh\n$ sh -c 'echo \"$1 is in $(dirname \"$1\")\"' _ \"mydir/myfile\"\nmydir/myfile is in mydir\n```\n\nThis command can be executed by `find -exec`, with `{}` as the filename argument. It executes shell which interprets the inlined script once for each file. Note that the inlined script is single quoted, again to ensure that the expansion does not happen prematurely .\n\n### Exceptions:\n\nIf you don't care (or if you prefer) that it's only expanded once, like when dynamically selecting the executable to be used by all invocations, you can ignore this message.\n\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2014)"},{"id":"shellcheck_SC2015","category":"ErrorProne","level":"Info","severityLevel":"Info","enabled":true,"parameters":[],"title":"Note that A && B || C is not if-then-else. C may run when A is true.","description":"Note that A && B || C is not if-then-else. C may run when A is true.","explanation":"# Note that A && B || C is not if-then-else. C may run when A is true.\n\n### Problematic code:\n\n```sh\n[[ $dryrun ]] && echo \"Would delete file\" || rm file\n```\n\n### Correct code:\n\n```sh\nif [[ $dryrun ]]\nthen\n  echo \"Would delete file\"\nelse\n  rm file\nfi\n```\n\n### Rationale:\n\nIt's common to use `A && B` to run `B` when `A` is true, and `A || C` to run `C` when `A` is false.\n\nHowever, combining them into `A && B || C` is not the same as `if A then B else C`.\n\nIn this case, if `A` is true but `B` is false, `C` will run.\n\nFor the code sample above, if the script was run with stdout closed for any reason (such as explicitly running `script --dryrun >&-`), echo would fail and the file would be deleted, even though `$dryrun` was set!\n\nIf an `if` clause is used instead, this problem is avoided.\n\n### Boring detail:\n\nWe can think of the example above as\n```sh\n((([[ $dryrun ]]) && echo \"Would delete file\") || rm file)\n```\nexpressing the left-associativity of the `&&` `||` operators.\n\nWhenever a command (strictly, a pipeline) succeeds or fails, the execution proceeds following the next `&&` (for success) or `||` (for failure). (More strictly, the parentheses should be replaced with `{ command; }` to avoid making a subshell, but that's ugly and boring.)\n\n### Exceptions\nIgnore this warning when you actually do intend to run C when either A or B fails.\n\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2015)"},{"id":"shellcheck_SC2016","category":"CodeStyle","level":"Info","severityLevel":"Info","enabled":true,"parameters":[],"title":"Expressions don't expand in single quotes, use double quotes for that.","description":"Expressions don't expand in single quotes, use double quotes for that.","explanation":"# Expressions don't expand in single quotes, use double quotes for that.\n\n### Problematic code:\n\n```sh\nname=World\necho 'Hello $name'   # Outputs Hello $name\n```\n\n### Correct code:\n\n```sh\nname=World\necho \"Hello $name\"   # Outputs Hello World\n```\n\n### Rationale:\n\nShellCheck found an expansion like `$var`, `$(cmd)`, or `` `cmd` `` in single quotes.\n\nSingle quotes express all such expansions. If you want the expression to expand, use double quotes instead. \n\nIf switching to double quotes would require excessive escaping of other metacharacters, note that you can mix and match quotes in the same shell word:\n\n```sh\ndialog --msgbox \"Filename $file may not contain any of: \"'`&;\"\\#%$' 10 70\n```\n\n### Exceptions\n\nIf you know that you want the expression literally without expansion, you can [[ignore]] this message:\n\n```\n# We want this to output $PATH without expansion\n# shellcheck disable=SC2016\necho 'PATH=$PATH:/usr/local/bin' >> ~/.bashrc\n```\n\nShellCheck also does not warn about escaped expansions in double quotes:\n\n```\necho \"PATH=\\$PATH:/usr/local/bin\" >> ~/.bashrc\n```\n\nThis suggestion is primarily meant to help newbies who assume single and double quotes are basically the same, like in Python and JavaScript. It's not at all meant to discourage experienced users from using single quotes in general. If you are well aware of the difference, please do not hesitate to permanently disable this suggestion with `disable=SC2016` in your `.shellcheckrc`. \n\nShellCheck tries to increase the signal-to-noise ratio of this warning by ignoring certain well known commands that frequently expect literal dollar signs, such as `sh` and `perl`. However, there's a long tail of less common commands and flags that also frequently expect `$`s, and it's not in ShellCheck's scope to try to keep track of them all. When you come across such a command, please [[ignore]] the suggestion, either permanently or for that one instance.\n\n### Related resources:\n\n* StackOverflow: [How do I use variables in single quoted strings?](https://stackoverflow.com/questions/21192420/how-do-i-use-variables-in-single-quoted-strings)\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2016)"},{"id":"shellcheck_SC2017","category":"BestPractice","level":"Info","severityLevel":"Info","enabled":false,"parameters":[],"title":"Increase precision by replacing a/b\\*c with a\\*c/b.","description":"Increase precision by replacing a/b\\*c with a\\*c/b.","explanation":"## Increase precision by replacing a/b\\*c with a\\*c/b.\n\n### Problematic code:\n\n```sh\npercent=$((count/total*100))\n```\n\n### Correct code:\n\n```sh\npercent=$((count*100/total))\n```\n\n### Rationale:\n\nIf integer division is performed before multiplication, the intermediate result will be truncated causing a loss of precision.\n\nIn this case, if  `count=1` and `total=2`, then the problematic code results in `percent=0`, while the correct code gives `percent=50`.\n\n### Exceptions:\n\nIf you want and expect truncation you can ignore this message.\n\nShellCheck doesn't warn when `b` and `c` are identical expressions, e.g. `a/10*10`, under the assumption that the intent is to rounded to the nearest 10 rather than the no-op of multiply by `1`.\n\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2017)"},{"id":"shellcheck_SC2018","category":"CodeStyle","level":"Info","severityLevel":"Info","enabled":false,"parameters":[],"title":"Use '[:lower:]' to support accents and foreign alphabets.","description":"Use '[:lower:]' to support accents and foreign alphabets.","explanation":"## Use '[:lower:]' to support accents and foreign alphabets.\n\n### Problematic code:\n\n```sh\nPLATFORM=\"$(uname -s | tr 'A-Z' 'a-z')\"\n```\n\n### Correct code:\n\n```sh\nPLATFORM=\"$(uname -s | tr '[:upper:]' '[:lower:]')\"\n```\n\n### Rationale:\n\n`A-Z` and `a-z` are commonly intended to mean \"all uppercase\" and \"all lowercase letters\" respectively. This ignores accented characters in English, and foreign characters in other languages:\n\n    $ tr 'a-z' 'A-Z' <<< \"My fiancée ordered a piña colada.\"\n    MY FIANCéE ORDERED A PIñA COLADA.\n\nInstead, you can use `[:lower:]` and `[:upper:]` to explicitly specify case:\n\n    $ tr '[:lower:]' '[:upper:]' <<< \"My fiancée ordered a piña colada.\"\n    MY FIANCÉE ORDERED A PIÑA COLADA.\n\n### Exceptions:\n\nIf you don't want `a-z` to match `é` or `A-Z` to match `Ñ`, you can ignore this message.\n\nAs of 2019-09-08, BusyBox `tr` does not support character classes, so you would have to ignore this message.\n\nNote that the examples used here are multibyte characters in UTF-8. Many implementations (including GNU) fails to deal with them. \n[Source](https://github.com/koalaman/shellcheck/wiki/SC2018)"},{"id":"shellcheck_SC2019","category":"CodeStyle","level":"Info","severityLevel":"Info","enabled":false,"parameters":[],"title":"Use '[:upper:]' to support accents and foreign alphabets.","description":"Use '[:upper:]' to support accents and foreign alphabets.","explanation":"## Use '[:upper:]' to support accents and foreign alphabets.\n\nSee the equivalent warning for lowercase matching: [[SC2018]]\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2019)"},{"id":"shellcheck_SC2020","category":"ErrorProne","level":"Info","severityLevel":"Info","enabled":true,"parameters":[],"title":"tr replaces sets of chars, not words (mentioned due to duplicates).","description":"tr replaces sets of chars, not words (mentioned due to duplicates).","explanation":"# tr replaces sets of chars, not words (mentioned due to duplicates).\n\n### Problematic code:\n\n```sh\necho 'hello world' | tr 'hello' 'goodbye'\n```\n\n### Correct code:\n\n```sh\necho 'hello world' | sed -e 's/hello/goodbye/g'\n```\n\n### Rationale:\n\n`tr` is for `tr`ansliteration, turning some characters into other characters. It doesn't match strings or words, only individual characters.\n\nIn this case, it transliterates h->g, e->o, l->d, o->y, resulting in the string \"goddb wbrdd\" instead of \"goodbye world\".\n\nThe solution is to use a tool that does string search and replace, such as sed.\n\n### Exceptions\n\nNone.\n\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2020)"},{"id":"shellcheck_SC2021","category":"CodeStyle","level":"Info","severityLevel":"Info","enabled":false,"parameters":[],"title":"Don't use [] around ranges in tr, it replaces literal square brackets.","description":"Don't use [] around ranges in tr, it replaces literal square brackets.","explanation":"## Don't use [] around ranges in tr, it replaces literal square brackets.\n\n### Problematic code:\n\n```sh\ntr -cd '[a-z]'\n```\n\n### Correct code:\n\n```sh\ntr -cd 'a-z'\n```\n### Rationale:\n\nAncient System V `tr` required brackets around operands, but modern implementations including POSIX, GNU, OS X and *BSD instead treat them as literals.\n\nUnless you want to operate on literal square brackets, don't include them.\n\n### Exceptions:\n\nIf you do want to replace literal square brackets, reorder the expression (e.g. `a-z[]` to make it clear that the brackets are not special).\n\nShellCheck does not warn about correct usage of `[..]` in character and equivalence classes like `[:lower:]` and `[=e=]`.\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2021)"},{"id":"shellcheck_SC2022","category":"ErrorProne","level":"Info","severityLevel":"Info","enabled":true,"parameters":[],"title":"Note that unlike globs, o* here matches 'ooo' but not 'oscar'","description":"Note that unlike globs, o* here matches 'ooo' but not 'oscar'","explanation":"# Note that unlike globs, o* here matches 'ooo' but not 'oscar'\n### Problematic code:\n\n```sh\ngrep 'foo*'\n```\n\nwhen wanting to match `food` and `foosball`, but not `mofo` or `keyfob`.\n\n### Correct code:\n\n```sh\ngrep '^foo'\n```\n\n### Rationale:\n\nAs a glob, `foo*` means \"Any string starting with foo\", e.g. `food` and `foosball`.\n\nAs a regular expression, \"foo*\" means \"f followed by 1 or more o's, anywhere\", e.g. \"mofo\" or \"keyfob\".\n\nThis construct is way more common as a glob than as a regex, so ShellCheck notifies you about it.\n\n### Exceptions\n\nIf you're aware of the above, you can ignore this message. If you'd like shellcheck to be quiet, use a [[directive]] or `'fo[o]*'`.\n\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2022)"},{"id":"shellcheck_SC2024","category":"ErrorProne","level":"Warning","severityLevel":"Warning","enabled":true,"parameters":[],"title":"`sudo` doesn't affect redirects. Use `..| sudo tee file`\r","description":"`sudo` doesn't affect redirects. Use `..| sudo tee file`\r","explanation":"## `sudo` doesn't affect redirects. Use `..| sudo tee file`\r\n\r\nor \"Use `..| sudo tee -a file`\" instead of `>>` to append.\r\n\r\nor \"Use `sudo cat file | ..`\" instead of `<` to read.\r\n\r\n### Problematic code:\r\n\r\n```\r\n# Write to a file\r\nsudo echo 3 > /proc/sys/vm/drop_caches\r\n\r\n# Append to a file\r\nsudo echo 'export FOO=bar' >> /etc/profile\r\n\r\n# Read from a file\r\nsudo wc -l < /etc/shadow\r\n```\r\n\r\n### Correct code:\r\n\r\n```\r\n# Write to a file\r\necho 3 | sudo tee /proc/sys/vm/drop_caches > /dev/null\r\n\r\n# Append to a file\r\necho 'export FOO=bar' | sudo tee -a /etc/profile > /dev/null\r\n\r\n# Read from a file\r\nsudo cat /etc/shadow | wc -l\r\n```\r\n\r\n### Rationale:\r\n\r\nRedirections are performed by the current shell before `sudo` is started. This means that it will use the current shell's user and permissions to open and read from or write to the file.\r\n\r\n* To *read* from a file that requires additional privileges, you can replace `sudo command < file` with `sudo cat file | command`. \r\n* To *write* to a file that requires additional privileges, you can replace `sudo command > file` with `command | sudo tee file > /dev/null`\r\n* To *append* to a file, use the above with `tee -a`. \r\n* If the file does *not* require special privileges but the command *does*, then you are already doing the right thing: please [[ignore]] the message. \r\n\r\nThe substitutions work by having a command open the file for reading or writing, instead of relying on the current shell. Since the command is run with elevated privileges, it will have access to files that the current user does not.\r\n\r\nNote: there is nothing special about `tee`. It's just the simplest command that can both truncate and append to files without help from the shell. Here are equivalent alternatives:\r\n\r\nTruncating:\r\n\r\n```\r\necho 'data' | sudo dd of=file\r\necho 'data' | sudo sed 'w file'\r\n```\r\n\r\nAppending: \r\n\r\n```\r\necho 'data' | sudo awk '{ print $0 >> \"file\" }'\r\necho 'data' | sudo sh -c 'cat >> file'\r\n```\r\n\r\n### Exceptions\r\n\r\nIf you want to run a command as root but redirect as the normal user, you can [[ignore]] this message.\r\n\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2024)"},{"id":"shellcheck_SC2025","category":"CodeStyle","level":"Info","severityLevel":"Info","enabled":true,"parameters":[],"title":"Make sure all escape sequences are enclosed in `\\[..\\]` to prevent line wrapping issues","description":"Make sure all escape sequences are enclosed in `\\[..\\]` to prevent line wrapping issues","explanation":"# Make sure all escape sequences are enclosed in `\\[..\\]` to prevent line wrapping issues\n\n### Problematic code:\n\n```sh\nPS1='\\e[36m\\$ \\e(B\\e[m'\n```\n\n### Correct code:\n\n```sh\nPS1='\\[\\e[36m\\]\\$ \\[\\e(B\\e[m\\]'\n```\n\n### Rationale:\n\nBash is unable to determine exactly which parts of your prompt are text and which are terminal codes. You have to help it by wrapping invisible control codes in `\\[..\\]` (and ensuring that visible characters are not wrapped in `\\[..\\]`).\n\nNote: ShellCheck offers this as a helpful hint and not a robust check. Don't rely on ShellCheck to verify that your prompt is correct.\n\n### Exceptions\n\nNone.\n\n### Related resources:\n\n* [BashFaq: I have a fancy prompt with colors, and now bash doesn't seem to know how wide my terminal is. Lines wrap around incorrectly.](https://mywiki.wooledge.org/BashFAQ/053)\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2025)"},{"id":"shellcheck_SC2026","category":"ErrorProne","level":"Info","severityLevel":"Info","enabled":true,"parameters":[],"title":"This word is outside of quotes. Did you intend to `'nest '\"'single quotes'\"'` instead'?","description":"This word is outside of quotes. Did you intend to `'nest '\"'single quotes'\"'` instead'?","explanation":"## This word is outside of quotes. Did you intend to `'nest '\"'single quotes'\"'` instead'?\n\n### Problematic code:\n\n```sh\nalias server_uptime='ssh $host 'uptime -p''\n```\n\n### Correct code:\n\n```sh\nalias server_uptime='ssh $host '\"'uptime -p'\"\n```\n\n### Rationale:\n\nIn the first case, the user has four single quotes on a line, wishfully hoping that the shell will match them up as outer quotes around a string with literal single quotes:\n\n```sh\n#                   v--------match--------v\nalias server_uptime='ssh $host 'uptime -p''\n#                              ^--match--^\n```\n\nThe shell, meanwhile, always terminates single quoted strings at the first possible single quote:\n\n```sh\n#                   v---match--v\nalias server_uptime='ssh $host 'uptime -p''\n#                                        ^^\n```\n\nWhich is the same thing as `alias server_uptime='ssh $host uptime' -p`.\n\nThere is no way to nest single quotes. However, single quotes can be placed literally in double quotes, so we can instead concatenate a single quoted string and a double quoted string:\n\n```sh\n#                   v--match---v\nalias server_uptime='ssh $host '\"'uptime -p'\"\n#                               ^---match---^\n```\n\nThis results in an alias with embedded single quotes.\n\n### Exceptions\n\nNone.\n\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2026)"},{"id":"shellcheck_SC2027","category":"ErrorProne","level":"Warning","severityLevel":"Warning","enabled":true,"parameters":[],"title":"The surrounding quotes actually unquote this. Remove or escape them.","description":"The surrounding quotes actually unquote this. Remove or escape them.","explanation":"## The surrounding quotes actually unquote this. Remove or escape them.\n\n### Problematic code:\n\n```sh\necho \"You enter \"$HOSTNAME\". You can smell the wumpus.\" >> /etc/issue\n```\n\n### Correct code:\n\n```sh\necho \"You enter $HOSTNAME. You can smell the wumpus.\" >> /etc/issue\n```\n\n### Rationale:\n\nAlways quoting variables and command expansions is good practice, but blindly putting quotes left and right of them is not.\n\nIn this case, ShellCheck has noticed that the quotes around the expansion are unquoting it, because the left quote is terminating an existing double quoted string, while the right quote starts a new one:\n\n```sh\necho \"You enter \"$HOSTNAME\". You can smell the wumpus.\"\n     |----------|         |---------------------------|\n        Quoted   No quotes           Quoted\n```\n\nIf the quotes were supposed to be literal, they should be escaped. If the quotes were supposed to quote an expansion (as in the example), they should be removed because this is already a double quoted string.\n\n### Exceptions\n\nNone.\n\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2027)"},{"id":"shellcheck_SC2028","category":"ErrorProne","level":"Info","severityLevel":"Info","enabled":true,"parameters":[],"title":"echo won't expand escape sequences. Consider printf.","description":"echo won't expand escape sequences. Consider printf.","explanation":"# echo won't expand escape sequences. Consider printf.\n\n### Problematic code:\n\n```sh\necho \"Name:\\t$value\"\n```\n\n### Correct code:\n\n```sh\nprintf 'Name:\\t%s\\n' \"$value\"\n```\n\n### Rationale:\n\nBackslash escapes like `\\t` and `\\n` are not expanded by echo, and become literal backslash-t, backslash-n.\n\n`printf` does expand these sequences, and should be used instead.\n\nOther, non-portable methods include `echo -e '\\t'` and `echo $'\\t'`. ShellCheck will warn if this is used in a script with shebang `#!/bin/sh`.\n\nIf you actually wanted a literal backslash-t, use\n\n```sh\necho \"\\\\t\"\n```\n\n### Exceptions\n\nNone\n\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2028)"},{"id":"shellcheck_SC2029","category":"ErrorProne","level":"Info","severityLevel":"Info","enabled":true,"parameters":[],"title":"Note that, unescaped, this expands on the client side.","description":"Note that, unescaped, this expands on the client side.","explanation":"## Note that, unescaped, this expands on the client side.\n\n### Problematic code:\n\n```sh\nssh host \"echo $HOSTNAME\"\n```\n\n### Correct code:\n\n```sh\nssh host \"echo \\$HOSTNAME\"\n```\n\nor\n\n```sh\nssh host 'echo $HOSTNAME'\n```\n\n### Rationale:\n\nBash expands all arguments that are not escaped/singlequoted. This means that the problematic code is identical to\n\n```sh\nssh host \"echo clienthostname\"\n```\n\nand will print out the client's hostname, not the server's hostname.\n\nBy escaping the `$` in `$HOSTNAME`, it will be transmitted literally and evaluated on the server instead.\n\n### Exceptions\n\nIf you do want your string expanded on the client side, you can safely ignore this message.\n\nKeep in mind that the expanded string will be evaluated again on the server side, so for arbitrary variables and command output, you may need to add a layer of escaping with e.g. `printf %q`.\n\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2029)"},{"id":"shellcheck_SC2030","category":"CodeStyle","level":"Info","severityLevel":"Info","enabled":false,"parameters":[],"title":"Modification of var is local (to subshell caused by pipeline).","description":"Modification of var is local (to subshell caused by pipeline).","explanation":"# Modification of var is local (to subshell caused by pipeline).\n\nSee companion warning [[SC2031]].\n\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2030)"},{"id":"shellcheck_SC2031","category":"ErrorProne","level":"Info","severityLevel":"Info","enabled":true,"parameters":[],"title":"var was modified in a subshell. That change might be lost.","description":"var was modified in a subshell. That change might be lost.","explanation":"# var was modified in a subshell. That change might be lost.\n\n### Problematic code:\n\nThere are many ways of accidentally creating subshells, but a common one is piping to a loop:\n\n```bash\nn=0\nprintf \"%s\\n\" {1..10} | while read i; do (( n+=i )); done\necho $n\n```\n\n### Correct code:\n\n```bash\n# Bash specific: process substitution. Also try shopts like lastpipe.\nn=0\nwhile read i; do (( n+=i )); done < <(printf \"%s\\n\" {1..10})\necho $n\n```\n\nIn `sh`, a temp file (better if fifo or fd) can be used instead of process substitution. And if it's acceptable to do it with waiting, try Here Documents.\n\n### Rationale:\n\nVariables set in subshells are not available outside the subshell. This is a wide topic, and better described on the [Wooledge Bash Wiki](http://mywiki.wooledge.org/BashFAQ/024).\n\nHere are some constructs that cause subshells (shellcheck may not warn about all of them). In each case, you can replace `subshell1` by a command or function that sets a variable, e.g. simply `var=foo`, and the variable will appear to be unset after the command is run. Similarly, you can replace `regular` with `var=foo`, and it will be set afterwards:\n\nPipelines:\n\n```sh\nsubshell1 | subshell2 | subshell3    # Bash, Dash, Ash\nsubshell1 | subshell2 | regular      # Ksh, Zsh\n```\n\nCommand substitution:\n\n```sh\nregular \"$(subshell1)\" \"`subshell2`\"\n```\n\nProcess substitution:\n\n```sh\nregular <(subshell1) >(subshell2)\n```\n\nSome forms of grouping:\n\n```sh\n( subshell )\n{ regular; }\n```\n\nBackgrounding:\n\n```sh\nsubshell1 &\nsubshell2 &\n```\n\nAnything executed by external processes:\n\n```sh\nfind . -exec subshell1 {} \\;\nfind . -print0 | xargs -0 subshell2\nsudo subshell3\nsu -c subshell4\n```\n\nThis applies not only to setting variables, but also setting shell options and changing directories.\n\n### Exceptions\n\nYou can ignore this error if you don't care that the changes aren't reflected, because work on the value branches and shouldn't be recombined.\n\n### Related resources:\n\n* [BashFaq: I set variables in a loop that's in a pipeline. Why do they disappear after the loop terminates?](https://mywiki.wooledge.org/BashFAQ/024)\n* [Bash Pitfalls: grep foo bar | while read -r; do ((count++)); done](https://mywiki.wooledge.org/BashPitfalls#pf8)\n* [StackOverflow: A variable modified inside a while loop is not remembered](https://stackoverflow.com/questions/16854280/a-variable-modified-inside-a-while-loop-is-not-remembered)\n\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2031)"},{"id":"shellcheck_SC2032","category":"CodeStyle","level":"Info","severityLevel":"Info","enabled":false,"parameters":[],"title":"Use own script or sh -c '..' to run this from su.","description":"Use own script or sh -c '..' to run this from su.","explanation":"# Use own script or sh -c '..' to run this from su.\n\n(or from xargs, sudo, chroot, or other commands)\n\nSee [[SC2033]].\n\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2032)"},{"id":"shellcheck_SC2033","category":"ErrorProne","level":"Warning","severityLevel":"Warning","enabled":true,"parameters":[],"title":"Shell functions can't be passed to external commands.","description":"Shell functions can't be passed to external commands.","explanation":"# Shell functions can't be passed to external commands.\n\n### Problematic code:\n\n```sh\nfoo() { bar --baz \"$@\"; frob --baz \"$@\"; };\nfind . -exec foo {} +\n```\n\n### Correct code:\n\n```sh\nfind . -exec sh -c 'bar --baz \"$@\"; frob --baz \"$@\";' -- {} +\n```\n\n### Rationale:\n\nShell functions are only known to the shell. External commands like `find`, `xargs`, `su` and `sudo` do not recognize shell functions.\n\nInstead, the function contents can be executed in a shell, either through `sh -c` or by creating a separate shell script as an executable file.\n\n### Exceptions\n\nIf you're intentionally passing a word that happens to have the same name as a declared function, you can quote it to make shellcheck ignore it, e.g.\n\n```sh\nnobody() {\n  sudo -u \"nobody\" \"$@\"\n}\n\n```\n\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2033)"},{"id":"shellcheck_SC2034","category":"ErrorProne","level":"Warning","severityLevel":"Warning","enabled":true,"parameters":[],"title":"foo appears unused. Verify it or export it.","description":"foo appears unused. Verify it or export it.","explanation":"# foo appears unused. Verify it or export it.\n\n## Problematic code:\n\n```sh\nfoo=42\necho \"$FOO\"\n```\n\n## Correct code:\n\n```sh\nfoo=42\necho \"$foo\"\n```\n\n## Rationale:\n\nVariables not used for anything are often associated with bugs, so ShellCheck warns about them.\n\nAlso note that something like `local let foo=42` does not make a `let` statement local -- it instead declares an additional local variable named `let`.\n\n## Exceptions\n\nThis warning may be falsely emitted when a variable is only referenced indirectly, and for variables that are intentionally unused.\n\n### Indirection\n\nIt's ShellCheck's intended behavior to emit this warning for any variable that is only referenced though indirection:\n\n```sh\n# foo generates a warning, even though it has five indirect references\nfoo=42\nname=foo\necho \"${!name} $((name))\"\nexport \"$name\"; eval \"echo $name\"\ndeclare -n name; echo \"$name\"\n```\n\nThis is an intentional design decision and not a bug. If you have variables that will not have direct references, consider using an associative array in bash, or just [[Ignore]] the warning. \n\nTracking indirect references is a common problem for compilers and static analysis tool, and it is known to be unsolvable in the most general case. There are two ways to handle unresolved indirections (which in a realistic program will essentially be all of them):\n\n* Avoid false positives by assuming all variables may potentially be used (disable all unused variable warnings)\n* Keep true positives by allowing some false positives (emit unused variable warnings that may be incorrect)\n\nCompilers are forced to do the former, but static analysis tools generally do the latter. This includes `pylint`, `jshint` and `shellcheck` itself. This is a design decision meant to make the tools more helpful at the expense of some noise. For consistency and to avoid giving the impression that it should work more generally, ShellCheck does not attempt to resolve even trivial indirections.\n\n#### Intentionally unused variables\n\nFor throwaway variables, consider using `_` as a dummy:\n\n```sh\nread _ last _ zip _ _ <<< \"$str\"\necho \"$last, $zip\"\n```\n\nOr optionally as a prefix for dummy variables (ShellCheck >0.7.2).\n\n```sh ​\nread _first last _email zip _lat _lng <<< \"$str\"\necho \"$last, $zip\"\n```\n\nFor versions <= 0.7.2, the message can optionally be [[ignore]]d with a directive:\n\n```sh\n# shellcheck disable=SC2034  # Unused variables left for readability\nread first last email zip lat lng <<< \"$str\"\necho \"$last, $zip\"\n```\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2034)"},{"id":"shellcheck_SC2035","category":"CodeStyle","level":"Info","severityLevel":"Info","enabled":true,"parameters":[],"title":"Use ./\\*glob* or -- \\*glob* so names with dashes won't become options.","description":"Use ./\\*glob* or -- \\*glob* so names with dashes won't become options.","explanation":"# Use ./\\*glob* or -- \\*glob* so names with dashes won't become options.\n\n### Problematic code:\n    rm *\n\n### Correct code:\n\n    rm ./*\n\nor\n\n    rm -- *\n\n### Rationale\n\nSince files and arguments are strings passed the same way, programs can't properly determine which is which, and rely on dashes to determine what's what.\n\nA file named `-f` (`touch -- -f`) will not be deleted by the problematic code. It will instead be interpreted as a command line option, and `rm` will even report success.\n\nUsing `./*` will instead cause the glob to be expanded into `./-f`, which no program will treat as an option.\n\nSimilarly, `--` by convention indicates the end of options, and nothing after it will be treated like flags (except for some programs possibly still special casing `-` as e.g. stdin).\n\nNote that changing `*` to `./*` in GNU Tar parameters will add `./` prefix to path names in the created archive. This may cause subtle problems (eg. to search for a specific file in archive, the `./` prefix must be specified as well). So using `-- *` is a safer fix for GNU Tar commands.\n\n`echo` and `printf` does not have issues unless the glob is the first word in the command. ShellCheck 0.7.2+ does not warn for these commands. \n\nFor more information, see \"[Filenames and Pathnames in Shell: How to do it Correctly](http://www.dwheeler.com/essays/filenames-in-shell.html)\".\n\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2035)"},{"id":"shellcheck_SC2036","category":"ErrorProne","level":"Warning","severityLevel":"Warning","enabled":true,"parameters":[],"title":"If you wanted to assign the output of the pipeline, use a=$(b | c) .","description":"If you wanted to assign the output of the pipeline, use a=$(b | c) .","explanation":"## If you wanted to assign the output of the pipeline, use a=$(b | c) .\n\n### Problematic code:\n\n```sh\nsum=find | wc -l\n```\n\n### Correct code:\n\n```sh\nsum=$(find | wc -l)\n```\n\n### Rationale:\n\nThe intention in this code was that `sum` would in some way get the value of the command `find | wc -l`.\n\nHowever, `|` has precedence over the `=`, so the command is a two stage pipeline consisting of `sum=find` and `wc -l`.\n\n`sum=find` is a plain string assignment. Since it happens by itself in an independent pipeline stage, it has no effect: it produces no output, and the variable disappears when the pipeline stage finishes. Because the assignment produces no output, `wc -l` will count 0 lines.\n\nTo instead actually assign a variable with the output of a command, command substitution `$(..)` can be used.\n\n### Exceptions:\n\nNone. This warning is triggered whenever the first stage of a pipeline is a single assignment, which is never correct.\n\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2036)"},{"id":"shellcheck_SC2037","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"To assign the output of a command, use var=$(cmd) .","description":"To assign the output of a command, use var=$(cmd) .","explanation":"##  To assign the output of a command, use var=$(cmd) .\n\n### Problematic code:\n\n```sh\nvar=grep -c pattern file\n```\n\n### Correct code:\n\n```sh\nvar=$(grep -c pattern file)\n```\n### Rationale:\n\nTo assign the output of a command to a variable, use `$(command substitution)`. Just typing a command after the `=` sign does not work.\n\n### Exceptions:\n\nNone. \n\nThis warning triggers generally for `var=value -flag` and `var=value *glob*`. See related warning [[SC2209]] which matches `var=commonCommand`. \n[Source](https://github.com/koalaman/shellcheck/wiki/SC2037)"},{"id":"shellcheck_SC2038","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"Use -print0/-0 or find -exec + to allow for non-alphanumeric filenames.","description":"Use -print0/-0 or find -exec + to allow for non-alphanumeric filenames.","explanation":"## Use -print0/-0 or find -exec + to allow for non-alphanumeric filenames.\n\n### Problematic code:\n\n```sh\nfind . -type f | xargs md5sum\n```\n\n### Correct code:\n\n```sh\nfind . -type f -print0 | xargs -0 md5sum\nfind . -type f -exec md5sum {} +\n```\n\n### Rationale:\n\nBy default, `xargs` interprets spaces and quotes in an unsafe and unexpected way. Whenever it's used, it should be used with `-0` or `--null` to split on `\\0` bytes, and `find` should be made to output `\\0` separated filenames.\n\nPOSIX does not require find or xargs to support null terminators, so you can also use `find -exec +`. \n### Exceptions\n\nNone.\n\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2038)"},{"id":"shellcheck_SC2041","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"This is a literal string. To run as a command, use $(..) instead of '..' .","description":"This is a literal string. To run as a command, use $(..) instead of '..' .","explanation":"## This is a literal string. To run as a command, use $(..) instead of '..' .\n\n### Problematic code:\n\n```sh\nfor i in 'seq 1 10'\ndo\n  echo \"$i\"\ndone\n```\n\n### Correct code:\n\n```sh\nfor i in $(seq 1 10)\ndo\n  echo \"$i\"\ndone\n```\n\n### Rationale:\n\nThe intent was to run the code in the single quotes. This would have worked with slanted backticks, `` `..` ``, but here the very similar looking single quotes `'..'` were used, resulting in a string literal instead of command output.\n\nThis is one of the many problems with backticks, so it's better to use `$(..)` to expand commands.\n\n### Exceptions:\n\nNone.\n\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2041)"},{"id":"shellcheck_SC2043","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"This loop will only ever run once for a constant value. Did you perhaps mean to loop over dir/*, $var or $(cmd)?\"","description":"This loop will only ever run once for a constant value. Did you perhaps mean to loop over dir/*, $var or $(cmd)?\"","explanation":"## This loop will only ever run once for a constant value. Did you perhaps mean to loop over dir/*, $var or $(cmd)?\"\n\n### Problematic code:\n\n```sh\nfor var in value\ndo\n  echo \"$var\"\ndone\n```\n\n### Correct code:\n\nCorrect code depends on what you want to do.\n\nTo iterate over files in a directory, instead of `for var in /my/dir` use:\n\n```sh\nfor var in /my/dir/* ; do echo \"$var\"; done\n```\n\nTo iterate over lines in a file or command output, use a while read loop instead:\n\n```sh\nmycommand | while IFS= read -r line; do echo \"$line\"; done\n```\n\nTo iterate over *words* written to a command or function's stdout, instead of `for var in myfunction`, use\n\n```sh\nfor var in $(myfunction); do echo \"$var\"; done\n```\n\nTo iterate over *words* in a variable, instead of  `for var in myvariable`, use\n\n```sh\nfor var in $myvariable; do echo \"$var\"; done\n```\n\n\n\n### Rationale:\n\nShellCheck has detected that your for loop iterates over a single, constant value. This is most likely a bug in your code, caused by you not expanding the value in the way you want.\n\nYou should make sure that whatever you loop over will expand into multiple words.\n\n### Exceptions\n\nNone.\n\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2043)"},{"id":"shellcheck_SC2044","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"For loops over find output are fragile. Use find -exec or a while read loop.","description":"For loops over find output are fragile. Use find -exec or a while read loop.","explanation":"## For loops over find output are fragile. Use find -exec or a while read loop.\n\n### Problematic code:\n\n```sh\nfor file in $(find mydir -mtime -7 -name '*.mp3')\ndo\n  let count++\n  echo \"Playing file no. $count\"\n  play \"$file\"\ndone\necho \"Played $count files\"\n```\n\nThis will fail for filenames containing spaces and similar, such as `My File.mp3`, and has a series of potential globbing issues depending on other filenames in the directory like (if you have `MyFile2.mp3` and `MyFile[2014].mp3`, the former file will play twice and the latter will not play at all).\n\n### Correct code:\n\nThere are many possible fixes, each with its pros and cons.\n\nThe most general fix (that requires the least amount of thinking to apply) is having `find` output a `\\0` separated list of files and consuming them in a `while read` loop:\n\n```sh\nwhile IFS= read -r -d '' file\ndo\n  let count++\n  echo \"Playing file no. $count\"\n  play \"$file\"\ndone <   <(find mydir -mtime -7 -name '*.mp3' -print0)\necho \"Played $count files\"\n```\n\nIn usage it's very similar to the `for` loop: it gets its output from a `find` statement, it executes a shell script body, it allows updating/aggregating variables, and the variables are available when the loop ends.\n\nIt requires Bash, and works with GNU, Busybox, OS X, FreeBSD and OpenBSD find, but not POSIX find.\n\n##### If `find` is just matching globs recursively\n\nIf you don't need `find` logic like `-mtime -7` and just use it to match globs recursively (all `*.mp3` files under a directory), you can instead use `globstar` and `nullglob` instead of `find`, and still use a `for` loop:\n\n```sh\nshopt -s globstar nullglob\nfor file in mydir/**/*.mp3\ndo\n  let count++\n  echo \"Playing file no. $count\"\n  play \"$file\"\ndone\necho \"Played $count files\"\n```\n\nThis is bash 4 specific.\n\n\n##### For POSIX\n\nIf you need POSIX compliance, this is a fair approach:\n\n```sh\nfind mydir ! -name \"$(printf \"*\\n*\")\" -name '*.mp3' > tmp\nwhile IFS= read -r file\ndo\n  let count++\n  echo \"Playing file #$count\"\n  play \"$file\"\ndone < tmp\nrm tmp\necho \"Played $count files\"\n```\n\nThe only problem is for filenames containing line feeds. A `! -name \"$(printf \"*\\n*\")\"` has been added to simply skip these files, just in case there are any.\n\nIf you don't need variables to be available after the loop (here, if you don't need to print the final play count at the end), you can skip the `tmp` file and just pipe from `find` to `while`.\n\n##### For simple commands with no aggregation\n\nIf you don't need a shell script loop body or any form of variable  like if we only wanted to play the file, we can dramatically simplify while maintaining POSIX compatibility:\n\n```sh\n# Simple and POSIX\nfind mydir -name '*.mp3' -exec play {} \\;\n```\n\nThis does not allow things like `let counter++` because `let` is a shell builtin, not an external command.\n\n##### For shell commands with no aggregation\n\nIf we do need a shell script body but no aggregation, you can do the above but invoking `sh` (this is still POSIX):\n\n```sh\nfind mydir -name '*.mp3' -exec sh -c '\n    echo \"Playing ${1%.mp3}\"\n    play \"$1\"\n  ' sh {} \\;\n```\n\nThis would not be possible without `sh`, because `${1%.mp3}` is a shell construct that `find` can't evaluate by itself. If we had tried to `let counter++` in this loop, we would have found that the value never changes.\n\nNote that using `+` instead of `\\;`, and using an embedded `for file in \"$@\"` loop rather than `\"$1\"`, will not allow aggregating variables. This is because for large lists, `find` will invoke the command multiple times, each time with some chunk of the input.\n\n\n### Rationale:\n\n`for var in $(find ...)`  loops rely on word splitting and will evaluate globs, which will wreck havoc with filenames containing whitespace or glob characters.\n\n`find -exec` `for i in glob` and `find`+`while` do not rely on word splitting, so they avoid this problem.\n\n### Exceptions\n\nIf you know about and carefully apply `IFS=$'\\n'` and `set -f`, you could choose to ignore this message.\n\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2044)"},{"id":"shellcheck_SC2045","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"Iterating over ls output is fragile. Use globs.","description":"Iterating over ls output is fragile. Use globs.","explanation":"## Iterating over ls output is fragile. Use globs.\n\n### Problematic code:\n\n```sh\nfor f in $(ls *.wav)\ndo\n  echo \"$f\"\ndone\n```\n\n### Correct code:\n\n```sh\nfor f in *.wav\ndo\n  [[ -e \"$f\" ]] || break  # handle the case of no *.wav files\n  echo \"$f\"\ndone\n```\n\nAlso note that in Bash, `shopt -s nullglob` will allow the loop to run 0 times instead of 1 if there are no matches. There are also [several other conditions](http://mywiki.wooledge.org/BashPitfalls#for_i_in_.24.28ls_.2A.mp3.29) to be aware of.\n\n### Rationale:\n\nWhen looping over a set of files, it's always better to use globs when possible. Using command expansion causes word splitting and glob expansion, which will cause problems for certain filenames (typically first seen when trying to process a file with spaces in the name).\n\nThe following files can or will break the first loop:\n\n```sh\ntouch 'filename with spaces.wav'\ntouch 'filename with * globs.wav'\ntouch 'More_Globs[2003].wav'\ntouch 'files_with_fønny_chæracters_in_certain_locales.wav'\n```\n\n### Related resources:\n\n* [Bash Pitfalls: for i in $(ls *.mp3)](http://mywiki.wooledge.org/BashPitfalls#pf1)\n+ [How to loop over directories in Linux?](https://stackoverflow.com/questions/2107945/how-to-loop-over-directories-in-linux)\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2045)"},{"id":"shellcheck_SC2046","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"Quote this to prevent word splitting.","description":"Quote this to prevent word splitting.","explanation":"# Quote this to prevent word splitting.\n\n### Problematic code:\n\n```sh\nls -l $(getfilename)\n```\n\n### Correct code:\n\n```sh\n# getfilename outputs 1 file\nls -l \"$(getfilename)\"\n\n# getfilename outputs multiple files, linefeed separated\ngetfilename | while IFS='' read -r line\ndo\n    ls -l \"$line\"\ndone\n```\n\n### Rationale:\n\nWhen command expansions are unquoted, word splitting and globbing will occur. This often manifests itself by breaking when filenames contain spaces.\n\nTrying to fix it by adding quotes or escapes to the data will not work. Instead, quote the command substitution itself.\n\nIf the command substitution outputs multiple pieces of data, use a loop instead.\n\n### Exceptions\n\nIn rare cases you actually want word splitting, such as in\n\n```sh\n# shellcheck disable=SC2046\ngcc $(pkg-config --libs openssl) client.c\n```\n\nThis is because `pkg-config` outputs `-lssl -lcrypto`, which you want to break up by spaces into `-lssl` and `-lcrypto`.\n\nA bash alternative in these cases is to use `read -a` for words or `mapfile` for lines. ksh can also use `read -a`, or a `while read` loop for lines. In this case, since `pkg-config` outputs words, you could use:\n\n```sh\n# Read words into an array in bash and ksh\nread -ra args < <(pkg-config --libs openssl)\n\n# expand args\ngcc \"${args[@]}\" client.c\n```\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2046)"},{"id":"shellcheck_SC2048","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"Use \"$@\" (with quotes) to prevent whitespace problems.","description":"Use \"$@\" (with quotes) to prevent whitespace problems.","explanation":"## Use \"$@\" (with quotes) to prevent whitespace problems.\n\nOr: Use \"${array[@]}\" (with quotes) to prevent whitespace problems.\n\n### Problematic code:\n\n```sh\ncp $* ~/dir\ncp ${array[*]} ~/dir\n```\n\n### Correct code:\n\n```sh\ncp \"$@\" ~/dir\ncp \"${array[@]}\" ~/dir\n```\n\n### Rationale:\n\n`$*` and `${array[*]}`, unquoted, is subject to word splitting and globbing.\n\nLet's say you have three arguments or array elements: `baz`, `foo bar` and `*`\n\n`\"$@\"` and `\"${array[@]}\" `will expand into exactly that: `baz`, `foo bar` and `*`\n\n`$*` and `${array[*]}` will expand into multiple other arguments: `baz`, `foo`, `bar`, `file.txt` and `otherfile.jpg`\n\nSince the latter is rarely expected or desired, ShellCheck warns about it.\n\n### Exceptions\n\nNone.\n\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2048)"},{"id":"shellcheck_SC2049","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"=~ is for regex, but this looks like a glob. Use = instead.","description":"=~ is for regex, but this looks like a glob. Use = instead.","explanation":"## =~ is for regex, but this looks like a glob. Use = instead.\n\n### Problematic code:\n\n```sh\n[[ $file =~ *.txt ]]\n```\n\n### Correct code:\n\n```sh\n[[ $file = *.txt ]]\n```\n\n### Rationale:\n\nYou are using `=~` to match against a regex -- specifically a Extended Regular Expression (ERE) -- but the right-hand side looks more like a glob:\n\n* It may have a leading `*`, like in `*.txt`\n    * In a glob, this matches strings ending in `.txt`, like `readme.txt` but not `foo.sh`\n    * In an ERE, this matches a literal asterisk, followed by any character, and then `txt`, such as `*itxt` but not `test.txt`\n\n* It may be a single letter followed by a `*`, like in `s*`. \n    * In a glob, this matches strings starting with `s`, such as `shell` and `set`.\n    * In an ERE, this matches zero or more `s`s, such as `dog` (because it does in fact contain zero or more `s`'s)\n\nPlease ensure that the pattern is correct as an ERE, or switch to glob matching if that's what you intended.\n\nThis is similar to [[SC2063]], where `grep \"*foo*\"` produces an equivalent warning.\n\n### Exceptions:\n\nIf you are aware of the difference, you can [[ignore]] this message, but this warning is not emitted for the more probable EREs `\\*.txt`, `\\.txt$`, `^s` or `s+`, so it should rarely be necessary.\n\n### Related resources:\n\n* Help by adding links to BashFAQ, StackOverflow, man pages, POSIX, etc!\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2049)"},{"id":"shellcheck_SC2050","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"This expression is constant. Did you forget the `$` on a variable?","description":"This expression is constant. Did you forget the `$` on a variable?","explanation":"## This expression is constant. Did you forget the `$` on a variable?\n### Problematic code:\n\n```sh\nif [ myvar = \"test\" ]\nthen\n  echo \"Test mode\"\nfi\n```\n\n### Correct code:\n\n```sh\nif [ \"$myvar\" = \"test\" ]\nthen\n  echo \"Test mode\"\nfi\n```\n### Rationale:\n\nShellCheck has found a `[ .. ]` or `[[ .. ]]` comparison that only involves literal strings. The intention was probably to check a variable or command output instead.\n\nThis is usually due to missing `$` or bad quoting:\n\n    if [[ \"myvar\" = \"test\" ]]             # always false because myvar is a literal string\n    if [[ \"$myvar\" = \"test\" ]]            # correctly compares a variable\n\n    if [ 'grep -c foo bar' -ge 10 ]       # always false because grep doesn't run\n    if [ \"$(grep -c foo bar)\" -ge 10 ]    # correctly checks grep output\n\n### Exceptions:\n\nNone\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2050)"},{"id":"shellcheck_SC2051","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"Bash doesn't support variables in brace range expansions.\r","description":"Bash doesn't support variables in brace range expansions.\r","explanation":"## Bash doesn't support variables in brace range expansions.\r\n\r\n### Problematic code:\r\n\r\n```bash\r\nfor i in {1..$n}\r\ndo\r\n  echo \"$i\"\r\ndone\r\n```\r\n\r\n### Correct code:\r\n\r\n```bash\r\nfor ((i=0; i<n; i++))\r\ndo\r\n  echo \"$i\"\r\ndone\r\n```\r\n\r\n### Rationale:\r\n\r\nIn Bash, brace expansion happens before variable expansion. This means that brace expansion will not account for variables.\r\n\r\nFor integers, use an arithmetic for loop instead. For zero-padded numbers or letters, use of eval may be warranted:\r\n\r\n```bash\r\nfrom=\"a\" to=\"m\"\r\nfor c in $(eval \"echo {$from..$to}\"); do echo \"$c\"; done\r\n```\r\n\r\nor more carefully (if `from`/`to` could be user input, or if the brace expansion could have spaces):\r\n\r\n```bash\r\nfrom=\"a\" to=\"m\"\r\nwhile IFS= read -d '' -r c\r\ndo\r\n  echo \"Read $c\"\r\ndone <  <(eval \"printf '%s\\0' $(printf \"{%q..%q}.jpg\" \"$from\" \"$to\")\")\r\n```\r\n\r\n### Exceptions\r\n\r\nNone (if you're writing for e.g. zsh, you can use a directive to disable this check)\r\n\r\n### Related Resources:\r\n\r\n* [StackOverflow: Variables in bash seq replacement ({1..10})](https://stackoverflow.com/questions/169511/how-do-i-iterate-over-a-range-of-numbers-defined-by-variables-in-bash)\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2051)"},{"id":"shellcheck_SC2053","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"Quote the rhs of = in [[ ]] to prevent glob matching.","description":"Quote the rhs of = in [[ ]] to prevent glob matching.","explanation":"## Quote the rhs of = in [[ ]] to prevent glob matching.\n\n### Problematic code:\n\n```sh\n[[ $a = $b ]]\n```\n\n### Correct code:\n\n```sh\n[[ $a = \"$b\" ]]\n```\n### Rationale:\n\nWhen the right-hand side of `=`, `==` or `!=` is unquoted in `[[ .. ]]`, it will be treated like a glob.\n\nThis has some unexpected consequences like `[[ $var = $var ]]` being false (for `var='[a]'`), or `[[ $foo = $bar ]]` giving a different result from `[[ $bar = $foo ]]`.\n\nThe most common intention is to compare one variable to another as strings, in which case the right-hand side must be quoted.\n\n### Exceptions:\n\nIf you explicitly want to match against a pattern, you can [[ignore]] this warning.\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2053)"},{"id":"shellcheck_SC2054","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"Use spaces, not commas, to separate array elements.","description":"Use spaces, not commas, to separate array elements.","explanation":"## Use spaces, not commas, to separate array elements.\n\n### Problematic code:\n\n```sh\nflags=(\"-l\", \"-d\", \"--sort=size\")\nls \"${flags[@]}\"\n```\n\n### Correct code:\n\n```sh\nflags=(\"-l\" \"-d\" \"--sort=size\")\nls \"${flags[@]}\"\n```\n### Rationale:\n\nYou appear to have used commas to separate array elements in an array assignment. Other languages require this, but bash instead treats the commas as literal strings.\n\nIn the problematic code, the first element is `-l,` with the trailing comma, and the executed command ends up being `ls -l, -d, --sort=size`.\n\nIn the correct code, the trailing commas have been removed, and the command will be `ls -l -d --sort=size` as expected.\n\n### Exceptions:\n\nNone (if you actually want a trailing comma in your strings, move them inside the quotes).\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2054)"},{"id":"shellcheck_SC2055","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"You probably wanted && here, otherwise it's always true.","description":"You probably wanted && here, otherwise it's always true.","explanation":"## You probably wanted && here, otherwise it's always true.\n\n### Problematic code:\n\n```sh\nif [[ $1 != foo || $1 != bar ]]\nthen\n  echo \"$1 is not foo or bar\"\nfi\n```\n\n### Correct code:\n\n```sh\nif [[ $1 != foo && $1 != bar ]]\nthen\n  echo \"$1 is not foo or bar\"\nfi\n```\n\n### Rationale:\n\nThis is not a bash issue, but a simple, common logical mistake applicable to all languages.\n\n`[[ $1 != foo || $1 != bar ]]` is always true (when `foo != bar`):\n\n* If `$1 = foo` then `$1 != bar` is true, so the statement is true.\n* If `$1 = bar` then `$1 != foo` is true, so the statement is true.\n* If `$1 = cow` then `$1 != foo` is true, so the statement is true.\n\n`[[ $1 != foo && $1 != bar ]]` matches when `$1` is neither `foo` nor `bar`:\n\n* If `$1 = foo`, then `$1 != foo` is false, so the statement is false.\n* If `$1 = bar`, then `$1 != bar` is false, so the statement is false.\n* If `$1 = cow`, then both `$1 != foo` and `$1  != bar` is true, so the statement is true.\n\nThis statement is identical to `! [[ $1 = foo || $1 = bar ]]`, which also works correctly.\n\n### Exceptions\n\nRare.\n\n* If I want to check that $FOO, $BAR and $COW are all equal:\n```sh\nif [[ $FOO != $BAR || $FOO != $COW ]]\nthen\n    echo \"$FOO and $BAR and $COW are not all equal\"\nfi\n```\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2055)"},{"id":"shellcheck_SC2056","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"You probably wanted && here","description":"You probably wanted && here","explanation":"## You probably wanted && here\n\n### Problematic code:\n\n```sh\nif  (( $1 != 0 || $1 != 3 ))\nthen\n  echo \"$1 is not 0 or 3\"\nfi\n```\n\n### Correct code:\n\n```sh\nif  (( $1 != 0 && $1 != 3 ))\nthen\n  echo \"$1 is not 0 or 3\"\nfi\n```\n\n### Rationale:\n\nThis is not a bash issue, but a simple, common logical mistake applicable to all languages.\n\n`(( $1 != 0 || $1 != 3 ))` is always true:\n\n* If `$1 = 0` then `$1 != 3` is true, so the statement is true.\n* If `$1 = 3` then `$1 != 0` is true, so the statement is true.\n* If `$1 = 42` then `$1 != 0` is true, so the statement is true.\n\n`(( $1 != 0 && $1 != 3 ))` is true only when `$1` is not `0` and not `3`:\n\n* If `$1 = 0`, then `$1 != 3` is false, so the statement is false.\n* If `$1 = 3`, then `$1 != 0` is false, so the statement is false.\n* If `$1 = 42`, then both `$1 != 0` and `$1  != 3` is true, so the statement is true.\n\nThis statement is identical to `! (( $1 == 0 || $1 == 3 ))`, which also works correctly.\n\n### Exceptions\n\nNone.\n\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2056)"},{"id":"shellcheck_SC2057","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"Unknown binary operator.","description":"Unknown binary operator.","explanation":"## Unknown binary operator.\n\n### Problematic code:\n\n```sh\n[ \"$var\" -leq 42 ]\n```\n\n### Correct code:\n\n```sh\n[ \"$var\" -le 42 ]\n```\n\n### Rationale:\n\nYou are using an unknown binary operator in a `test` expression. Choose one that exists.\n\nIn bash, use `help test` to see a list of supported operators:\n\n      FILE1 -nt FILE2  True if file1 is newer than file2 (according to\n                       modification date).\n\n      FILE1 -ot FILE2  True if file1 is older than file2.\n\n      FILE1 -ef FILE2  True if file1 is a hard link to file2.\n\n      STRING1 = STRING2\n                     True if the strings are equal.\n      STRING1 != STRING2\n                     True if the strings are not equal.\n      STRING1 < STRING2\n                     True if STRING1 sorts before STRING2 lexicographically.\n      STRING1 > STRING2\n                     True if STRING1 sorts after STRING2 lexicographically.\n\n      arg1 OP arg2   Arithmetic tests.  OP is one of -eq, -ne,\n                     -lt, -le, -gt, or -ge.\n\n    Arithmetic binary operators return true if ARG1 is equal, not-equal,\n    less-than, less-than-or-equal, greater-than, or greater-than-or-equal\n    than ARG2.\n\n\n### Exceptions:\n\nNone. If you've tested and verified that the operator works but the latest version of ShellCheck says it's unknown, please [submit a bug report](https://github.com/koalaman/shellcheck/issues).\n\n### Related resources:\n\n* [The classic test command](http://wiki.bash-hackers.org/commands/classictest) on the Bash Hackers wiki.\n* [The conditional expression](http://wiki.bash-hackers.org/syntax/ccmd/conditional_expression) on the Bash Hackers wiki.\n* [Tests and conditionals](https://mywiki.wooledge.org/BashGuide/TestsAndConditionals) on the Wooledge BashGuide.\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2057)"},{"id":"shellcheck_SC2058","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"Unknown unary operator.","description":"Unknown unary operator.","explanation":"## Unknown unary operator.\n\n### Problematic code:\n\n```sh\n[ -E 42 ]\n```\n\n### Correct code:\n\n```sh\n[ -e 42 ]\n```\n\n### Rationale:\n\nYou are using an unknown unary operator in a `test` expression. Perhaps it's a typo?\n\nIn bash, you can use `help test` to see a list of supported operators:\n\n      -a FILE        True if file exists.\n      -b FILE        True if file is block special.\n      -c FILE        True if file is character special.\n      -d FILE        True if file is a directory.\n      -e FILE        True if file exists.\n      -f FILE        True if file exists and is a regular file.\n      -g FILE        True if file is set-group-id.\n      -h FILE        True if file is a symbolic link.\n      -L FILE        True if file is a symbolic link.\n      -k FILE        True if file has its `sticky' bit set.\n      -p FILE        True if file is a named pipe.\n      -r FILE        True if file is readable by you.\n      -s FILE        True if file exists and is not empty.\n      -S FILE        True if file is a socket.\n      -t FD          True if FD is opened on a terminal.\n      -u FILE        True if the file is set-user-id.\n      -w FILE        True if the file is writable by you.\n      -x FILE        True if the file is executable by you.\n      -O FILE        True if the file is effectively owned by you.\n      -G FILE        True if the file is effectively owned by your group.\n      -N FILE        True if the file has been modified since it was last read.\n\n### Exceptions:\n\nNone. If you've tested and verified that the operator works but the latest version of ShellCheck says it's unknown, please [submit a bug report](https://github.com/koalaman/shellcheck/issues).\n\n### Related resources:\n\n* [The classic test command](http://wiki.bash-hackers.org/commands/classictest) on the Bash Hackers wiki.\n* [The conditional expression](http://wiki.bash-hackers.org/syntax/ccmd/conditional_expression) on the Bash Hackers wiki.\n* [Tests and conditionals](https://mywiki.wooledge.org/BashGuide/TestsAndConditionals) on the Wooledge BashGuide.\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2058)"},{"id":"shellcheck_SC2059","category":"CodeStyle","level":"Info","severityLevel":"Info","enabled":false,"parameters":[],"title":"Don't use variables in the printf format string. Use printf \"..%s..\" \"$foo\".","description":"Don't use variables in the printf format string. Use printf \"..%s..\" \"$foo\".","explanation":"# Don't use variables in the printf format string. Use printf \"..%s..\" \"$foo\".\n\n### Problematic code:\n\n```sh\nprintf \"Hello, $NAME\\n\"\n```\n\n### Correct code:\n\n```sh\nprintf \"Hello, %s\\n\" \"$NAME\"\n```\n\n### Rationale:\n\n`printf` interprets escape sequences and format specifiers in the format string. If variables are included, any escape sequences or format specifiers in the data will be interpreted too, when you most likely wanted to treat it as data. Example:\n\n```sh\ncoverage='96%'\nprintf \"Unit test coverage: %s\\n\" \"$coverage\"\nprintf \"Unit test coverage: $coverage\\n\"\n```\n\nThe first printf writes `Unit test coverage: 96%`.\n\nThe second writes ``bash: printf: `\\': invalid format character``\n\n### Exceptions\n\nSometimes you may actually want to interpret data as a format string, like in:\n\n```sh\noctToAscii() { printf \"\\\\$1\"; }\noctToAscii 130\n```\n\nIn Bash, Ksh and BusyBox, there's a `%b` format specifier that expands escape sequences without interpreting other format specifiers: `printf '%b' \"\\\\$1\"`. In POSIX, you can instead [[ignore]] this warning.\n\nOther times, you might have a pattern in a variable:\n\n```sh\nfilepattern=\"file-%d.jpg\"\nprintf -v filename \"$filepattern\" \"$number\"\n```\n\nThis has no good rewrite. Please [[ignore]] the warning with a [[directive]].\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2059)"},{"id":"shellcheck_SC2060","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"Quote parameters to tr to prevent glob expansion.","description":"Quote parameters to tr to prevent glob expansion.","explanation":"# Quote parameters to tr to prevent glob expansion.\n\n### Problematic code:\n\n```sh\ntr -cd [:digit:]\n```\n\n### Correct code:\n\n```sh\ntr -cd '[:digit:]'\n```\n\n### Rationale:\n\nFrom the shell's point of view, unquoted `[:digit:]` is a glob equivalent to `[dgit:]` that matches any single character filename from the group, such as `d` or `t`, in the current directory. \n\nIf someone starts learning D and creates a directory named `d` to hold the source code, the glob will be expanded and the script will end up executing `tr -cd d` instead, which is clearly unintended.\n\nQuoting the argument prevents this, and will pass it correctly as the literal string `[:digit:]` no matter which files exist in the current directory.\n\n### Exceptions\n\nNone\n\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2060)"},{"id":"shellcheck_SC2061","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"Quote the parameter to -name so the shell won't interpret it.","description":"Quote the parameter to -name so the shell won't interpret it.","explanation":"## Quote the parameter to -name so the shell won't interpret it.\n\n### Problematic code:\n\n```sh\nfind . -name *.txt\n```\n\n### Correct code:\n\n```sh\nfind . -name '*.txt'\n```\n### Rationale:\n\nSeveral find options take patterns to match against, including `-ilname`, `-iname`, `-ipath`, `-iregex`, `-iwholename`, `-lname`, `-name`, `-path`, `-regex` and `-wholename`.\n\nThese compete with the shell's pattern expansion, and must therefore be quoted so that they are passed literally to `find`.\n\nThe example command may end up executing as `find . -name README.txt` after the shell has replaced the `*.txt` with a matching file `README.txt` from the current directory. \n\nThis may happen today or suddenly in the future.\n\n### Exceptions:\n\nNone.\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2061)"},{"id":"shellcheck_SC2062","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"Quote the grep pattern so the shell won't interpret it.","description":"Quote the grep pattern so the shell won't interpret it.","explanation":"# Quote the grep pattern so the shell won't interpret it.\n\n### Problematic code\n    grep foo* file\n\n### Correct code\n    grep \"foo*\" file\n\n### Rationale\nThe regex passed to grep frequently contains characters that collide with globs. The code above is supposed to match \"f followed by 1 or more o's\", but if the directory contains a file called \"foo.txt\", an unquoted pattern will cause it to become `grep foo.txt file`.\n\nTo prevent this, always quote the regex passed to grep, especially when it contains one or more glob character.\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2062)"},{"id":"shellcheck_SC2063","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"Grep uses regex, but this looks like a glob.","description":"Grep uses regex, but this looks like a glob.","explanation":"# Grep uses regex, but this looks like a glob.\n\n### Problematic code:\n\n```sh\ngrep '*foo*'\n```\n\n### Correct code:\n\n```sh\ngrep 'foo'   # or more explicitly,  grep '.*foo.*'\n```\n\n### Rationale:\n\nIn globs, `*` matches any number of any character.\n\nIn regex, `*` matches any number of the preceding character.\n\n`grep` uses regex, not globs, so this means that `grep '*foo'` is nonsensical because there's no preceding character for `*`.\n\nIf the intention was to match \"any number of characters followed by foo\", use `'.*foo'`. Also note that since grep matches substrings, this will match \"fishfood\". Use anchors to prevent this, e.g. `foo$`.\n\nThis also means that `f*` will match \"hello\", because `f*` matches 0 (or more) \"f\"s and there are indeed 0 \"f\" characters in \"hello\". Again, use `grep 'f'` to find strings containing \"f\", or `grep '^f'` to find strings starting with \"f\".\n\n\n### Exceptions\n\nIf you're aware of the differences between globs and regex, you can ignore this message.\n\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2063)"},{"id":"shellcheck_SC2064","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"Use single quotes, otherwise this expands now rather than when signalled.","description":"Use single quotes, otherwise this expands now rather than when signalled.","explanation":"## Use single quotes, otherwise this expands now rather than when signalled.\n\n### Problematic code:\n\n```sh\ntrap \"echo \\\"Finished on $(date)\\\"\" EXIT\n```\n\n### Correct code:\n\n```sh\ntrap 'echo \"Finished on $(date)\"' EXIT\n```\n\n### Rationale:\n\nWith double quotes, all parameter and command expansions will expand when the trap is defined rather than when it's executed.\n\nIn the example with the Problematic code, the message will contain the date on which the trap was declared, and not the date on which the script exits.\n\nUsing single quotes will prevent expansion at declaration time, and save it for execution time.\n\n### Exceptions\n\nIf you don't care that the trap code is expanded early because the commands/variables won't change during execution of the script, or because you want to use the current and not the future values, then you can ignore this message.\n\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2064)"},{"id":"shellcheck_SC2065","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"This is interpreted as a shell file redirection, not a comparison.","description":"This is interpreted as a shell file redirection, not a comparison.","explanation":"## This is interpreted as a shell file redirection, not a comparison.\n\n### Problematic code:\n\n```sh\n[ 1 >2 ] || [ 3>'aaa bb' ] # Simple example of problematic code\n```\n\n### Correct code:\n\n```sh\n[ 1 -gt 2 ] || [ 3 \\> 'aaa bb' ] # arithmetical, lexicographical\n```\n### Rationale:\n\nA word that looks like a redirection in simple shell commands causes it to be interpreted as a redirection.\nShellCheck would guess that you don't want it in tests.\n\n### Exceptions:\n\nWhen it's among a continuous list of redirections at the end of a simple `test` command, it's more likely that\nthe user really meant to do a redirection. Or any other case that you mean to do that.\n\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2065)"},{"id":"shellcheck_SC2066","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"Since you double quoted this, it will not word split, and the loop will only run once.","description":"Since you double quoted this, it will not word split, and the loop will only run once.","explanation":"## Since you double quoted this, it will not word split, and the loop will only run once.\n\n### Problematic code:\n\n```sh\nfor s in \"$(mycommand)\"; do echo \"$s\"; done\n```\n\n### Correct code:\n\nThe correct code depends on your intention. Let's say you're in a directory with the files `file.png` and `My cat.png`, and you want to loop over a command that outputs (or variable that contains):\n\n```sh\nhello world\nMy *.png\n```\n\n#### Loop over each line without globbing (`hello world`, `My *.png`)\n\n```sh\nmycommand | while IFS= read -r s; do echo \"$s\"; done\n```\n\n#### Loop over each word with globbing (`hello`, `world`, `My`, `file.png`, `My cat.png`):\n\n```sh\n# relies on the fact that IFS by default contains space-tab-linefeed\nfor s in $(mycommand); do echo \"$s\"; done\n```\n\n#### Loop over each line with globbing (`hello world`, `My cat.png`)\n\n```sh\n# explicitly set IFS to contain only a line feed\nIFS='\n'\nfor s in $(mycommand); do echo \"$s\"; done\n```\n\n### Rationale:\n\nYou get this warning because you have a loop that will only ever run exactly one iteration. Since you have a loop, you clearly expect it to run more than once. You just have to decide how it should be split up.\n\n### Exceptions\n\nNone.\n\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2066)"},{"id":"shellcheck_SC2067","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"Missing ';' or + terminating -exec. You can't use |/||/&&, and ';' has to be a separate, quoted argument.","description":"Missing ';' or + terminating -exec. You can't use |/||/&&, and ';' has to be a separate, quoted argument.","explanation":"## Missing ';' or + terminating -exec. You can't use |/||/&&, and ';' has to be a separate, quoted argument.\n\n### Problematic code:\n\n```sh\nfind . -type f -exec shellcheck {} | wc -l \\;\nfind . -exec echo {} ;\n```\n\n### Correct code:\n\n```sh\nfind . -type f -exec sh -c 'shellcheck \"$1\" | wc -l' -- {} \\;\nfind . -exec echo {} \\;\n```\n\n### Rationale:\n\n`find -exec` is still subject to all normal shell rules, so all shell features like `|`, `||`, `&` and `&&` will apply to the `find` command itself, and not to the command you are trying to construct with `-exec`.\n\n`find . -exec foo {} && bar {} \\;` means run the command `find . -exec foo {}`, and if find is successful, run the command `bar \"{}\" \";\"`.\n\nTo instead go through each file and run `foo file && bar file` on it, invoke a shell that can interpret `&&`:\n\n```sh\nfind . -exec sh 'foo \"$1\" && bar \"$1\"' -- {} \\;\n```\n\nYou can also use find `-a` instead of shell `&&`:\n\n```sh\nfind . -exec foo {} \\; -a -exec bar {} \\;\n```\n\nThis will have the same effect (`-a` is also the default when two commands are specified, and can therefore be omitted).\n\n### Exceptions\n\nNone\n\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2067)"},{"id":"shellcheck_SC2068","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"Double quote array expansions to avoid re-splitting elements.","description":"Double quote array expansions to avoid re-splitting elements.","explanation":"## Double quote array expansions to avoid re-splitting elements.\n\n### Problematic code:\n\n```sh\ncp $@ ~/dir\n```\n\n### Correct code:\n\n```sh\ncp \"$@\" ~/dir\n```\n\n### Rationale:\n\nDouble quotes around `$@` (and similarly, `${array[@]}`) prevents globbing and word splitting of individual elements, while still expanding to multiple separate arguments.\n\nLet's say you have four arguments: `baz`, `foo bar`, `*` and `/*/*/*/*`\n\n`\"$@\"` will expand into exactly that: `baz`, `foo bar`, `*` and `/*/*/*/*`\n\n`$@` will expand into multiple other arguments: `baz`, `foo`, `bar`, `file.txt`, `otherfile.jpg`, and (eventually) a list of most files on the system\n\nSince the latter is rarely expected or desired, ShellCheck warns about it.\n\n### Exceptions\n\nWhen you want globbing of individual elements.\n\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2068)"},{"id":"shellcheck_SC2069","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"To redirect stdout+stderr, 2>&1 must be last (or use '{ cmd > file; } 2>&1' to clarify).","description":"To redirect stdout+stderr, 2>&1 must be last (or use '{ cmd > file; } 2>&1' to clarify).","explanation":"## To redirect stdout+stderr, 2>&1 must be last (or use '{ cmd > file; } 2>&1' to clarify).\n\n### Problematic code:\n\n```sh\nfirefox 2>&1 > /dev/null\n```\n\n### Correct code:\n\n```sh\nfirefox > /dev/null 2>&1\n```\n\n### Rationale:\n\nWhen it comes to redirection, order matters.\n\nThe problematic code means \"Point stderr to where stdout is currently pointing (the terminal). Then point stdout to /dev/null\".\n\nThe correct code means \"Point stdout to /dev/null. Then point stderr to where stdout is currently pointing (/dev/null)\".\n\nIn other words, the problematic code hides stdout and shows stderr. The correct code hides both stderr and stdout, which is usually the intention.\n\n### Exceptions\n\nIf you actually do want to redirect stdout to a file, and then turn stderr into the new stdout, you can make this more explicit with braces:\n\n    { firefox > /dev/null; } 2>&1\n\nAlso note that this warning does not trigger when output is piped or captured.\n\n### Related resources:\n\n* [Bash Pitfalls: somecmd 2>&1 >>logfile](https://mywiki.wooledge.org/BashPitfalls#pf43)\n* [BashFaq: Tell me all about 2>&1 -- what's the difference between 2>&1 >foo and >foo 2>&1, and when do I use which?](https://mywiki.wooledge.org/BashFAQ/055)\n\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2069)"},{"id":"shellcheck_SC2070","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"`-n` doesn't work with unquoted arguments. Quote or use ``[[ ]]``.","description":"`-n` doesn't work with unquoted arguments. Quote or use ``[[ ]]``.","explanation":"## `-n` doesn't work with unquoted arguments. Quote or use ``[[ ]]``.\n\n### Problematic code:\n\n```sh\nif [ -n $var ]\nthen\n  echo \"var has a value\"\nelse\n  echo \"var is empty\"\nfi\n```\n\n### Correct code:\n\nIn POSIX:\n\n```sh\nif [ -n \"$var\" ]\nthen\n  echo \"var has a value\"\nelse\n  echo \"var is empty\"\nfi\n```\n\nIn bash/ksh:\n\n```sh\nif [[ -n $var ]]\nthen\n  echo \"var has a value\"\nelse\n  echo \"var is empty\"\nfi\n```\n\n\n### Rationale:\n\nWhen `$var` is unquoted, a blank value will cause it to wordsplit and disappear. If `$var` is empty, these two statements are identical:\n\n```sh\n[ -n $var ]\n[ -n ]\n```\n\n`[ string ]` is shorthand for testing if a string is empty. This is still true if `string` happens to be `-n`. `[ -n ]` is therefore true, and by extension so is `[ -n $var ]`.\n\nTo fix this, either quote the variable, or (if your shell supports it) use `[[ -n $var ]]` which generally has fewer caveats than `[`.\n\n### Exceptions:\n\nNone\n\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2070)"},{"id":"shellcheck_SC2071","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"> is for string comparisons. Use -gt instead.","description":"> is for string comparisons. Use -gt instead.","explanation":"## > is for string comparisons. Use -gt instead.\n\n### Problematic code:\n\n```sh\nif [[ $var > 10 ]]\nthen\n  echo \"Incorrectly triggers when var=5\"\nfi\n```\n\n### Correct code:\n\n```sh\nif [[ $var -gt 10 ]]\nthen\n  echo \"Correct numerical comparison\"\nfi\n```\n### Rationale:\n\n`<` and `>`, in both `[[` and `[` (when escaped) will do a lexicographical comparison, not a numerical comparison. \n\nThis means that `[[ 5 > 10 ]]` is true because 5 comes after 10 alphabetically. Meanwhile `[[ 5 -gt 10 ]]` is false because 5 does not come after 10 numerically.\n\nIf you want to compare numbers by value, use the numerical comparison operators `-gt`, `-ge`, `-lt` and `-le`.\n\n### Exceptions:\n\nIf the strings happen to be version numbers and you're using <, or > to compare them as strings, and you consider this an acceptable thing to do, then you can ignore this warning.\n\n### Related resources:\n\n* [Bash Pitfalls: `[[ $foo > 7 ]]`](https://mywiki.wooledge.org/BashPitfalls#pf7)\n* [StackOverflow: Comparing numbers in Bash](https://stackoverflow.com/questions/18668556/comparing-numbers-in-bash)\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2071)"},{"id":"shellcheck_SC2072","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"Decimals are not supported. Either use integers only, or use bc or awk to compare.","description":"Decimals are not supported. Either use integers only, or use bc or awk to compare.","explanation":"## Decimals are not supported. Either use integers only, or use bc or awk to compare.\n\n### Problematic code:\n\n```sh\n[[ 2 -lt 3.14 ]]\n```\n\n### Correct code:\n\n```sh\n[[ 200 -lt 314 ]]                   # Use fixed point math\n[[ $(echo \"2 < 3.14\" | bc) == 1 ]]  # Use bc\n```\n\n### Rationale:\n\nBash and Posix sh does not support decimals in numbers. Decimals should either be avoided, or compared using a tool that does support them.\n\n### Exceptions\n\nIf the strings happen to be version numbers and you're using `<`, or `>` to compare them as strings, and you consider this an acceptable thing to do, then you can ignore this warning.\n\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2072)"},{"id":"shellcheck_SC2073","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"Escape `\\<` to prevent it redirecting (or switch to `[[ .. ]]`).","description":"Escape `\\<` to prevent it redirecting (or switch to `[[ .. ]]`).","explanation":"## Escape `\\<` to prevent it redirecting (or switch to `[[ .. ]]`).\n\n### Problematic code:\n\n```sh\nif [ \"aardvark\" < \"zebra\" ]\nthen\n  echo \"Alphabetical!\"\nfi\n```\n\n### Correct code:\n\n```sh\nif [ \"aardvark\" \\< \"zebra\" ]\nthen\n  echo \"Alphabetical!\"\nfi\n```\n\nor optionally in Bash/Ksh:\n\n```sh\nif [[ \"aardvark\" < \"zebra\" ]]\nthen\n  echo \"Alphabetical!\"\nfi\n```\n### Rationale:\n\nYou are using the operator `<` or `>` in a `[` test expression.\n\nIn this context, it will be considered a file redirection operator instead, so `[ \"aardvark\" < \"zebra\" ]` is equivalent to `[ \"aardvark\" ] < ./zebra`, which is true if there exists a readable file `zebra` in the current directory.\n\nIf you wanted to compare two strings lexicographically (alphabetically), escape the `<` or `>` with a backslash as in the correct example. \n\nIf you want to compare two numbers numerically, use `-lt` or `-ge` instead.\n\n### Exceptions:\n\nNone.\n\n### Related resources:\n\n* Help by adding links to BashFAQ, StackOverflow, man pages, POSIX, etc!\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2073)"},{"id":"shellcheck_SC2074","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"Can't use `=~` in `[ ]`. Use `[[..]]` instead.","description":"Can't use `=~` in `[ ]`. Use `[[..]]` instead.","explanation":"## Can't use `=~` in `[ ]`. Use `[[..]]` instead.\n\n### Problematic code:\n\n```sh\n[ \"$input\" =~ DOC[0-9]*\\.txt ] && echo \"match\"\n```\n\n### Correct code:\n\n```sh\n[[ \"$input\" =~ DOC[0-9]*\\.txt ]] && echo \"match\"\n```\n### Rationale:\n\n`=~` only works in `[[ .. ]]` tests. It does not work with `test` or `[` in any shell.\n\nIf you're targeting POSIX `sh`, rewrite in terms of `case` or `grep` instead.\n\n### Exceptions:\n\nNone.\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2074)"},{"id":"shellcheck_SC2076","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"Don't quote rhs of =~, it'll match literally rather than as a regex.","description":"Don't quote rhs of =~, it'll match literally rather than as a regex.","explanation":"## Don't quote rhs of =~, it'll match literally rather than as a regex.\n\n### Problematic code:\n\n```sh\n[[ $foo =~ \"^fo+ bar$\" ]]\n```\n\n### Correct code:\n\n```sh\n[[ $foo =~ ^fo+\\ bar$ ]]\n```\n\n### Rationale:\n\nQuotes on the right hand side of `=~` can be used to match literally, so that `[[ $1 =~ ^\"$2\".* ]]` works even if `$2` contains regex metacharacters. This mirrors the behavior of globs, `[[ $1 = \"$2\"* ]]`.\n\nThis also means that the problematic code tries to match literal carets and plus signs instead of interpreting them as regular expression matchers.  To match as a regex, the regex metacharacters it must be unquoted. Literal parts of the expression can be quoted with double or single quotes, or escaped.\n\n### Exceptions:\n\nIf you do want to match literally just to do a plain substring search, e.g. `[[ $foo =~ \"bar\" ]]`, you could ignore this message, but consider using a more canonical glob match instead: `[[ $foo == *\"bar\"* ]]`.\n\n### Compatibility:\n\n* In Bash 3.2 and newer with shopt `compat31` *disabled (the default)*, quoted patterns are literal whereas unquoted patterns are parsed for regex metacharacters.\n* In Bash 3.2 and newer with shopt `compat31` *enabled*, quoted and unquoted patterns match identically.\n* In Bash 3.1 quoted and unquoted patterns match identically.\n\nSee http://stackoverflow.com/questions/218156/bash-regex-with-quotes\n\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2076)"},{"id":"shellcheck_SC2077","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"You need spaces around the comparison operator.","description":"You need spaces around the comparison operator.","explanation":"## You need spaces around the comparison operator.\n\n### Problematic code:\n\n```sh\n[[ 0=1 ]]\n```\n\n### Correct code:\n\n```sh\n[[ 0 = 1 ]]\n```\n\n### Rationale:\n\n`[[ 0 = 1 ]]` means \"check if 0 and 1 are equal\".\n\n`[[ str ]]` is short form for `[[ -n str ]]`, and means \"check if `str` is non-empty\". It doesn't matter if `str` happens to contain `0=1`.\n\nAlways use spaces around the comparison operator in `[..]` and `[[..]]`, otherwise it won't be recognized as an operator.\n\n### Exceptions\n\nNone.\n\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2077)"},{"id":"shellcheck_SC2078","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"This expression is constant. Did you forget a `$` somewhere?","description":"This expression is constant. Did you forget a `$` somewhere?","explanation":"## This expression is constant. Did you forget a `$` somewhere?\n### Problematic code:\n\n```sh\nif [ \"myvar\" ]\nthen\n  echo \"myvar is set\"\nfi\n```\n\n### Correct code:\n\n```sh\nif [ \"$myvar\" ]\nthen\n  echo \"myvar is set\"\nfi\n```\n### Rationale:\n\nShellCheck has found a `[ .. ]` or `[[ .. ]]` statement that just contains a literal string. Such a check does not do anything useful, and will always be true (or always false, for empty strings).\n\nThis is usually due to missing `$` or bad quoting:\n\n    if [[ STY ]             # always true\n    if [[ $STY ]]           # checks variable $STY\n\n    if [[ 'grep foo bar' ]] # always true\n    if [[ `grep foo bar` ]] # checks grep output (poorly)\n    if grep -q foo bar      # checks for grep match (preferred)\n\n\n### Exceptions:\n\nNone\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2078)"},{"id":"shellcheck_SC2079","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"(( )) doesn't support decimals. Use bc or awk.","description":"(( )) doesn't support decimals. Use bc or awk.","explanation":"# (( )) doesn't support decimals. Use bc or awk.\n\nBash [arithmetic conditional evaluation can only be performed on integers](https://www.tldp.org/LDP/abs/html/comparison-ops.html). More detail: Bash has limited data types which [include integer](http://www.tldp.org/LDP/abs/html/declareref.html), but everything is effectively [untyped](http://www.tldp.org/LDP/abs/html/untyped.html).\n\nSuggested workarounds to this constraint use bc or awk, here are \n[some examples](https://stackoverflow.com/questions/11237794/how-to-compare-two-decimal-numbers-in-bash-awk).\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2079)"},{"id":"shellcheck_SC2080","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"Numbers with leading 0 are considered octal.","description":"Numbers with leading 0 are considered octal.","explanation":"## Numbers with leading 0 are considered octal.\n\n### Problematic code:\n\n```sh\necho $(( 16 - 08 ))\n```\n\n### Correct code:\n\n```sh\necho $(( 16 - 8 ))\n```\n### Rationale:\n\nShellCheck found an integer literal with a leading zero, but containing the digits 8 or 9.\n\nThis is invalid, as the integer will be interpreted as an octal value (e.g. 0777 == 0x1FF == 511).\n\nTo have the value parsed in base 10, either remove the leading zeros as in the example, or specify the radix explicitly:\n\n    echo $((10#08)) \n\n### Exceptions:\n\nNone\n\n### Related resources:\n\n* Help by adding links to BashFAQ, StackOverflow, man pages, POSIX, etc!\n\n[The BASH manual \"Shell Arithmetic\" chapter](https://www.gnu.org/software/bash/manual/html_node/Shell-Arithmetic.html)\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2080)"},{"id":"shellcheck_SC2081","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"`[ .. ]` can't match globs. Use `[[ .. ]]` or grep.","description":"`[ .. ]` can't match globs. Use `[[ .. ]]` or grep.","explanation":"## `[ .. ]` can't match globs. Use `[[ .. ]]` or grep.\n\n### Problematic code:\n\n```sh\nif [ $var == *[^0-9]* ]\nthen\n  echo \"$var is not numeric\"\nfi \n```\n\n### Correct code:\n\n```sh\nif [[ $var == *[^0-9]* ]]\nthen\n  echo \"$var is not numeric\"\nfi \n```\n### Rationale:\n\n`[ .. ]` aka `test` can not match against globs. \n\nIn bash/ksh, you can instead use `[[ .. ]]` which supports this behavior.\n\nIn sh, you can rewrite to use `grep`. \n\n```sh\nif echo $var | grep -q '^[0-9]*$'; then\n  echo \"$var is numeric\"\nfi\n```\n\n### Exceptions:\n\nNone. If you are not trying to match a glob, quote the argument (e.g. `[ $var == '*' ]` to match literal asterisk. \n[Source](https://github.com/koalaman/shellcheck/wiki/SC2081)"},{"id":"shellcheck_SC2082","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"To expand via indirection, use name=\"foo$n\"; echo \"${!name}\".","description":"To expand via indirection, use name=\"foo$n\"; echo \"${!name}\".","explanation":"## To expand via indirection, use name=\"foo$n\"; echo \"${!name}\".\n\n### Problematic code:\n\n```sh\nvar_1=\"hello world\"\nn=1\necho \"${var_$n}\"\n```\n\n### Correct code:\n\nBash/ksh:\n\n```sh\n# Use arrays instead of dynamic names\ndeclare -a var\nvar[1]=\"hello world\"\nn=1\necho \"${var[n]}\"\n```\n\nor\n\n```sh\n# Expand variable names dynamically\nvar_1=\"hello world\"\nn=1\nname=\"var_$n\"\necho \"${!name}\"\n```\n\nPOSIX sh:\n\n```sh\n# Expand dynamically with eval\nvar_1=\"hello world\"\nn=1\neval \"tmp=\\$var_$n\"\necho \"${tmp}\"\n```\n\n### Rationale:\n\nYou can expand a variable `var_1` with `${var_1}`, but you can not generate the string `var_1` with an embedded expansion, like `${var_$n}`.\n\nInstead, if at all possible, you should use an array. Bash and ksh support both numerical and associative arrays, and an example is shown above.\n\nIf you can't use arrays, you can indirectly reference variables by creating a temporary variable with its name, e.g. `myvar=\"var_$n\"` and then expanding it indirectly with `${!myvar}`. This will give the contents of the variable `var_1`.\n\nIf using POSIX sh, where neither arrays nor `${!var}` is available, `eval` can be used. You must be careful in sanitizing the data used to construct the variable name to avoid arbitrary code execution.\n\n### Exceptions:\n\nNone\n\n### Related resources:\n\n* [BashFaq: How can I use variable variables (indirect variables, pointers, references) or associative arrays?](https://mywiki.wooledge.org/BashFAQ/006)\n* [StackOverflow: Dynamic variable names in Bash](https://stackoverflow.com/questions/16553089/dynamic-variable-names-in-bash)\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2082)"},{"id":"shellcheck_SC2084","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"Remove '$' or use '_=$((expr))' to avoid executing output.","description":"Remove '$' or use '_=$((expr))' to avoid executing output.","explanation":"## Remove '$' or use '_=$((expr))' to avoid executing output.\n\n### Problematic code:\n\n```sh\ni=4\n$(( i++ ))\n```\n\n### Correct code:\n\nBash, Ksh:\n\n```sh\ni=4\n(( i++ ))\n```\n\nPOSIX (assuming `++` is supported):\n\n```sh\ni=4\n_=$(( i++ ))\n```\n\nAlternative POSIX version that does not preserve the exit code:\n\n```sh\n: $(( i++ ))\n```\n\n### Rationale:\n\n`$((..))` expands to a number. If it's the only word on the line, the shell will try to execute this number as a command name:\n\n```sh\n$ i=4\n$ $(( i++ ))\n4: command not found\n$ echo $i\n5\n```\n\nTo avoid trying to execute the number as a command name, use one of the methods mentioned:\n\n```sh\n$ i=4\n$ _=$(( i++ ))\n$ echo $i\n5\n```\n\n### Exceptions:\n\nNone.\n\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2084)"},{"id":"shellcheck_SC2086","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":true,"parameters":[],"title":"Double quote to prevent globbing and word splitting.","description":"Double quote to prevent globbing and word splitting.","explanation":"# Double quote to prevent globbing and word splitting.\n\n## Problematic code:\n\n```sh\necho $1\nfor i in $*; do :; done # this one and the next one also apply to expanding arrays.\nfor i in $@; do :; done\n```\n\n## Correct code:\n\n```sh\necho \"$1\"\nfor i in \"$@\"; do :; done # or, 'for i; do'\n```\n## Rationale\n\nThe first code looks like \"print the first argument\". It's actually \"Split the first argument by IFS (spaces, tabs and line feeds). Expand each of them as if it was a glob. Join all the resulting strings and filenames with spaces. Print the result.\"\n\nThe second one looks like \"iterate through all arguments\". It's actually \"join all the arguments by the first character of IFS (space), split them by IFS and expand each of them as globs, and iterate on the resulting list\". The third one skips the joining part.\n\nQuoting variables prevents word splitting and glob expansion, and prevents the script from breaking when input contains spaces, line feeds, glob characters and such.\n\nStrictly speaking, only expansions themselves need to be quoted, but for stylistic reasons, entire arguments with multiple variable and literal parts are often quoted as one:\n\n```sh\n$HOME/$dir/dist/bin/$file        # Unquoted (bad)\n\"$HOME\"/\"$dir\"/dist/bin/\"$file\"  # Minimal quoting (good)\n\"$HOME/$dir/dist/bin/$file\"      # Canonical quoting (good)\n```\n\nWhen quoting composite arguments, make sure to exclude globs and brace expansions, which lose their special meaning in double quotes: `\"$HOME/$dir/src/*.c\"` will not expand, but `\"$HOME/$dir/src\"/*.c` will.\n\nNote that `$( )` starts a new context, and variables in it have to be quoted independently:\n\n```sh\necho \"This $variable is quoted $(but this $variable is not)\"\necho \"This $variable is quoted $(and now this \"$variable\" is too)\"\n```\n\n### Exceptions\nSometimes you want to split on spaces, like when building a command line:\n\n```sh\noptions=\"-j 5 -B\"\n[[ $debug == \"yes\" ]] && options=\"$options -d\"\nmake $options file\n```\n\nJust quoting this doesn't work. Instead, you should have used an array (bash, ksh, zsh):\n\n```bash\noptions=(-j 5 -B) # ksh88: set -A options -- -j 5 -B\n[[ $debug == \"yes\" ]] && options=(\"${options[@]}\" -d)\nmake \"${options[@]}\" file\n```\n\nor a function (POSIX):\n\n```sh\nmake_with_flags() {\n  [ \"$debug\" = \"yes\" ] && set -- -d \"$@\"\n  make -j 5 -B \"$@\"\n}\nmake_with_flags file\n```\n\nTo split on spaces but not perform glob expansion, Posix has a `set -f` to disable globbing.  You can disable word splitting by setting `IFS=''`.\n\nSimilarly, you might want an optional argument:\n\n```sh\ndebug=\"\"\n[[ $1 == \"--trace-commands\" ]] && debug=\"-x\"\nbash $debug script\n```\n\nQuoting this doesn't work, since in the default case, `\"$debug\"` would expand to one empty argument while `$debug` would expand into zero arguments. In this case, you can use an array with zero or one elements as outlined above, or you can use an unquoted expansion with an alternate value:\n\n```sh\ndebug=\"\"\n[[ $1 == \"--trace-commands\" ]] && debug=\"yes\"\nbash ${debug:+\"-x\"} script\n```\n\nThis is better than an unquoted value because the alternative value can be properly quoted, e.g. `wget ${output:+ -o \"$output\"}`.\n\n---\n\nHere are two common cases where this warning seems unnecessary but may still be beneficial:\n\n```sh\ncmd <<< $var         # Requires quoting on Bash 3 (but not 4+)\n: ${var=default}     # Should be quoted to avoid DoS when var='*/*/*/*/*/*'\n```\n\n---\n\nAs always, this warning can be [[ignored|ignore]] on a case-by-case basis.\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2086)"},{"id":"shellcheck_SC2087","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"Quote 'EOF' to make here document expansions happen on the server side rather than on the client.","description":"Quote 'EOF' to make here document expansions happen on the server side rather than on the client.","explanation":"## Quote 'EOF' to make here document expansions happen on the server side rather than on the client.\n\n### Problematic code:\n\n```sh\nssh host.example.com << EOF\n  echo \"Logged in on $HOSTNAME\"\nEOF\n```\n\n### Correct code:\n\n```sh\nssh host.example.com << \"EOF\"\n  echo \"Logged in on $HOSTNAME\"\nEOF\n```\n\n### Rationale:\n\nWhen the end token of a here document is unquoted, parameter expansion and command substitution will happen on in contents of the here doc.\n\nThis means that before sending the commands to the server, the client replaces `$HOSTNAME` with localhost, thereby sending `echo \"Logged in on localhost\"` to the server. This has the effect of printing the client's hostname instead of the server's.\n\nScripts with any kind of variable use are especially problematic because all references will be expanded before the script run. For example,\n\n```sh\nssh host << EOF\n  x=\"$(uname -a)\"\n  echo \"$x\"\nEOF\n```\n\nwill never print anything, neither client nor server details, since before evaluation, it will be expanded to:\n\n```sh\n  x=\"Linux localhost ... x86_64 GNU/Linux\"\n  echo \"\"\n```\n\nBy quoting the here token, local expansion will not take place, so the server sees `echo \"Logged in on $HOSTNAME\"` which is expanded and printed with the server's hostname, which is usually the intention.\n\n### Exceptions:\n\nIf the client should expand some or all variables, this message can and should be ignored.\n\nTo expand a mix of local and remote variables, the here doc end token should be unquoted, and the remote variables should be escaped, e.g.\n\n```sh\nssh host.example.com << EOF\n  echo \"Logged in on \\$HOSTNAME from $HOSTNAME\"\nEOF\n```\n\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2087)"},{"id":"shellcheck_SC2088","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"Tilde does not expand in quotes. Use $HOME.","description":"Tilde does not expand in quotes. Use $HOME.","explanation":"## Tilde does not expand in quotes. Use $HOME.\n\n### Problematic code:\n\n```sh\nrm \"~/Desktop/$filename\"\n```\n\n### Correct code:\n\n```sh\nrm \"$HOME/Desktop/$filename\"\n```\n\n### Rationale:\n\nTilde does not expand to the user's home directory when it's single or double quoted. Use double quotes and `$HOME` instead.\n\nAlternatively, the `~/` can be left unquoted, as in `rm ~/\"Desktop/$filename\"`.\n\n### Exceptions\n\nIf you don't want the tilde to be expanded, you can ignore this message.\n\n### Related resources:\n\n* StackOverflow: [Why isn't tilde (~) expanding inside double quotes?](https://stackoverflow.com/questions/41871596/why-isnt-tilde-expanding-inside-double-quotes)\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2088)"},{"id":"shellcheck_SC2089","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"Quotes/backslashes will be treated literally. Use an array.","description":"Quotes/backslashes will be treated literally. Use an array.","explanation":"# Quotes/backslashes will be treated literally. Use an array.\n\n### Problematic code:\n\n```sh\nargs='-lh \"My File.txt\"'\nls $args\n```\n\n### Correct code:\n\nIn Bash/Ksh with arrays:\n\n```sh\nargs=(-lh \"My File.txt\")\nls \"${args[@]}\"\n```\n\nor in POSIX overwriting `\"$@\"`:\n\n```sh\nset -- -lh \"My File.txt\"\nls \"$@\"\n```\n\nor in POSIX via functions:\n\n```sh\nmyls() { ls \"-lh\" \"My File.txt\"; }\nmyls\n```\n\n### Rationale:\n\nBash does not interpret data as code. Consider almost any other languages, such as Python:\n\n```python\nprint 1+1   # prints 2\na=\"1+1\"\nprint a     # prints 1+1, not 2\n```\n\nHere, `1+1` is Python syntax for adding numbers. However, passing a literal string containing this expression does not cause Python to interpret it, see the `+` and produce the calculated result.\n\nSimilarly, `\"My File.txt\"` is Bash syntax for a single word with a space in it. However, passing a literal string containing this expression does not cause Bash to interpret it, see the quotes and produce the tokenized result.\n\nThe solution is to use an array instead, whenever possible.\n\nIf due to `sh` compatibility you can't use arrays, you can sometimes use functions instead. Instead of trying to create a set of arguments that has to be passed to a command, create a function that calls the function with arguments plus some more:\n\n```sh\nffmpeg_with_args() {\n  ffmpeg -filter_complex '[#0x2ef] setpts=PTS+1/TB [sub] ; [#0x2d0] [sub] overlay' \"$@\"\n}\nffmpeg_with_args -i \"My File.avi\" \"Output.avi\"\n```\n\nIn other cases, you may have to use `eval` instead, though this is often fragile and insecure. If you get it wrong, it'll appear to work great in all test cases, and may still lead to various forms of security vulnerabilities and breakage:\n\n```sh\nquote() { local q=${1//\\'/\\'\\\\\\'\\'}; echo \"'$q'\"; }\nargs=\"-lh $(quote \"My File.txt\")\"\neval ls \"$args\" # Do not use unless you understand implications\n```\n\nIf you ever accidentally forget to use proper quotes, such as with:\n\n```sh\nfor f in *.txt; do\n  args=\"-lh '$1'\" # Example security exploit\n  eval ls \"$args\" # Do not copy and use\ndone\n```\n\nThen you can use `touch \"'; rm -rf \\$'\\x2F'; '.txt\"`  (or someone can trick you into downloading a file with this name, or create a zip file or git repo containing it, or changing their nick and have your chat client create the file for a chat log, or...), and running the script to list your files will run the command `rm -rf /`.\n\n### Exceptions\n\nFew and far between.\n\n### Additional resources\n\n* [Wooledge BashFAQ #50](http://mywiki.wooledge.org/BashFAQ/050): I'm trying to put a command in a variable, but the complex cases always fail!\n* [StackOverflow: In bash, why do shell commands ignore quotes in arguments when the arguments are passed to them as a variable?](https://stackoverflow.com/questions/12136948/in-bash-why-do-shell-commands-ignore-quotes-in-arguments-when-the-arguments-are)\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2089)"},{"id":"shellcheck_SC2090","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"Quotes/backslashes in this variable will not be respected.","description":"Quotes/backslashes in this variable will not be respected.","explanation":"# Quotes/backslashes in this variable will not be respected.\n\nSee companion warning, [[SC2089]].\n\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2090)"},{"id":"shellcheck_SC2091","category":"Security","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"Remove surrounding $() to avoid executing output (or use eval if intentional).","subCategory":"CommandInjection","description":"Remove surrounding $() to avoid executing output (or use eval if intentional).","explanation":"## Remove surrounding $() to avoid executing output (or use eval if intentional).\n\n### Problematic code:\n\n```sh\nif $(which epstopdf)\nthen\n  echo \"Found epstopdf\"\nfi\n```\n\nor\n\n```sh\nmake_command() {\n  printf 'cat header %q footer > %q\\n' \"$1\" \"$2\" | tee log\n}\n$(make_command foo.html output/foo.html)\n```\n\n### Correct code:\n\n```sh\nif which epstopdf\nthen\n  echo \"Found epstopdf\"\nfi\n```\n\nor \n\n```sh\nmake_command() {\n  printf 'cat header %q footer > %q\\n' \"$1\" \"$2\" | tee log\n}\neval \"$(make_command foo.html output/foo.html)\"\n```\n### Rationale:\n\nShellCheck has detected that you have a command that just consists of a command substitution. This often happens when you want to run a command (possibly from a variable name), without realizing that `$(..)` is for capturing and not for executing.\n\nFor example, if you have this shell function:\n\n    sayhello() { echo \"hello world\"; }\n\nThen `$(sayhello)` will:\n\n1. Run `sayhello`, capturing \"hello world\"\n1. Run `hello world`, resulting in `bash: hello: command not found`\n\nMeanwhile, just `sayhello` will:\n\n1. Run `sayhello`, outputting \"hello world\" to screen\n\nNote that this is equally true if the command is in a variable, e.g. `x=sayhello; $($x)`.\n\nIf you *do* have a command that outputs a second command, similar to how `ssh-agent` outputs `export` commands to run, then you should do this via `eval`. This way, quotes, pipes, redirections, semicolons, and other shell constructs will work as expected. Note that this kind of design is best avoided when possible, since correctly escaping all values can be difficult and error prone. \n\n### Exceptions:\n\nNone.\n\n### Related resources:\n\n* StackOverflow: [Bash Function -> Command not found](https://stackoverflow.com/questions/18611842/bash-function-command-not-found)\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2091)"},{"id":"shellcheck_SC2092","category":"Security","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"Remove backticks to avoid executing output.","subCategory":"CommandInjection","description":"Remove backticks to avoid executing output.","explanation":"## Remove backticks to avoid executing output.\n\nBackticks does the same thing as `$(..)`. See [[SC2091]] for a description of the same problem with this syntax.\n\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2092)"},{"id":"shellcheck_SC2093","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"Remove \"exec \" if script should continue after this command.","description":"Remove \"exec \" if script should continue after this command.","explanation":"## Remove \"exec \" if script should continue after this command.\n\n### Problematic code:\n\n```sh\necho \"Starting compilation\"\nexec ./compile\necho \"Starting deployment\"\nexec ./deploy\n```\n\n### Correct code:\n\n```sh\necho \"Starting compilation\"\n./compile\necho \"Starting deployment\"\n./deploy\n```\n\n### Rationale:\n\nThe script contains an `exec` command followed by other commands in the same block. This is likely an error because the script will not resume after an `exec` command.\n\nInstead, \"exec\" refers to the Unix process model's idea of execution (see [`execve(2)`](http://man7.org/linux/man-pages/man2/execve.2.html)), in which the current process stops its current program and replaces it with a new one. This is mainly used in wrapper scripts.\n\nTo execute another script or program and then continue, simply drop the `exec` as in the example.\n\n### Exceptions:\n\nIf the code after the `exec` is only there to handle a failure in executing the command you can ignore this warning. For this reason, ShellCheck suppresses the warning if `exec` is only followed by `echo`/`exit` commands.\n\n### Related resources:\n\n* StackOverflow: [My shell script stops after exec](https://stackoverflow.com/questions/3877657/my-shell-script-stops-after-exec)\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2093)"},{"id":"shellcheck_SC2094","category":"CodeStyle","level":"Info","severityLevel":"Info","enabled":false,"parameters":[],"title":"SC2094 Make sure not to read and write the same file in the same pipeline.","description":"SC2094 Make sure not to read and write the same file in the same pipeline.","explanation":"# SC2094 Make sure not to read and write the same file in the same pipeline.\n\n### Problematic code:\n\n```sh\ngrep foo file.txt | sed -e 's/foo/bar/g' > file.txt\n```\n\n### Correct code:\n\n```sh\ngrep foo file.txt  | sed -e 's/foo/bar/g' > tmpfile && mv tmpfile file.txt\n```\n\n### Rationale:\n\nEach step in a pipeline runs in parallel.\n\nIn this case, `grep foo file.txt` will immediately try to read `file.txt` while `sed .. > file.txt` will immediately try to truncate it.\n\nThis is a race condition, and results in the file being partially or (far more likely) entirely truncated.\n\nNote that this can also be a problem when you write to a file and read from it later in the pipe. The second command (which reads the file) may not see all the output of the first. An exception in this case is a non-greedy file reader like `less`, for example `python foo.py 2> errfile.txt | less - errfile.txt` will successfully allow you to see stdout and stderr separately in less.\n\n### Exceptions\n\nYou can ignore this error if:\n\n* The file is a device or named pipe. These files don't truncate in the same way.\n* The command mentions the filename but doesn't read/write it, such as `echo log.txt > log.txt`.\n\n### Additional Resources\n\n* [StackOverflow: bash redirect input from file back into same file](https://stackoverflow.com/questions/6696842/bash-redirect-input-from-file-back-into-same-file)\n* [BashPitfalls: `cat file | sed s/foo/bar/ > file`](https://mywiki.wooledge.org/BashPitfalls#pf13)\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2094)"},{"id":"shellcheck_SC2095","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"Use ssh -n to prevent ssh from swallowing stdin.","description":"Use ssh -n to prevent ssh from swallowing stdin.","explanation":"## Use ssh -n to prevent ssh from swallowing stdin.\n\nThe same error applies to multiple commands, like `ffmpeg -nostdin` and `mplayer -noconsolecontrols`.\n\n### Problematic code:\n\n```sh\nwhile read -r host\ndo\n  ssh \"$host\" \"uptime\"\ndone < hosts.txt\n```\n\n### Correct code:\n\n```sh\nwhile read -r host\ndo\n  ssh -n \"$host\" \"uptime\"\ndone < hosts.txt\n```\n\nor\n\n```sh\nwhile read -r host\ndo\n  ssh \"$host\" <<'EOF'\nuptime\nEOF\ndone < hosts.txt\n```\n\n### Rationale:\n\nCommands that process stdin will compete with the `read` statement for input. This is especially tricky for commands you wouldn't expect reads from stdin, like `ssh .. uptime`, `ffmpeg` and `mplayer`.\n\nThe most common symptom of this is a `while read` loop only running once, even though the input contains many lines. This is because the rest of the lines are swallowed by the offending command.\n\nTo refuse such commands input, you can use a command specific option like `ssh -n` or `ffmpeg -nostdin`. \n\nMore generally, you can also redirect their stdin with `< /dev/null`. This works for all commands with this behavior.\n\n### Exceptions:\n\nNone.\n\n### Related resources:\n\n* [BashFaq: I'm reading a file line by line and running ssh or ffmpeg, only the first line gets processed!](https://mywiki.wooledge.org/BashFAQ/089)\n* [StackOverflow: Shell script while read line loop stops after the first line\n](https://stackoverflow.com/questions/13800225/shell-script-while-read-line-loop-stops-after-the-first-line)\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2095)"},{"id":"shellcheck_SC2096","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"On most OS, shebangs can only specify a single parameter.","description":"On most OS, shebangs can only specify a single parameter.","explanation":"## On most OS, shebangs can only specify a single parameter.\n\n### Problematic code:\n\n```sh\n#!/usr/bin/env bash -x\n```\n\n### Correct code:\n\n```sh\n#!/usr/bin/env bash\nset -x\n```\n\n### Rationale:\n\nMost operating systems, including POSIX, Linux and FreeBSD, allow only a single parameter in the shebang. The example is equivalent to calling `env 'bash -x'` instead of `env 'bash' '-x'`, and it will therefore fail.\n\nThe shebang should be rewritten to use at most one parameter. Shell options can instead be set in the body of the script.\n\n### Exceptions\n\nmacOS X currently allows multiple words in the shebang. Scripts running on OSX exclusively can ignore this warning.\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2096)"},{"id":"shellcheck_SC2097","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"This assignment is only seen by the forked process.","description":"This assignment is only seen by the forked process.","explanation":"## This assignment is only seen by the forked process.\n\n### Problematic code:\n\n```sh\nname=World cmd -m \"Hello $name\"\n```\n\n### Correct code:\n\n```sh\nname=World\ncmd -m \"Hello $name\"\n```\n\nIf the original goal was to limit the scope of the variable, this can also be done in a subshell:\n\n```sh\n(\n   name=World\n   cmd -m \"Hello $name\"\n) # 'name' does not leave this subshell\n```\n\n### Rationale:\n\nIn `name=World cmd \"$name\"`, `name=World` is passed in as part of the environment to `cmd` (i.e., in the `envp` parameter to [execve(2)](http://linux.die.net/man/2/execve)).  This means that `cmd` and its children will see the parameter, but no other processes will.\n\nHowever, `\"$name\"` is not expanded by `cmd`. `\"$name\"` is expanded by the shell before `cmd` is ever executed, and thus it will not use the new value.\n\nThe solution is to set the variable first, then use it as a parameter. If limited scope is desired, a `( subshell )` can be used.\n\n### Exceptions\n\nIn the strange and fabricated scenarios where the script and a program uses a variable name for two different purposes, you can ignore this message. This is hard to conceive, since scripts should use lowercase variable names specifically to avoid collisions with the environment.\n\n### Related resources:\n\n* [BashFaq: Why doesn't foo=bar echo \"$foo\" print bar?](https://mywiki.wooledge.org/BashFAQ/104)\n* [StackOverflow: Prefixing variable assignment doesn't work with echo](https://stackoverflow.com/questions/36380569/prefixing-variable-assignment-doesnt-work-with-echo?rq=1)\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2097)"},{"id":"shellcheck_SC2098","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"This expansion will not see the mentioned assignment.","description":"This expansion will not see the mentioned assignment.","explanation":"## This expansion will not see the mentioned assignment.\n\nSee companion warning [[SC2097]].\n\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2098)"},{"id":"shellcheck_SC2099","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"Use `$((..))` for arithmetics, e.g. `i=$((i + 2))`","description":"Use `$((..))` for arithmetics, e.g. `i=$((i + 2))`","explanation":"## Use `$((..))` for arithmetics, e.g. `i=$((i + 2))`\n\n### Problematic code:\n\n```sh\ni=3\ni=i + 2\n```\n\n### Correct code:\n\n```sh\ni=3\ni=$((i + 2))\n```\n\n### Rationale:\n\nUnlike most languages, variable assignments in shell scripts are space sensitive and (almost) always assign strings.\n\nTo evaluate a mathematical expressions, use `$((..))` as in the correct code:\n\n    i=$((i + 2))   # Spaces are fine inside $((...))\n\nIn the problematic code, `i=i + 2` will give an error `+: command not found` because the expression is interpreted similar to something like `LC_ALL=C wc -c` instead of numerical addition:\n \n     Prefix assignment    Command  Argument\n     LC_ALL=C             wc       -c\n     i=i                  +        2\n\n### Exceptions:\n\nIf you wanted to assign a literal string, quote it:\n\n    game_score=\"0 - 2\"\n\n### Related resources:\n\n* Help by adding links to BashFAQ, StackOverflow, man pages, POSIX, etc!\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2099)"}],"pagination":{"cursor":"MjAw","limit":100,"total":411}}