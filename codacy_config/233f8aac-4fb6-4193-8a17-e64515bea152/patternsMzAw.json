{"data":[{"id":"shellcheck_SC2214","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"This case is not specified by getopts.","description":"This case is not specified by getopts.","explanation":"## This case is not specified by getopts.\n\n### Problematic code:\n\n```sh\nwhile getopts \"vr\" n\ndo\n  case \"$n\" in\n    v) echo \"Verbose\" ;;\n    r) echo \"Recursive\" ;;\n    n) echo \"Dry-run\" ;;\n    *) usage;;\n  esac\ndone\n```\n\n### Correct code:\n\n```sh\nwhile getopts \"vrn\" n    # 'n' added here\ndo\n  case \"$n\" in\n    v) echo \"Verbose\" ;;\n    r) echo \"Recursive\" ;;\n    n) echo \"Dry-run\" ;;\n    *) usage;;\n  esac\ndone\n```\n### Rationale:\n\nYou have a `case` statement in a `while getopts` loop that matches a flag that hasn't been provided in the `getopts` option string.\n\nEither add the flag to the options list, or delete the case statement.\n\n### Exceptions:\n\nNone.\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2214)"},{"id":"shellcheck_SC2215","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"This flag is used as a command name. Bad line break or missing `[ .. ]`?","description":"This flag is used as a command name. Bad line break or missing `[ .. ]`?","explanation":"## This flag is used as a command name. Bad line break or missing `[ .. ]`?\n\n### Problematic code:\n\n```sh\nif -e .bashrc\nthen\n  echo \".bashrc already exists\"\nfi\n```\n\nor\n\n```sh\nfind . -name '*.mkv'\n       -exec mplayer {} \\;\n```\n\n### Correct code:\n\n```sh\nif [ -e .bashrc ]\nthen\n  echo \".bashrc already exists\"\nfi\n```\n\nor\n\n```sh\nfind . -name '*.mkv' \\\n       -exec mplayer {} \\;\n```\n### Rationale:\n\nYou are using a name that starts with a dash as a command name. This is almost always a bug.\n\nThere are two typical ways in which this happens:\n\n* Missing `[ .. ]` or `[[ .. ]]` around a test expression, like in the first example example. \n* An invalid line break that splits a command in two, like in the second example.\n\n### Exceptions:\n\nIf you actually have a command that starts with a dash -- which you should really reconsider -- you can quote the name (or at least the leading dash). This makes no difference to the shell, but makes it clear to ShellCheck and humans that this is not intended as a flag.\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2215)"},{"id":"shellcheck_SC2216","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"Piping to 'rm', a command that doesn't read stdin. Wrong command or missing xargs?","description":"Piping to 'rm', a command that doesn't read stdin. Wrong command or missing xargs?","explanation":"## Piping to 'rm', a command that doesn't read stdin. Wrong command or missing xargs?\n\n### Problematic code:\n\n```sh\nls | echo                      # Want to print result\ncat files | rm                 # Want to delete items from a file\nfind . -type f | cp dir        # Want to process 'find' output\nrm file | true                 # Want to ignore errors\n```\n\n### Correct code:\n\n```sh\nls\ncat files | while IFS= read -r file; do rm -- \"$file\"; done\nfind . -type f -exec cp {} dir \\;\nrm file || true\n```\n\n### Rationale:\n\nYou are piping to one of several commands that don't read from stdin.\n\nThis may happen when:\n\n* Confusing one command for another, e.g. using `echo` where `cat` was intended.\n* Incorrectly refactoring, leaving a `|` on the previous line.\n* Missing `xargs`, because stdin should be passed as positional parameters instead (use `xargs -0` if at all possible).\n* Intending to use `||` instead of `|`\n\nCheck your logic, and rewrite the command so data is passed correctly.\n\n### Exceptions:\n\nIf you've overridden a command to return output, you can either rename it to make this obvious, or [[ignore]] this message.\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2216)"},{"id":"shellcheck_SC2217","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"Redirecting to 'echo', a command that doesn't read stdin. Bad quoting or missing xargs?","description":"Redirecting to 'echo', a command that doesn't read stdin. Bad quoting or missing xargs?","explanation":"## Redirecting to 'echo', a command that doesn't read stdin. Bad quoting or missing xargs?\n\n### Problematic code:\n\n```sh\necho << eof\n  Hello World\neof\n```\n\n### Correct code:\n\n```sh\ncat << eof\n  Hello World\neof\n```\n\n### Rationale:\n\nYou are redirecting to one of several commands that don't read from stdin.\n\nThis may happen when:\n\n* Confusing one command for another, e.g. using `echo` where `cat` was intended.\n* Incorrectly quoting angle brackets, e.g. using `echo <p>Hello` which tries to read from a file `p`.\n* Missing `xargs`, e.g. `mv -t dir < files` instead of `xargs mv -t dir < files` (or more safely, `tr '\\n' '\\0' < files | xargs -0 mv -t dir`), because stdin should be passed as parameters.\n\nCheck your logic, and rewrite the command so data is passed correctly.\n\n### Exceptions:\n\nIf you've overridden a command to return output, you can either rename it to make this obvious, or [[ignore]] this message.\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2217)"},{"id":"shellcheck_SC2218","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"This function is only defined later. Move the definition up.","description":"This function is only defined later. Move the definition up.","explanation":"## This function is only defined later. Move the definition up.\n\n### Problematic code:\n\n```sh\n#!/bin/sh\nmyfunction\n\nmyfunction() {\n  echo \"Hello World\"\n}\n```\n\n### Correct code:\n\n```sh\n#!/bin/sh\nmyfunction() {\n  echo \"Hello World\"\n}\nmyfunction\n```\n\n### Rationale:\n\nYou are calling a function that you are defining later in the file. The function definition must come first.\n\nFunction definitions are much like variable assignments, and define a name at the point the definition is \"executed\". This is why they must happen before their first use.\n\nThis is especially apparent when defining functions conditionally:\n\n```\ncase \"$(uname -s)\" in\n  Linux) hi() { echo \"Hello from Linux\"; } ;;\n  Darwin) hi() { echo \"Hello from macOS\"; } ;;\n  *) hi() { echo \"Hello from something else\"; } ;;\nesac\n\nhi\n```\n\n\n### Exceptions:\n\nNone. \n[Source](https://github.com/koalaman/shellcheck/wiki/SC2218)"},{"id":"shellcheck_SC2219","category":"CodeStyle","level":"Info","severityLevel":"Info","enabled":false,"parameters":[],"title":"Instead of `let expr`, prefer `(( expr ))` .","description":"Instead of `let expr`, prefer `(( expr ))` .","explanation":"## Instead of `let expr`, prefer `(( expr ))` .\n\n### Problematic code:\n\n```sh\nlet a++\n```\n\n### Correct code:\n\n```sh\n(( a++ )) || true\n```\n\n> Note, `|| true` bits ignore error status code when incrementing from `0` to `1`\n\n### Rationale:\n\nThe `(( .. ))` arithmetic compound command evaluates expressions in the same way as `let`, except it's not subject to glob expansion and therefore requires no additional quoting or escaping. \n\nThis warning only triggers in Bash/Ksh scripts. In Sh/Dash, neither `let` nor `(( .. ))` are defined, but can be simulated with `[ $(( expr )) -ne 0 ]` to retain exit code, or `: $(( expr ))` to ignore it.\n\n### Exceptions:\n\nNone.\n\n### More information\n\n* Bash Hacker's Wiki: [The let builtin command](http://wiki.bash-hackers.org/commands/builtin/let)\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2219)"},{"id":"shellcheck_SC2220","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"Invalid flags are not handled. Add a `*)` case.","description":"Invalid flags are not handled. Add a `*)` case.","explanation":"## Invalid flags are not handled. Add a `*)` case.\n\n### Problematic code:\n\n```sh\n#!/bin/sh\nwhile getopts \"vr\" f\ndo\n  case \"$f\" in\n    v) echo \"verbose\" ;;\n    r) echo \"recursive\" ;;\n  esac\ndone\n```\n\n### Correct code:\n\n```sh\n#!/bin/sh\nwhile getopts \"vr\" f\ndo\n  case \"$f\" in\n    v) echo \"verbose\" ;;\n    r) echo \"recursive\" ;;\n    *) echo \"usage: $0 [-v] [-r]\" >&2\n       exit 1 ;;\n  esac\ndone\n```\n\n### Rationale:\n\nThe `case` statement handling `getopts` arguments does not have a default branch to handle unknown flags.\n\nWhen a flag is not recognized, such as if passing `-Z` to the example code, `getopts` will set the variable to a literal question mark `?`. This should be handled along with all the valid flags, usually by printing a usage message and exiting with failure.\n\nUsing a `\\?)` or `?)` case will also match invalid flags, but`*)` would additionally match things like the empty string if the variable name was misspelled.\n\n### Exceptions:\n\nIf your script's logic handles unrecognized flags in another way, e.g. after the `case` statement, you can ignore this warning.\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2220)"},{"id":"shellcheck_SC2221","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"This pattern always overrides a later one.","description":"This pattern always overrides a later one.","explanation":"## This pattern always overrides a later one.\n\n### Problematic code:\n\n```sh\ncase \"$1\" in\n  -?) echo \"Usage: $0 [-n]\";;\n  -n) echo \"Hello World\";;\n   *) exit 1;;\nesac\n```\n\n### Correct code:\n\n```sh\ncase \"$1\" in\n  -\\?) echo \"Usage: $0 [-n]\";;\n# '-?') echo \"Usage: $0 [-n]\";;  # Also valid\n  -n) echo \"Hello World\";;\n   *) exit 1;;\nesac\n```\n### Rationale:\n\nYou have specified multiple patterns in a `case` statement, where one will always override the other. The pattern being overridden is indicated with a [[SC2222]] warning.\n\nIn the example, `-?` actually matches a dash followed by any character, such as `-n`. This means that the later `-n` branch will never trigger. In this case, the correct solution is to escape the `-\\?` so that it doesn't match `-n`. \n\nAnother common reason for this is accidentally duplicating a branch. In this case, fix or delete the duplicate branch.\n\n### Exceptions:\n\nNone. One could argue that having `-*|--*) echo \"Invalid flag\";` is a readability issue, even though the second pattern follows from the first. In this case, you can either rearrange the pattern from most to least specific, i.e. `--*|-*)` or ignore the error.\n\nWhen ignoring this error, remember that ShellCheck directives have to go in front of the `case` statement, and not in front of the branch:\n\n    # shellcheck disable=SC2221,SC2222\n    case \"$1\" in\n      -n) ...;;\n      # no directive here\n      -*|--*) echo \"Unknown flag\" ;;\n    esac\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2221)"},{"id":"shellcheck_SC2222","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"This pattern never matches because of a previous pattern.","description":"This pattern never matches because of a previous pattern.","explanation":"## This pattern never matches because of a previous pattern.\n\nSee companion warning [[SC2221]].\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2222)"},{"id":"shellcheck_SC2223","category":"Security","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"This default assignment may cause DoS due to globbing. Quote it.","subCategory":"DoS","description":"This default assignment may cause DoS due to globbing. Quote it.","explanation":"## This default assignment may cause DoS due to globbing. Quote it.\n\n### Problematic code:\n\n```sh\n: ${COLUMNS:=80}\n```\n\n### Correct code:\n\n```sh\n: \"${COLUMNS:=80}\"\n```\n### Rationale:\n\nThis statement is an idiomatic way of assigning a default value to an environment variable. However, even though it's passed to `:` which ignores arguments, it's better to quote it.\n\nIf `COLUMNS='/*/*/*/*/*/*'`, the unquoted, problematic code may spend 30+ minutes trashing the disk as it unnecessarily tries to glob expand the value. \n\nThe correct code uses double quotes to avoid glob expansion, and therefore does not have this problem.\n\nWhen quoting, make sure to update any inner quotes:\n\n    : ${var:='foo'}    # Assigns foo without quotes\n    : \"${var:='foo'}\"  # Assigns 'foo' with quotes\n\n\n### Exceptions:\n\nNone, though this issue is largely theoretical.\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2223)"},{"id":"shellcheck_SC2224","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"This mv has no destination. Check the arguments.","description":"This mv has no destination. Check the arguments.","explanation":"## This mv has no destination. Check the arguments.\n\n### Problematic code:\n\n```sh\nmv \"$file $dir\"\n```\n\n### Correct code:\n\n```sh\nmv \"$file\" \"$dir\"\n```\n### Rationale:\n\nShellCheck found an `mv` command with a single parameter. This may be because the source and destination was accidentally merged into a single argument, or because the line was broken in an invalid way.\n\nFix the `mv` statement by correctly specifying both source and destination.\n\n### Exceptions:\n\nNone\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2224)"},{"id":"shellcheck_SC2225","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"This cp has no destination. Check the arguments.","description":"This cp has no destination. Check the arguments.","explanation":"## This cp has no destination. Check the arguments.\n\n### Problematic code:\n\n```sh\ncp \"$file $dir\"\n```\n\n### Correct code:\n\n```sh\ncp \"$file\" \"$dir\"\n```\n### Rationale:\n\nShellCheck found a `cp` command with a single parameter. This may be because the source and destination was accidentally merged into a single argument, or because the line was broken in an invalid way.\n\nFix the `cp` statement by correctly specifying both source and destination.\n\n### Exceptions:\n\nNone\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2225)"},{"id":"shellcheck_SC2226","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"This ln has no destination. Check the arguments, or specify '.' explicitly.","description":"This ln has no destination. Check the arguments, or specify '.' explicitly.","explanation":"## This ln has no destination. Check the arguments, or specify '.' explicitly.\n\n### Problematic code:\n\n```sh\nln \"$file $dir\"\n```\n\nor\n\n```sh\nln /foo/bar/baz\n```\n\n### Correct code:\n\n```sh\nln \"$file\" \"$dir\"\n```\n\nor\n\n```sh\nln /foo/bar/baz .\n```\n### Rationale:\n\nShellCheck found a `ln` command with a single parameter. This may be because the source and destination was accidentally merged into a single argument, because the line was broken in an invalid way, or because you're using a non-standard invocation of `ln` that defaults to linking the argument into the current directory.\n\nIf you wanted to specify both source and destination, fix the `ln` statement.\n\nIf you wanted to link a file into the current directory, prefer using the more explicit and POSIX standard invocation `ln /your/file .` \n\n### Exceptions:\n\nNone.\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2226)"},{"id":"shellcheck_SC2227","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"Redirection applies to the find command itself. Rewrite to work per action (or move to end).","description":"Redirection applies to the find command itself. Rewrite to work per action (or move to end).","explanation":"## Redirection applies to the find command itself. Rewrite to work per action (or move to end).\n\n### Problematic code:\n\n```sh\nfind . -name '*.ppm' -exec pnmtopng {} > {}.png \\;\n```\n\n### Correct code:\n\n```sh\nfind . -name '*.ppm' -exec sh -c 'pnmtopng \"$1\" > \"$1.png\"' _ {} \\;\n```\n### Rationale:\n\nShellCheck detected a `find` command with a redirection in the middle.\n\nThis redirection may have been intended to apply only to a specific action like `-exec` or `-print`, but it does in fact apply to the entire `find` command:\n\n    # This command\n    find . -name '*.ppm' -exec pnmtopng {} > {}.png \\;\n\n    # Is the same as this\n    {\n       find . -name '*.ppm' -exec pnmtopng {} \\;\n    } > {}.png \n\nTo perform a redirection per action, rewrite it with e.g. `-exec sh -c '...' _ {} \\;` \n\n\n### Exceptions:\n\nIf the redirection is something like `> /dev/null` where you don't mind it applying to the whole `find` and not individual results, you can move the redirection to the end of command to make it clear to ShellCheck (and humans) that it's not meant per command:\n\n    find . -exec foo {} > /dev/null \\;     # Ambiguous syntax. Is it per -exec or not?\n    find . -exec foo {} \\;  > /dev/null    # Identical command with clear intent.\n\nThere is no difference in behavior between the two.\n\n### Related resources:\n\n* Help by adding links to BashFAQ, StackOverflow, man pages, POSIX, etc!\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2227)"},{"id":"shellcheck_SC2229","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"This does not read 'foo'. Remove $/${} for that, or use ${var?} to quiet.","description":"This does not read 'foo'. Remove $/${} for that, or use ${var?} to quiet.","explanation":"## This does not read 'foo'. Remove $/${} for that, or use ${var?} to quiet.\n\n### Problematic code:\n\n```sh\nread $foo\n```\n\n### Correct code:\n\n```sh\nread foo\n```\n\n### Rationale:\n\n`read` takes a variable name, but shellcheck has noticed that you give it an expanded variable instead. This will populate whatever the variable expans to instead of the variable itself. For example:\n\n    foo=bar\n    read $foo   # Reads data into 'bar', not into 'foo'\n    read foo    # Reads data into 'foo'\n\n### Exceptions:\n\nIf this is intentional and you do want to read a variable through an indirect reference, you can silence this warning with a directive:\n\n```sh\n# shellcheck disable=SC2229\nread \"$foo\"\n```\n\nOr take advantage of the fact that ShellCheck only warns when no parameter expansion modifiers are applied:\n\n```sh\nread \"${foo}\"    # ShellCheck warns\nread \"${foo?}\"   # No warning\n```\n\n`${foo?}` fails when `foo` is unset, which is fine since `read` would have failed too. The main side effect is an improved runtime error message in that case.\n\n### Related resources:\n\n* [Bash Pitfalls #12](https://mywiki.wooledge.org/BashPitfalls#pf12): `read $foo`\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2229)"},{"id":"shellcheck_SC2230","category":"CodeStyle","level":"Info","severityLevel":"Info","enabled":false,"parameters":[],"title":"which is non-standard. Use builtin 'command -v' instead.","description":"which is non-standard. Use builtin 'command -v' instead.","explanation":"## which is non-standard. Use builtin 'command -v' instead.\n\nNote: This check is opt-in only in ShellCheck 0.7.1+ (`shellcheck -o deprecate-which`).\n\n### Problematic code:\n\n```sh\nwhich grep\n```\n\n### Correct code:\n\n```sh\n# For the path of a single, unaliased, external command,\n# or to check whether this will just \"run\" in this shell:\ncommand -v grep\n# To check whether commands exist, without obtaining a reusable path:\nhash grep\n```\n\n### Rationale:\n\n`which` is a non-standard, external tool that locates an executable in PATH. `command -v` is a POSIX standard builtin, which uses the same lookup mechanism that the shell itself would.\n\n### Exceptions:\n\nThis check is opt-in only in 0.7.1+, and you may choose to [[ignore]] it in earlier versions. `which` is very common, and some prefer its executable-or-nothing behavior over `command -v`'s handling of builtins, functions and aliases.\n\n### Caveats:\n\n#### `command -v` does not check ALL parameters\n\n`command -v` succeeds (with exit code 0) if *any* command exists:\n\n```\n# grep is in /usr/bin/grep\n# foobar is not in path\n#\n$ command -v -- grep foobar; echo $?\n0\n```\n\nIn the above example, it should have failed and exited with 1 unless *all* commands\nexist, if it were to be a replacement for `which`. Other problems associated with\n`command` include its inclusion of builtins, aliases, and functions.\n\nAn alternative is:\n\n```\n$ hash <file1> <file2>\n```\n\nWhich observes the standard behaviour of failures.\n\nTo obtain a path, `type -p` can be used instead. Like `command -v`, it has a similarly\nquirky behavior with builtins, aliases, and functions, although this is\narguably milder since it would print nothing for these cases. The failure condition is\nsimilar to `hash`.\n\n### Related resources:\n\n* `shellcheck` issue: [#1162 command -v is not a direct replacement for which](https://github.com/koalaman/shellcheck/issues/1162) (Discussion)\n* [Check if a program exists from a Bash script](https://stackoverflow.com/a/677212/1899640) on StackOverflow.\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2230)"},{"id":"shellcheck_SC2231","category":"CodeStyle","level":"Info","severityLevel":"Info","enabled":false,"parameters":[],"title":"Quote expansions in this for loop glob to prevent wordsplitting, e.g. \"$dir\"/*.txt .","description":"Quote expansions in this for loop glob to prevent wordsplitting, e.g. \"$dir\"/*.txt .","explanation":"## Quote expansions in this for loop glob to prevent wordsplitting, e.g. \"$dir\"/*.txt .\n\n### Problematic code:\n\n```sh\nfor file in $dir/*.txt\ndo\n  echo \"Found $file\"\ndone\n```\n\n### Correct code:\n\n```sh\nfor file in \"$dir\"/*.txt\ndo\n  echo \"Found $file\"\ndone\n```\n\n### Rationale:\n\nWhen iterating over globs containing expansions, you can still quote all expansions in the path to better handle whitespace and special characters.\n\nJust make sure glob characters are outside quotes. `\"$dir/*.txt\"` will not glob expand, but `\"$dir\"/*.txt` or `\"$dir\"/*.\"$ext\"` will. \n\n### Exceptions:\n\nExceptions similar to [[SC2086]] apply. If the variable is expected to contain globs, such as if `dir=\"tmp/**\"` in the example, you can ignore this message.\n\n### Related resources:\n\n* Help by adding links to BashFAQ, StackOverflow, man pages, POSIX, etc!\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2231)"},{"id":"shellcheck_SC2232","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"Can't use sudo with builtins like cd. Did you want sudo sh -c .. instead?","description":"Can't use sudo with builtins like cd. Did you want sudo sh -c .. instead?","explanation":"## Can't use sudo with builtins like cd. Did you want sudo sh -c .. instead?\n\n### Problematic code:\n\n```sh\nsudo cd /root\npwd\n```\n\n### Correct code:\n\n```sh\nsudo sh -c 'cd /root && pwd'\n```\n### Rationale:\n\nDue to the Unix process model, `sudo` can only change the privileges of a new, external process. It can not grant privileges to a currently running process.\n\nThis means that shell builtins -- commands that are interpreted by the current shell rather than through program invocation -- cannot be run with `sudo`. This includes `cd`, `source`, `read`, and others.\n\nInstead you can run a shell with `sudo`, and have that shell run the builtins you want. Just be aware that what happens in that shell stays in that shell:\n\n    sudo sh -c 'cd /root && pwd'  # This shows /root\n    pwd                           # This shows the original directory\n\n### Exceptions:\n\nNone.\n\n### Related resources:\n\n* [SuperUser](https://superuser.com/questions/241129/why-wont-sudo-cd-work): Why won't “sudo cd” work?\n* Help by adding links to BashFAQ, StackOverflow, man pages, POSIX, etc!\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2232)"},{"id":"shellcheck_SC2233","category":"CodeStyle","level":"Info","severityLevel":"Info","enabled":false,"parameters":[],"title":"Remove superfluous `(..)` around condition to avoid subshell overhead.","description":"Remove superfluous `(..)` around condition to avoid subshell overhead.","explanation":"## Remove superfluous `(..)` around condition to avoid subshell overhead.\n\n### Problematic code:\n\n```sh\nif ([ \"$x\" -gt 0 ])\nthen true; fi\n```\n\n### Correct code:\n\n```sh\nif [ \"$x\" -gt 0 ]\nthen true; fi\n```\n\n### Rationale:\n\nThe shell syntax is `if cmd`, `elif cmd`, `while cmd` and `until cmd` without any parentheses. Instead, parentheses are an independent construct used to create subshells.\n\nShellCheck has noticed that you're wrapping `(..)` around one or more test commands. This is unnecessary, and the resulting fork adds quite a lot of overhead:\n\n```\n$ i=0; time while ( [ \"$i\" -lt 10000 ] ); do i=$((i+1)); done\nreal    0m6.998s\nuser    0m3.453s\nsys     0m3.464s\n\n$ i=0; time while [ \"$i\" -lt 10000 ]; do i=$((i+1)); done\nreal    0m0.055s\nuser    0m0.054s\nsys     0m0.001s\n```\n\nJust delete the surrounding `(..)` since they serve no purpose and only slows the script down.\n\n### Exceptions:\n\nThis issue only affects performance, not correctness, so it can be safely [[ignore]]d.\n\nIf you are considering doing it to stylistically match C-like languages, please note that this is not conventional and that you'd probably recommend someone use `if (1 == 2)` over `if (system(\"[ 1 = 2 ]\"))` in C no matter which language they're used to.\n\n### Related resources:\n\n* Help by adding links to BashFAQ, StackOverflow, man pages, POSIX, etc!\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2233)"},{"id":"shellcheck_SC2234","category":"CodeStyle","level":"Info","severityLevel":"Info","enabled":false,"parameters":[],"title":"Remove superfluous `(..)` around test command to avoid subshell overhead.","description":"Remove superfluous `(..)` around test command to avoid subshell overhead.","explanation":"## Remove superfluous `(..)` around test command to avoid subshell overhead.\n\n### Problematic code:\n\n```sh\n([ \"$x\" -gt 0 ]) && foo\n```\n\n### Correct code:\n\n```sh\n[ \"$x\" -gt 0 ] && foo\n```\n\n### Rationale:\n\nYou are wrapping a single test command in `(..)`, creating an unnecessary subshell. This serves no purpose, but is significantly slower:\n\n```\n$ i=0; time while ( [ \"$i\" -lt 10000 ] ); do i=$((i+1)); done\nreal    0m6.998s\nuser    0m3.453s\nsys     0m3.464s\n\n$ i=0; time while [ \"$i\" -lt 10000 ]; do i=$((i+1)); done\nreal    0m0.055s\nuser    0m0.054s\nsys     0m0.001s\n```\n\nJust delete the surrounding `(..)` since they serve no purpose and only slows the script down.\n\n### Exceptions:\n\nThis issue only affects performance, not correctness, and can be [[ignore]]d for stylistic reasons.\n\n### Related resources:\n\n* Help by adding links to BashFAQ, StackOverflow, man pages, POSIX, etc!\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2234)"},{"id":"shellcheck_SC2235","category":"CodeStyle","level":"Info","severityLevel":"Info","enabled":false,"parameters":[],"title":"Use `{ ..; }` instead of `(..)` to avoid subshell overhead.","description":"Use `{ ..; }` instead of `(..)` to avoid subshell overhead.","explanation":"## Use `{ ..; }` instead of `(..)` to avoid subshell overhead.\n\n### Problematic code:\n\n```sh\n([ \"$x\" ] || [ \"$y\" ]) && [ \"$z\" ]\n```\n\n### Correct code:\n\n```sh\n{ [ \"$x\" ] || [ \"$y\" ]; } && [ \"$z\" ]\n```\n\n### Rationale:\n\nYou appear to be using `(..)` to group test commands. This creates a subshell, making it unnecessarily slow. Avoid this by using `{ ..; }` to group.\n\nBe careful to note that unlike `(..)`, this requires both a space after the `{` and a semicolon before the `}`.\n\nFor example, `(cmd)`, `(cmd;)` and `( cmd )` are all valid, but `{cmd}`, `{cmd;}` and `{ cmd }` are all syntax errors because they lack either or both of the spaces and semicolon. The correct form is `{ cmd; }`\n\nHere's a small benchmark showing that the subshell version is more than 100x slower:\n\n```\n$ i=0; time for i in {1..10000}; do ([ \"$x\" ] || [ \"$y\" ]) && [ \"$z\" ]; done\nreal    0m7.122s\nuser    0m4.204s\nsys     0m2.825s\n\n$ i=0; time for i in {1..10000}; do { [ \"$x\" ] || [ \"$y\" ]; } && [ \"$z\" ]; done\nreal    0m0.055s\nuser    0m0.055s\nsys     0m0.000s\n```\n\n\n\n### Exceptions:\n\nNone.\n\n### Related resources:\n\n* Help by adding links to BashFAQ, StackOverflow, man pages, POSIX, etc!\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2235)"},{"id":"shellcheck_SC2236","category":"CodeStyle","level":"Info","severityLevel":"Info","enabled":false,"parameters":[],"title":"Use `-n` instead of `! -z`.","description":"Use `-n` instead of `! -z`.","explanation":"## Use `-n` instead of `! -z`.\n\n(or \"Use `-z` instead of `! -n`\")\n\n### Problematic code:\n\n```sh\nif [ ! -n \"$JAVA_HOME\" ]; then echo \"JAVA_HOME not specified\"; fi\nif [ ! -z \"$STY\" ];       then echo \"You are already running screen\"; fi\n```\n\n### Correct code:\n\n```sh\nif [ -z \"$JAVA_HOME\" ]; then echo \"JAVA_HOME not specified\"; fi\nif [ -n \"$STY\" ];       then echo \"You are already running screen\"; fi\n```\n\n### Rationale:\n\nYou have negated `test -z` or `test -n`, resulting in a needless double-negative. You can just use the other operator instead:\n\n    # Identical tests to verify that a value is assigned\n    [ ! -z foo ] # Not has no value\n    [ -n foo ]   # Has value\n\n    # Identical tests to verify that a value is empty\n    [ ! -n foo ] # Not is non-empty\n    [ -z foo ]   # Is empty\n\n### Exceptions:\n\nThis is a stylistic issue that does not affect correctness. If you prefer the original expression, you can [[Ignore]] it with a directive or flag.\n\n### Related resources:\n\n* Help by adding links to BashFAQ, StackOverflow, man pages, POSIX, etc!\n* [Bash reference manual for -z and -n](https://www.gnu.org/software/bash/manual/html_node/Bash-Conditional-Expressions.html#Bash-Conditional-Expressions).\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2236)"},{"id":"shellcheck_SC2237","category":"CodeStyle","level":"Info","severityLevel":"Info","enabled":false,"parameters":[],"title":"Use `[ -n .. ]` instead of `! [ -z .. ]`.","description":"Use `[ -n .. ]` instead of `! [ -z .. ]`.","explanation":"## Use `[ -n .. ]` instead of `! [ -z .. ]`.\n\n(or \"Use `[ -z .. ]` instead of `! [ -n .. ]`.)\n\n### Problematic code:\n\n```sh\nif ! [ -n \"$JAVA_HOME\" ]; then echo \"JAVA_HOME not specified\"; fi\nif ! [ -z \"$STY\" ];       then echo \"You are already running screen\"; fi\n```\n\n### Correct code:\n\n```sh\nif [ -z \"$JAVA_HOME\" ]; then echo \"JAVA_HOME not specified\"; fi\nif [ -n \"$STY\" ];       then echo \"You are already running screen\"; fi\n```\n\n### Rationale:\n\nYou have negated `test -z` or `test -n`, resulting in a needless double-negative. You can just use the other operator instead:\n\n    # Identical tests to verify that a value is assigned\n    ! [ -z foo ] # Not has no value\n    [ -n foo ]   # Has value\n\n    # Identical tests to verify that a value is empty\n    ! [ -n foo ] # Not is non-empty\n    [ -z foo ]   # Is empty\n\n### Exceptions:\n\nThis is a stylistic issue that does not affect correctness. If you prefer the original expression, you can't not [[Ignore]] it with a directive or flag.\n\n### Related resources:\n\n* [Google Bash Style Guide][google-bash] on Testing Strings\n* Help by adding links to BashFAQ, StackOverflow, man pages, POSIX, etc!\n\n[google-bash]: https://google.github.io/styleguide/shell.xml?showone=Testing_Strings#Testing_Strings\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2237)"},{"id":"shellcheck_SC2238","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"Redirecting to/from command name instead of file. Did you want pipes/xargs (or quote to ignore)?","description":"Redirecting to/from command name instead of file. Did you want pipes/xargs (or quote to ignore)?","explanation":"## Redirecting to/from command name instead of file. Did you want pipes/xargs (or quote to ignore)?\n\n### Problematic code:\n\n```sh\ncat file > tr -d '\\r'\ncat file > rm\n```\n\n### Correct code:\n\n```sh\ncat file | tr -d '\\r'         # tr reads stdin\ncat file | xargs -d '\\n' rm   # rm reads arguments\n```\n\n### Rationale:\n\nYou are using file redirection, but the filename is an unquoted command name. Instead of running the command and feeding data to it, this just writes to a file with the same name. \n\nTo run the command and feed data to it, determine how it gets its data:\n\n* If the command reads from STDIN, simply use a pipe as in the first example.\n* If the command reads multiple arguments, use a pipe to `xargs` as in the second example\n\nNote that `xargs` has many pitfalls when it comes to spaces and quotes. `cat file | xargs rm`  will appear to work during testing, but fails for filenames like `My File.txt` or `Can't_Fight_This_Feeling.mp3`. The example uses the GNU extension `-d '\\n'` to more safely handle these names. \n\n### Exceptions:\n\nIf you actually did want to write a file named after a command, simply quote the filename to let ShellCheck know you meant it literally and not as a command name. This does not change anything about how the script works:\n\n```sh\n# Write to a file literally named 'rm', does not try to delete anything\necho \"A potentially dangerous command\" > \"rm\" \n```\n\n### Related resources:\n\n* Help by adding links to BashFAQ, StackOverflow, man pages, POSIX, etc!\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2238)"},{"id":"shellcheck_SC2239","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"Ensure the shebang uses the absolute path to the interpreter.","description":"Ensure the shebang uses the absolute path to the interpreter.","explanation":"## Ensure the shebang uses the absolute path to the interpreter.\n\n### Problematic code:\n\n```sh\n#!bin/sh\necho \"Hello World\"\n```\n\n### Correct code:\n\n```sh\n#!/bin/sh\necho \"Hello World\"\n```\n\n### Rationale:\n\nThe script's interpreter, as specified in the shebang, does not start with a `/`.\n\nThe interpreter should always be specified by absolute path to ensure that the script can be executed from any directory. When it's not, it's generally a typo like in the problematic example.\n\nIf you don't know where the interpreter is and you hoped to use `#! bash`, this is not an option. Use `/usr/bin/env` instead:\n\n```sh\n#!/usr/bin/env bash\necho \"Hello World\"\n``` \n\nWhile not required by POSIX, `env` can essentially always be found in `/usr/bin` and will search the PATH for the specified executable.\n\n### Exceptions:\n\nNone.\n\n### Related resources:\n\n* Help by adding links to BashFAQ, StackOverflow, man pages, POSIX, etc!\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2239)"},{"id":"shellcheck_SC2240","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"The dot command does not support arguments in sh/dash. Set them as variables.","description":"The dot command does not support arguments in sh/dash. Set them as variables.","explanation":"## The dot command does not support arguments in sh/dash. Set them as variables.\n\n### Problematic code:\n\n```sh\n#!/bin/sh\n. include/myscript example.com 80\n```\n\n### Correct code:\n\n```sh\n#!/bin/sh\nhost=example.com port=80 . include/myscript \n```\n### Rationale:\n\nIn Bash and Ksh, you can use `. myscript arg1 arg2..` to set `$1` and `$2` in the sourced script.\n\nThis is not the case in Dash, where any additional arguments are ignored, or in POSIX sh where the behavior is unspecified.\n\nInstead, assign arguments to variables and rewrite the sourced script to read from them.\n\n### Exceptions:\n\nNone.\n\n### Related resources:\n\n* Help by adding links to BashFAQ, StackOverflow, man pages, POSIX, etc!\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2240)"},{"id":"shellcheck_SC2241","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"The exit status can only be one integer 0-255. Use stdout for other data.","description":"The exit status can only be one integer 0-255. Use stdout for other data.","explanation":"## The exit status can only be one integer 0-255. Use stdout for other data.\n\n### Problematic code:\n\n```sh\nexit foo bar\n```\n\n### Correct code:\n\n```sh\necho foo\necho bar\nexit\n```\n\n### Rationale:\n\nIn bash, `exit` can only be used to signal success or failure (0 = success, 1-255 = failure).\n\nTo exit with textual or multiple values from a function, write them to stdout and capture them with command substitution instead.\n\nSee [[SC2242]] for more information.\n\n### Exceptions:\n\nNone\n\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2241)"},{"id":"shellcheck_SC2242","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"Can only exit with status 0-255. Other data should be written to stdout/stderr.","description":"Can only exit with status 0-255. Other data should be written to stdout/stderr.","explanation":"## Can only exit with status 0-255. Other data should be written to stdout/stderr.\n\n### Problematic code:\n\n```sh\nexit \"Bad filename\"\n```\n\n### Correct code:\n\n```sh\necho \"Bad filename\" >&2\nexit 1\n```\n\n### Rationale:\n\n`exit` can only be used to signal success or failure (0 = success, 1-255 = failure). It can not be used to return string data, and it can not be used to print error messages.\n\nString data should be written stdout, before an `exit 0` to exit with success.\n\nErrors should instead be written to stderr, with an `exit 1` (or higher) to exit with failure:\n\n```\nif [ ! -f \"$1\" ]\nthen\n   echo \"$1 is not a regular file\" >&2\n   exit 1\nfi\n```\n\nNote in particular that `exit -1` is equivalent to `exit 255`, but that `exit 1` is the more canonical way of expressing the first possible error code.\n\n### Exceptions:\n\nNone\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2242)"},{"id":"shellcheck_SC2243","category":"CodeStyle","level":"Info","severityLevel":"Info","enabled":false,"parameters":[],"title":"Prefer explicit -n to check for output (or run command without [/[[ to check for success)","description":"Prefer explicit -n to check for output (or run command without [/[[ to check for success)","explanation":"## Prefer explicit -n to check for output (or run command without [/[[ to check for success)\n\n### Problematic code:\n\n```sh\nif [ \"$(mycommand --myflags)\" ]\nthen\n  echo \"True\"\nfi\n```\n\n### Correct code:\n\n```sh\n# Check that the command outputs something on stdout\nif [ -n \"$(mycommand --myflags)\" ]\nthen\n  echo \"The command had output on stdout\"\nfi\n\n# Check instead that the command succeeded (exit code = 0)\nif mycommand --myflags\nthen\n  echo \"The command reported success\"\nfi\n```\n\n(if the command instead outputs \"0\" or \"false\", see [[SC2244]] for integer and \"boolean\" comparisons)\n\n### Rationale:\n\n`[ \"$(mycommand)\" ]` is equivalent to `[ -n \"$(mycommand)\" ]` and checks whether the command's output on stdout was non-empty.\n\nUsers more familiar with other languages are often surprised to learn that it is nothing like e.g. `if (myfunction())`, since it does not care about what the command/function `return`s.\n\nUsing an explicit `-n` helps clarify that this is purely a string operation. And of course, if the intention was to check whether the command ran successfully, now would be a good time to fix it as in the alternate example.\n\n### Exceptions:\n\nIf you are familiar with the semantics of `[`, you can [[ignore]] this suggestion with no ill effects.\n\n### Related resources:\n\n* Help by adding links to BashFAQ, StackOverflow, man pages, POSIX, etc!\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2243)"},{"id":"shellcheck_SC2244","category":"CodeStyle","level":"Info","severityLevel":"Info","enabled":false,"parameters":[],"title":"Prefer explicit -n to check non-empty string (or use =/-ne to check boolean/integer).","description":"Prefer explicit -n to check non-empty string (or use =/-ne to check boolean/integer).","explanation":"## Prefer explicit -n to check non-empty string (or use =/-ne to check boolean/integer).\n\n### Problematic code:\n\n```sh\nif [ \"$1\" ]\nthen\n  echo \"True\"\nfi\n```\n\n### Correct code:\n\n```sh\n# Check if $1 is empty or non-empty\nif [ -n \"$1\" ]\nthen\n  echo \"True, $1 is a non-empty value\"\nfi\n\n# Check instead if $1 is true or false, as in Java\n[ \"$1\" = \"true\" ]\n\n# Check instead if $1 is non-zero or zero, as in C\n[ \"$1\" -ne 0 ]\n\n# Check instead if $1 is defined (even if just assigned the empty string) or undefined\n[ \"${1+x}\" = \"x\" ]\n\n```\n\n### Rationale:\n\n`[ \"$var\" ]` is equivalent to `[ -n \"$var\" ]` and checks that a string is non-empty.\n\nUsers more familiar with other languages are often surprised to learn that `[ \"$var\" ]` is true when:\n\n* `var=false`\n* `var=0`\n* `var=null`\n* `var=\" \"`\n\nAdding the explicit `-n` helps clarify that this is a string comparison, and not related to any concept of boolean values or \"truthiness\" as it is in most languages.\n\n### Exceptions:\n\nIf you are familiar with the semantics of `[`, you can [[ignore]] this stylistic suggestion with no ill effects.\n\n### Related resources:\n\n* Help by adding links to BashFAQ, StackOverflow, man pages, POSIX, etc!\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2244)"},{"id":"shellcheck_SC2245","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"-d only applies to the first expansion of this glob. Use a loop to check any/all.","description":"-d only applies to the first expansion of this glob. Use a loop to check any/all.","explanation":"## -d only applies to the first expansion of this glob. Use a loop to check any/all.\n\n### Problematic code:\n\n```sh\nif [ -f ksh* ]\nthen\n  echo \"The file exists\"\nfi\n```\n\n### Correct code:\n\n```sh\nfor f in ksh*\ndo\n  if [ -f \"$f\" ]\n  then\n    echo \"Found a matching file: $f\"\n  fi\ndone\n```\n### Rationale:\n\nKsh has the curious behavior of ignoring anything after an unrecognized flag to `test`/`[`, which means that file checking operators against globs will effectively apply the operator to the first expansion:\n\n```sh\n[ -f ksh* ]                              # This\n[ -f ksh93u ksh93u.tar ksh93u.tar.gz ]   # Becomes this\n[ -f ksh93u ]                            # And is interpreted like this\n```\n\nThis is an issue when you have multiple matches for a glob. Instead of checking some or all, it only checks the first result and ignores the rest. To ensure that all results are considered (either to check that *any* or *all* results match the operator), use a loop explicitly.\n\nIf you really only want to match the first result of the glob expansion as sorted alphabetically in the current locale, you can make this intention explicit:\n\n    matches=( ksh* )\n    if [ -f \"${matches[0]}\" ]\n    then\n      echo \"The first result is a file\"\n    fi\n\n### Exceptions:\n\nIf you only care that entries exists, use `-e`. ShellCheck does not warn in this case, since all files resulting from glob expansion necessarily exist.\n\n### Related resources:\n\n* Help by adding links to BashFAQ, StackOverflow, man pages, POSIX, etc!\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2245)"},{"id":"shellcheck_SC2246","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"This shebang specifies a directory. Ensure the interpreter is a file.","description":"This shebang specifies a directory. Ensure the interpreter is a file.","explanation":"## This shebang specifies a directory. Ensure the interpreter is a file.\n\n### Problematic code:\n\n```sh\n#!/bin/sh/\necho \"Hello World\"\n```\n\n### Correct code:\n\n```sh\n#!/bin/sh\necho \"Hello World\"\n```\n### Rationale:\n\nThe shebang specifies which file to use as an interpreter, but probably due to some kind of typo, your script's interpreter ends in a `/`, indicating a directory.\n\nEnsure it points to a valid executable filename.\n\n### Exceptions:\n\nNone\n\n### Related resources:\n\n* Help by adding links to BashFAQ, StackOverflow, man pages, POSIX, etc!\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2246)"},{"id":"shellcheck_SC2247","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"Flip leading $ and \" if this should be a quoted substitution.","description":"Flip leading $ and \" if this should be a quoted substitution.","explanation":"## Flip leading $ and \" if this should be a quoted substitution.\n\n### Problematic code:\n\n```sh\nvar=$\"(whoami)\"\n```\n\n### Correct code:\n\n```sh\nvar=\"$(whoami)\"\n```\n\n### Rationale:\n\nShellCheck has found a `$\"(` or `$\"{` . This is most likely due to flipping the dollar-sign and double quote:\n\n    echo $\"(cmd)\"  # Supposed to be \"$(cmd)\"\n    echo $\"{var}\"  # Supposed to be \"${var}\"\n\nInstead of quoted substitutions, these will be interpreted as localized string resources (`$\"..\"`) containing literal parentheses or curly braces. If this was not intentional, you should flip the `\"` and `$` like in the example.\n\n### Exceptions:\n\nIf you intentionally wanted a localized string literal `$\"..\"` that starts with `(` or `{`, either [[ignore]] this error or start it with a different character.\n\n### Related resources:\n\n* Help by adding links to BashFAQ, StackOverflow, man pages, POSIX, etc!\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2247)"},{"id":"shellcheck_SC2248","category":"CodeStyle","level":"Info","severityLevel":"Info","enabled":false,"parameters":[],"title":"Warn about variable references without braces.","description":"Warn about variable references without braces.","explanation":"# Warn about variable references without braces.\n\nThis error is optional and not enabled by default. \n\n## Problematic code:\n\n```shell\nsubdir='example'\n\ncd ${subdir}\n```\n\n## Correct code:\n\n```shell\nsubdir='example'\n\ncd \"${subdir}\"\n```\n\n## Rationale:\n\nShellcheck normally warns about unquoted variable use due to potential globbing or word splitting issues. See [[SC2086]] for details. However if it is determined that a variable does not have have spaces or special characters it will omit that warning. This optional warning exists to suggest that quotes be used even in this scenario. If the code is later changed such that special characters can appear in the variable, having its use already quoted will prevent issues.\n\nThis optional warning is also helpful if shellcheck's analysis of the variable contents is wrong because of indirect modification of the variable or because unknown commands implemented as shell functions have modified the variable. \n[Source](https://github.com/koalaman/shellcheck/wiki/SC2248)"},{"id":"shellcheck_SC2249","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"Consider adding a default *) case, even if it just exits with error.","description":"Consider adding a default *) case, even if it just exits with error.","explanation":"## Consider adding a default *) case, even if it just exits with error.\n\n### Problematic code:\n\n```sh\ncase \"$1\" in\n  start) start_service ;;\n  stop)  stop_service ;;\n  restart|reload|force-reload)\n    stop_service;\n    start_service;;\nesac\n```\n\n### Correct code:\n\n```sh\ncase \"$1\" in\n  start) start_service ;;\n  stop)  stop_service ;;\n  restart|reload|force-reload)\n    stop_service;\n    start_service;;\n  *)\n    echo >&2 \"Invalid choice: $1\"\n    exit 1\nesac\n```\n\n### Rationale:\n\nShellCheck found a `case` statement that may not be considering all possible cases. This may mean that only the [happy paths](https://en.wikipedia.org/wiki/Happy_path) are accounted for.\n\nConsider adding a default case to handle other values. If you don't know what to do or don't believe it'll ever happen, exiting with an error is good, fail-fast practice.\n\nThe example is adapted from a real world Debian init script, which due to a missing default case reports success on any misspelled command (here with underscore instead of dash):\n\n```\n$ /etc/init.d/screen-cleanup force_reload && echo success\nsuccess\n```\n\n### Exceptions:\n\nThis suggestion only triggers in verbose mode (`-S verbose`). \n\nIf you don't have a default case because the default should be to take no action, consider adding a comment to other humans:\n\n```\ncase \"$(uname)\" in\n  CYGWIN*) cygwin=1;;\n  MINGW*) mingw=1;;\n  *) ;; # No special workarounds identified\nesac\n```\n\nIf you believe that it's impossible for the expression to have any other value, it's considered good practice to add the equivalent of an `assert(0)` to fail fast if this assumption should turn out to be incorrect in the current or future versions:\n\n```\ncase \"$result\" in\n  true)  proceed;;\n  false) cancel;;\n  *) echo >&2 \"Submit bug report: '$result' should be true or false.\"\n     exit 127\nesac\n```\n\n### Related resources:\n\n* Help by adding links to BashFAQ, StackOverflow, man pages, POSIX, etc!\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2249)"},{"id":"shellcheck_SC2250","category":"CodeStyle","level":"Info","severityLevel":"Info","enabled":false,"parameters":[],"title":"Prefer putting braces around variable references even when not strictly required.","description":"Prefer putting braces around variable references even when not strictly required.","explanation":"# Prefer putting braces around variable references even when not strictly required.\n\nThis error is optional and not enabled by default.\n\n## Problematic code:\n\n```shell\npartial_path='example'\n\ncurl \"http://example.com/$partial_path_version/explain.html\"\n```\n\n## Correct code:\n\n```shell\npartial_path='example'\n\ncurl \"http://example.com/${partial_path}_version/explain.html\"\n```\n\n## Rationale:\n\nIf a variable gets called, and there is a string that gets appended to the variable that could get misinterpreted as possibly part of the name of the variable. Then it will not call the right variable.\n\n## Related resources:\n- [StackOverflow: How do we separate variables from letters in shell scripting](https://stackoverflow.com/questions/18320133/how-do-we-separate-variables-from-letters-in-shell-scripting)\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2250)"},{"id":"shellcheck_SC2251","category":"CodeStyle","level":"Info","severityLevel":"Info","enabled":false,"parameters":[],"title":"This ! is not on a condition and skips errexit. Use `&& exit 1` instead, or make sure $? is checked.","description":"This ! is not on a condition and skips errexit. Use `&& exit 1` instead, or make sure $? is checked.","explanation":"## This ! is not on a condition and skips errexit. Use `&& exit 1` instead, or make sure $? is checked.\n\n### Problematic code:\n\n```sh\nset -e\n! false\n```\n\n### Correct code:\n\n```sh\nset -e\nfalse && exit 1\n```\n\n### Rationale:\n\nShellCheck has found a command inverted with `!` that may have no effect. In particular, it does not appear as a condition in an `if` statement or `while` loop, or as the final command in a script or function.\n\nThe most common reason for this is thinking that it'll trigger `set -e` aka `errexit` if a command succeeds, as in the example. This is not the case: `!` will inhibit errexit both on success and failure of the inverted command.\n\nUsing `&& exit ` will instead exit when failure when the command succeeds.\n\n### Exceptions:\n\nShellCheck will not detect cases where `$?` is implicitly or explicitly used to check the value afterwards:\n\n```\nset -e;\ncheck_success() { [ $? -eq 0 ] || exit 1; }\n! false; check_success\n! true; check_success\n```\n\nIn this case, you can [[ignore]] the warning.\n\n### Related resources:\n\n* StackOverflow: [Why do I need parenthesis In bash `set -e` and negated return code](https://stackoverflow.com/questions/39581150/why-do-i-need-parenthesis-in-bash-set-e-and-negated-return-code/39582012)\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2251)"},{"id":"shellcheck_SC2252","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"You probably wanted && here, otherwise it's always true.","description":"You probably wanted && here, otherwise it's always true.","explanation":"## You probably wanted && here, otherwise it's always true.\n\n### Problematic code:\n\n```sh\nif [ \"$1\" != foo ] || [ \"$1\" != bar ]\nthen\n  echo \"$1 is not foo or bar\"\nfi\n```\n\n### Correct code:\n\n```sh\nif [ \"$1\" != foo ] && [ \"$1\" != bar ]\nthen\n  echo \"$1 is not foo or bar\"\nfi\n```\n\n### Rationale:\n\nThis is not a bash issue, but a simple, common logical mistake applicable to all languages. \n\n`[ \"$1\" != foo ] || [ \"$1\" != bar ]` is always true (when `foo != bar`):\n\n* If `$1 = foo` then `$1 != bar` is true, so the statement is true.\n* If `$1 = bar` then `$1 != foo` is true, so the statement is true.\n* If `$1 = cow` then `$1 != foo` is true, so the statement is true.\n\n`[ $1 != foo ] && [ $1 != bar ]` matches when `$1` is neither `foo` nor `bar`:\n\n* If `$1 = foo`, then `$1 != foo` is false, so the statement is false.\n* If `$1 = bar`, then `$1 != bar` is false, so the statement is false.\n* If `$1 = cow`, then both `$1 != foo` and `$1  != bar` is true, so the statement is true.\n\nThis statement is identical to `! [ \"$1\" = foo ] || [ \"$1\" = bar ]`, which also works correctly (by [De Morgan's law](https://en.wikipedia.org/wiki/De_Morgan%27s_laws))\n\nThis warning is equivalent to [[SC2055]] and [[SC2056]], which trigger for intra-`test` expressions and arithmetic contexts respectively.\n\n### Exceptions\n\nRare.\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2252)"},{"id":"shellcheck_SC2253","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"Use -R to recurse, or explicitly a-r to remove read permissions.","description":"Use -R to recurse, or explicitly a-r to remove read permissions.","explanation":"## Use -R to recurse, or explicitly a-r to remove read permissions.\n\n### Problematic code:\n\n```sh\nchmod -r 0700 dir\nchmod -r file\n```\n\n### Correct code:\n\n```sh\nchmod -R 0700 dir\nchmod a-r file\n```\n\n### Rationale:\n\nMany tools use `-r` for recursive operation, but in `chmod` this removes read permissions.\n\nIf you wanted to change permissions recursively, change the flag to `-R`. If you wanted to remove read permissions, consider using `a-r` explicitly to make this more obvious.\n\n### Exceptions:\n\nIf you're using it correctly and don't mind the potential for confusion, you can save a single character by ignoring this warning.\n\n### Related resources:\n\n* Help by adding links to BashFAQ, StackOverflow, man pages, POSIX, etc!\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2253)"},{"id":"shellcheck_SC2254","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"Quote expansions in case patterns to match literally rather than as a glob.","description":"Quote expansions in case patterns to match literally rather than as a glob.","explanation":"## Quote expansions in case patterns to match literally rather than as a glob.\n\n### Problematic code:\n\n```sh\ncase $input in\n  -       ) echo \"Reading from stdin...\" ;;\n  $output ) echo \"Input should be different from output\" ;;\nesac\n```\n\n### Correct code:\n\n```sh\ncase $input in\n  -         ) echo \"Reading from stdin...\" ;;\n  \"$output\" ) echo \"Input should be different from output\" ;;\nesac\n```\n### Rationale:\n\nWhen unquoted variables and command expansions are used in case branch patterns, they will be interpreted as globs. \n\nThis can lead to some surprising behavior, such as `case $x in $x) trigger;; esac` not triggering in some cases, such as when `x='Pride and Prejudice [1813].epub'`.\n\nTo match the literal content of the variable or expansion, make sure to double quote the expansion.\n\n### Exceptions:\n\nIf you intended to match a dynamically generated pattern, you can ignore this suggestion with a directive.\n\n### Related resources:\n\n* [[SC2053]], where the same effect can be seen with `[[ $x = $x ]]`.\n* Help by adding links to BashFAQ, StackOverflow, man pages, POSIX, etc!\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2254)"},{"id":"shellcheck_SC2255","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"`[ ]` does not apply arithmetic evaluation. Evaluate with `$((..))` for numbers, or use string comparator for strings.","description":"`[ ]` does not apply arithmetic evaluation. Evaluate with `$((..))` for numbers, or use string comparator for strings.","explanation":"##  `[ ]` does not apply arithmetic evaluation. Evaluate with `$((..))` for numbers, or use string comparator for strings.\n\n### Problematic code:\n\n```sh\n[ 2*3 -eq array[i] ]\n```\n\n### Correct code:\n\n```sh\n[ $((2*3)) -eq $((array[i])) ]\n```\n\n### Rationale:\n\nWhen using `[[ .. ]]` with numerical comparators (`-eq`, `-lt`, etc), the value on either side will be evaluated as an arithmetic expression. This means that `2*3` will be evaluated to `6`, and `x` will be evaluated to the contents of the variable `$x`.\n\nWhen using `[ .. ]`, this does not happen. `2*3` and `x` will both be considered invalid numbers. Instead, use e.g. `$((2*3))` to evaluate the expression before passing it to `[ .. ]`.\n\nAlternatively, if the expression should be considered a string, quote the expression and use a string comparison operator like `=` and `!=`. \n\n### Exceptions:\n\nNone\n\n### Related resources:\n\n* Help by adding links to BashFAQ, StackOverflow, man pages, POSIX, etc!\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2255)"},{"id":"shellcheck_SC2256","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"This translated string is the name of a variable. Flip leading $ and \" if this should be a quoted substitution.","description":"This translated string is the name of a variable. Flip leading $ and \" if this should be a quoted substitution.","explanation":"## This translated string is the name of a variable. Flip leading $ and \" if this should be a quoted substitution.\n\n### Problematic code:\n\n```sh\nvar=\"foo\"\necho $\"var\"\n```\n\n### Correct code:\n\n```sh\nvar=\"foo\"\necho \"$var\"\n```\n\n### Rationale:\n\n`$\"..\"` is a localized string, for example, `echo $\"Hello $USER\"` along with the proper translation files can be used to have the script say \"Bonjour, youruser\" in French locales.\n\nIn this case, ShellCheck found a localized string whose contents is also the name of a variable. This could have happened because the user wanted a far more common quoted substitution, e.g. `\"$var\"`, but accidentally switched the leading `$` and `\"`.\n\n### Exceptions:\n\nIf you do want a localized string whose contents is also an active variable, you can [[ignore]] this warning or rename the variable.\n\n### Related resources:\n\n* Help by adding links to BashFAQ, StackOverflow, man pages, POSIX, etc!\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2256)"},{"id":"shellcheck_SC2257","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"Arithmetic modifications in command redirections may be discarded. Do them separately.","description":"Arithmetic modifications in command redirections may be discarded. Do them separately.","explanation":"## Arithmetic modifications in command redirections may be discarded. Do them separately.\n\n### Problematic code:\n\n```sh\ncurl \"$URL\" > \"image$((i++)).jpg\"\n```\n\n### Correct code:\n\n```sh\ni=$((i+1))\ncurl \"$URL\" > \"image$i.jpg\"\n```\n### Rationale:\n\nYou are using an arithmetic expression that modifies a variable, e.g. `$((x+=1))` or `$((x++))`, in the name of a file to redirect from/to, in a here document, or in a here string.\n\nThe scope of these modifications depends on whether the command itself will fork:\n\n```sh\necho foo > $((var++)).txt  # Updates in BusyBox and Bash\ncat  foo > $((var++)).txt  # Updates in Busybox, not in Bash\ngcc  foo > $((var++)).txt  # Does not update in either\n\ngcc() { /opt/usr/bin/gcc \"$@\"; }\ngcc  foo > $((var++)).txt  # Now suddenly updates in both\n```\n\nRather than rely on knowing which commands do and don't fork, or are and aren't overridden, simply do the updates in a separate command as in the correct code.\n\n### Exceptions:\n\nIf you know your variable is scoped the way you want it, you can ignore this warning.\n\n### Related resources:\n\n* Help by adding links to BashFAQ, StackOverflow, man pages, POSIX, etc!\n* https://stackoverflow.com/questions/62783161/arithmetic-expression-in-redirection/62964890#62964890\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2257)"},{"id":"shellcheck_SC2259","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"This redirection overrides piped input. To use both, merge or pass filenames.","description":"This redirection overrides piped input. To use both, merge or pass filenames.","explanation":"## This redirection overrides piped input. To use both, merge or pass filenames.\n\n### Problematic code:\n\n```sh\ngzcat yesterday.log.gz | grep \"$USER\" < today.log\n```\n\n### Correct code:\n\n```sh\n# Specify non-piped inputs as filenames\ngzcat yesterday.log.gz | grep \"$USER\" - today.log\n\n# Or merge multiple inputs into a single stream\n{ gzcat yesterday.log.gz; cat today.log; } | grep \"$USER\"\n```\n\n### Rationale:\n\nA process only has a single standard input stream. Pipes and input redirections both overwrite it, so you can't use both at the same time. If you try, the redirection takes precedence and the input pipe is closed.\n\nMany commands support specifying multiple filenames, where one can be stdin (canonically by specifying `-` as a filename, or alternatively by using `/dev/stdin`).  In these cases, you can rewrite the command to use one piped input, and as many extra files (or process substitutions) as you want.\n\nFor commands that only process a single input stream (like `tr`), you can also concatenate multiple commands or files into a single stream using a `{ command group; }` as in the example.\n\n### Exceptions:\n\nNone.\n\n### Related resources:\n\n* Help by adding links to BashFAQ, StackOverflow, man pages, POSIX, etc!\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2259)"},{"id":"shellcheck_SC2260","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"This redirection overrides the output pipe. Use 'tee' to output to both.","description":"This redirection overrides the output pipe. Use 'tee' to output to both.","explanation":"## This redirection overrides the output pipe. Use 'tee' to output to both.\n\n### Problematic code:\n\n```sh\nenv > environment.txt | grep '^ANDROID'\n```\n\n### Correct code:\n\n```sh\nenv | tee environment.txt | grep '^ANDROID'\n```\n\n### Rationale:\n\nA process only has a single standard output stream. Pipes and output redirections both overwrite it, so you can't use both at the same time. If you try, the redirection takes precedence and the output pipe is closed.\n\nIf you want to dump output to a file while also piping it, use `tee` as in the example.\n\n### Exceptions:\n\nNone.\n\n### Related resources:\n\n* Help by adding links to BashFAQ, StackOverflow, man pages, POSIX, etc!\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2260)"},{"id":"shellcheck_SC2261","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"Multiple redirections compete for stdout. Use cat, tee, or pass filenames instead.","description":"Multiple redirections compete for stdout. Use cat, tee, or pass filenames instead.","explanation":"## Multiple redirections compete for stdout. Use cat, tee, or pass filenames instead.\n\n(or `stdin`, or `stderr`, or `FD 3`)\n\n### Problematic code:\n\n```sh\ngrep foo < input1 < input2 > output1 > output2 > output3\n```\n\n### Correct code:\n\n```sh\n# Merge inputs into a single stream, write outputs individually\ncat input1 input2 | grep foo | tee output1 output2 > output3\n\n# Pass inputs as filenames, write outputs individually\ngrep foo input1 input2 | tee output1 output2 > output3\n```\n### Rationale:\n\nA file descriptor, whether stdin, stdout, stderr, or non-standard ones, can only point to a single file/pipe.\n\nFor input, many commands support processing multiple filenames. In these cases you can just specify the filenames instead of redirecting. Alternatively, you can use `cat` to merge multiple filenames into a single stream.\n\nFor output, you can use `tee` to write to multiple output sinks in parallel. \n\n### Exceptions:\n\nZsh will automatically `cat` inputs and `tee` outputs, but none of the shells supported by ShellCheck do.\n\n### Related resources:\n\n* Help by adding links to BashFAQ, StackOverflow, man pages, POSIX, etc!\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2261)"},{"id":"shellcheck_SC2262","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"This alias can't be defined and used in the same parsing unit. Use a function instead.","description":"This alias can't be defined and used in the same parsing unit. Use a function instead.","explanation":"## This alias can't be defined and used in the same parsing unit. Use a function instead.\n\n### Problematic code:\n\n```sh\nfunction checksum() {\n  type md5 && alias md5sum=md5\n  md5sum \"$@\"  # This calls `md5sum`, not `md5`\n}\n```\n\n### Correct code:\n\n```sh\nfunction checksum() {\n  type md5 && md5sum() { md5 \"$@\"; }\n  md5sum \"$@\"  # Now this would call `md5` when applicable\n}\n```\n### Rationale:\n\nAlias expansion happens at parse time, which means to have an effect, the `alias` command must be executed not just before the alias is invoked, but before the invocation is parsed. \n\nA shell will parse commands until it has a complete set of commands followed by a linefeed. This includes compound commands like `{ brace; groups; }` and `while loops; do true; done`. Here are some examples:\n\n    # A single command followed by a linefeed is one unit\n    unit 1\n\n    # These commands are in the same parsing unit because\n    # there is no line feed between them\n    unit 2; unit 2;\n\n    # These commands are in the same parsing unit because\n    # they are part of the same top level brace group\n    {\n      unit 3\n      unit 3\n    }\n\n    # These commands are in the same parsing unit because\n    # there is no linefeed between the groups.\n    {\n      unit 4\n    }; {\n      unit 4\n    }\n\nAny alias defined in a command in `unit 1` would not take effect until `unit 2` and beyond. Similarly, an alias defined in unit 2 will only take effect in unit 3 and 4.\n\nIn the problematic example, the alias is defined and used in a function. Since a function definition is a single compound command, it's considered a single parsing unit. The alias would therefore not have an effect (this is true even if the function is invoked twice, because it's only parsed once).\n\nDoes this sound confusing and counter-intuitive? It is. Save yourself the trouble and always use functions instead of aliases.\n\n### Exceptions:\n\nIf the flagged commands are not expected to use the alias, you can ignore this error. ShellCheck may incorrectly flag this if the alias definition and usage were in different branches of an `if` statement.\n\nYou can [[ignore]] this warning with a directive. All warnings may always be disabled either before the relevant command or before any outer compound commands, but in this case it's especially useful:\n\n    # shellcheck disable=SC2262    # Option A, before compound command\n    if true\n    then\n      # shellcheck disable=SC2262  # Option B, before alias command\n      alias foo=bar\n      # With either Option A or B, this SC2263 message is auto-suppressed\n      foo\n    fi\n\n### Related resources:\n\n* Unix&Linux SE: [bash aliases do not expand even with shopt expand_aliases](https://unix.stackexchange.com/questions/502257/bash-aliases-do-not-expand-even-with-shopt-expand-aliases)\n* Help by adding links to BashFAQ, StackOverflow, man pages, POSIX, etc!\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2262)"},{"id":"shellcheck_SC2263","category":"CodeStyle","level":"Info","severityLevel":"Info","enabled":false,"parameters":[],"title":"Since they're in the same parsing unit, this command will not refer to the previously mentioned alias.","description":"Since they're in the same parsing unit, this command will not refer to the previously mentioned alias.","explanation":"## Since they're in the same parsing unit, this command will not refer to the previously mentioned alias.\nSee companion warning [[SC2262]]\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2263)"},{"id":"shellcheck_SC2264","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"This function unconditionally re-invokes itself. Missing `command`?","description":"This function unconditionally re-invokes itself. Missing `command`?","explanation":"## This function unconditionally re-invokes itself. Missing `command`?\n\n### Problematic code:\n\n```sh\nls() {\n  ls --color=always \"$@\"\n}\n\ncd() {\n  cd \"$@\" && ls\n}\n```\n\n### Correct code:\n\nNote that `command` is the literal name of a shell builtin. You should not replace it:\n\n```sh\nls() {\n  command ls --color=always \"$@\"\n}\n\ncd() {\n  command cd \"$@\" && ls\n}\n```\n\n### Rationale:\n\nShellCheck found a function that immediately and unconditionally re-invokes itself, causing infinite recursion.\n\nThis generally happens when writing a wrapper function with the same name as an existing command, but forgetting to make sure it invokes the existing command and not itself. This is what happened in both of the problematic examples.\n\nTo invoke a command when a function by the same name is defined, i.e. to suppress function lookup during execution, use the command confusingly named `command`. For example, to run the system's `ls` instead of the shell function `ls`, use `command ls`.\n\n### Exceptions:\n\nShellCheck does not intend to warn about infinite recursion or fork bombs in general. This warning is purely meant for unintentional bugs in well meaning wrapper functions.\n\nIf ShellCheck is triggering on an intentionally malicious fork bomb, either [[ignore]] the issue, or simply add a leading command or condition:\n\n    :() { true && :|: & }\n\n### Related resources:\n\n* Help by adding links to BashFAQ, StackOverflow, man pages, POSIX, etc!\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2264)"},{"id":"shellcheck_SC2267","category":"CodeStyle","level":"Info","severityLevel":"Info","enabled":false,"parameters":[],"title":"GNU xargs -i is deprecated in favor of -I{}","description":"GNU xargs -i is deprecated in favor of -I{}","explanation":"## GNU xargs -i is deprecated in favor of -I{}\n\n### Problematic code:\n\n```sh\n# Implicit replacement string\nxargs -i ls {}\n\n# Explicit replacement string\nxargs -imyfilename ls myfilename\n```\n\n### Correct code:\n\n```sh\nxargs -I {} ls {}\n\nxargs -I filename ls filename\n```\n### Rationale:\n\n`xargs -i` is a GNU specific option. It has been deprecated in favor of the POSIX standard option `-I`.\n\nNote that `-i` will implicitly use `{}` as a token if nothing is specified, while `-I` requires it to be explicit.\n\n### Exceptions:\n\nNone.\n\n### Related resources:\n\n* Help by adding links to BashFAQ, StackOverflow, man pages, POSIX, etc!\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2267)"},{"id":"shellcheck_SC2268","category":"CodeStyle","level":"Info","severityLevel":"Info","enabled":false,"parameters":[],"title":"Avoid x-prefix in comparisons as it no longer serves a purpose.","description":"Avoid x-prefix in comparisons as it no longer serves a purpose.","explanation":"## Avoid x-prefix in comparisons as it no longer serves a purpose.\n\n### Problematic code:\n\n```sh\n[ \"x$pass\" = \"xswordfish\" ]\n\ntest x\"$var\" = x \n```\n\n### Correct code:\n\n```sh\n[ \"$pass\" = \"swordfish\" ] \n\ntest \"$var\" = \"\"\n```\n\n### Rationale:\n\nSome older shells would get confused if the first argument started with a dash, or consisted of `!` or `(`. As a workaround, people would prefix variables and values to be compared with `x` to ensure the left-hand side always started with an alphanumeric character.\n\nPOSIX ensures [this is not necessary](https://pubs.opengroup.org/onlinepubs/9699919799/utilities/test.html), and all modern shells now follow suite.\n\n### Examples:\n\nBash 1.14 from 1992 incorrectly fails this test. This was fixed for Bash 2.0 in 1996:\n\n```sh\nvar='!'\n[ \"$var\" = \"!\" ]\n```\n\nDash 0.5.4 from 2007 incorrectly passes this test. This was fixed for Dash 0.5.5 in 2008: \n\n```sh\nx='(' y=')'\n[ \"$x\" = \"$y\" ]\n```\n\nZsh (while not supported by ShellCheck) fixed the same problem in 2015.\n\n### Exceptions:\n\nIf you are targeting especially old shells, you can ignore this warning (or use a different letter).\n\n### Related resources:\n\n* [What exactly was the point of `[ \"x$var\" = \"xval\" ]`](https://www.vidarholen.net/contents/blog/?p=1035)?\n* [Wooledge Bash Pitfall #4](https://mywiki.wooledge.org/BashPitfalls#A.5B_.24foo_.3D_.22bar.22_.5D)\n* [Problems With the test Builtin: What Does -a Mean?](http://www.oilshell.org/blog/2017/08/31.html)\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2268)"},{"id":"shellcheck_SC2269","category":"CodeStyle","level":"Info","severityLevel":"Info","enabled":false,"parameters":[],"title":"This variable is assigned to itself, so the assignment does nothing.","description":"This variable is assigned to itself, so the assignment does nothing.","explanation":"## This variable is assigned to itself, so the assignment does nothing.\n\n### Problematic code:\n\n```sh\nvar=\"$var\"\n```\n\n### Correct code:\n\n```sh\n# If the goal is to do nothing\ntrue\n```\n\n### Rationale:\n\nShellCheck found a variable that is assigned to itself, e.g. `x=$x`. This obviously has no effect.\n\nDouble check what the assignment was supposed to do. \n\n### Exceptions:\n\nNone.\n\n### Related resources:\n\n* Help by adding links to BashFAQ, StackOverflow, man pages, POSIX, etc!\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2269)"},{"id":"shellcheck_SC2270","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"To assign positional parameters, use 'set -- first second ..' (or use [ ] to compare).","description":"To assign positional parameters, use 'set -- first second ..' (or use [ ] to compare).","explanation":"## To assign positional parameters, use 'set -- first second ..' (or use [ ] to compare).\n\n### Problematic code:\n\n```sh\nif [ -z \"$1\" ]\nthen\n  $1=\"help\"\nfi\n```\n\nor\n\n```sh\nif $1=\"help\"\nthen\n  echo \"Usage: $0 filename\"\nfi\n```\n\n### Correct code:\n\n```sh\nif [ -z \"$1\" ]\nthen\n  set -- \"help\"\nfi\n```\n\nor\n\n```sh\nif [ $1 = \"help\" ]\nthen\n  echo \"Usage: $0 filename\"\nfi\n```\n### Rationale:\n\nYou have a command on the form `$2=value`.\n\nIf the goal is to assign a new value to the positional parameters, use the `set` builtin: `set -- one two ..` will cause `$1` to be \"one\" and `$2` to be \"two\".\n\nIf you instead want to compare the value, use `[ ]` and add spaces: `[ \"$1\" = \"foo\" ]`  \n\n### Exceptions:\n\nNone\n\n### Related resources:\n\n* Help by adding links to BashFAQ, StackOverflow, man pages, POSIX, etc!\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2270)"},{"id":"shellcheck_SC2271","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"For indirection, use arrays, `declare \"var$n=value\"`, or (for sh) read/eval","description":"For indirection, use arrays, `declare \"var$n=value\"`, or (for sh) read/eval","explanation":"## For indirection, use arrays, `declare \"var$n=value\"`, or (for sh) read/eval\n\n### Problematic code:\n\n```sh\nn=1\nvar$n=\"hello\"\n```\n\n### Correct code:\n\nFor integer indexing in ksh/bash, consider using an indexed array:\n\n```sh\nn=1\nvar[n]=\"hello\"\necho \"${var[n]}\"\n```\n\nFor string indexing in ksh/bash, use an associative array:\n\n```sh\ntypeset -A var\nn=\"greeting\"\nvar[$n]=\"hello\"\necho \"${var[$n]}\"\n```\n\nIf you actually need a variable with the constructed name in bash, use `declare`:\n\n```sh\nn=\"Foo\"\ndeclare \"var$n=42\"\necho \"$varFoo\"\n```\n\nFor `sh`, with single line contents, consider `read`:\n```sh\nn=\"Foo\"\nread -r \"var$n\" << EOF\nhello\nEOF\necho \"$varFoo\"\n```\n\nor with careful escaping, `eval`:\n\n```sh\nn=Foo\neval \"var$n='hello'\"\necho \"$varFoo\"\n```\n\n### Rationale:\n\n`var$n=value` is not a valid way of assigning to a dynamically created variable name in any shell. Please use one of the other methods to assign to names via expanded strings. [Wooledge BashFaq #6](https://mywiki.wooledge.org/BashFAQ/006) has significantly more information on the subject.\n\n\n### Exceptions:\n\nNone\n\n### Related resources:\n\n* [Wooledge BashFaq #6](https://mywiki.wooledge.org/BashFAQ/006): How can I use variable variables (indirect variables, pointers, references) or associative arrays?\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2271)"},{"id":"shellcheck_SC2272","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"Command name contains ==. For comparison, use [ \"$var\" = value ].","description":"Command name contains ==. For comparison, use [ \"$var\" = value ].","explanation":"## Command name contains ==. For comparison, use [ \"$var\" = value ].\n\n### Problematic code:\n\n```sh\n$a/$b==foo/bar\n```\n\n### Correct code:\n\n```sh\n[ \"$a/$b\" = \"foo/bar\" ] \n```\n### Rationale:\n\nShellCheck found a command name that contains a `==`. Most likely, this was intended as a kind of comparison.\n\nTo compare two values, use `[ value1 = value2 ]`. Both the brackets and the spaces around the `=` are relevant. \n\n### Exceptions:\n\nNone, though you can quote the `==` to suppress the warning.\n\n### Related resources:\n\n* Help by adding links to BashFAQ, StackOverflow, man pages, POSIX, etc!\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2272)"},{"id":"shellcheck_SC2273","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"Sequence of ===s found. Merge conflict or intended as a commented border?","description":"Sequence of ===s found. Merge conflict or intended as a commented border?","explanation":"## Sequence of ===s found. Merge conflict or intended as a commented border?\n\n### Problematic code:\n\n```sh\n=======\n```\n\n### Correct code:\n\nEither resolve the merge conflict, or use `# =======` for a border\n\n### Rationale:\n\nShellCheck found a series of `=======`s. If this was supposed to be a border or separator, use a comment.\n\n\nHowever, it could also be left behind from a source control merge conflict:\n\n```sh\n<<<<<<< HEAD\necho \"Goodbye World\"\n=======\necho \"Hello World!\"\n>>>>>>> mybranch\n```\n\nIn this case, make sure the merge conflict is correctly resolved, and all the markers removed.\n\n### Exceptions:\n\nNone\n\n### Related resources:\n\n* Help by adding links to BashFAQ, StackOverflow, man pages, POSIX, etc!\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2273)"},{"id":"shellcheck_SC2274","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"Command name starts with ===. Intended as a commented border?","description":"Command name starts with ===. Intended as a commented border?","explanation":"##  Command name starts with ===. Intended as a commented border?\n\n### Problematic code:\n\n```sh\n===================== MAIN SECTION =======================\n```\n\n### Correct code:\n\n```sh\n# ===================== MAIN SECTION =======================\n```\n### Rationale:\n\nShellCheck found a command that starts with a series of `===`s. This may have been intended as a border, but is missing the `#` to turn it into a harmless comment.\n\n### Exceptions:\n\nNone\n\n### Related resources:\n\n* Help by adding links to BashFAQ, StackOverflow, man pages, POSIX, etc!\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2274)"},{"id":"shellcheck_SC2275","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"Command name starts with =. Bad line break?","description":"Command name starts with =. Bad line break?","explanation":"## Command name starts with =. Bad line break?\n\n### Problematic code:\n\n```sh\nmy_variable\n  =value\n```\n\n### Correct code:\n\n```sh\nmyvariable=value\n```\n\n### Rationale:\n\nShellCheck found a command name starting with a `=`. This was likely not meant as a new command, but instead a continuation from a previous line.\n\nMake sure the `=` is used correctly.\n\n### Exceptions:\n\nNone, though you can quote the value to make ShellCheck ignore it, e.g. `\"=foo\"`.\n\n### Related resources:\n\n* Help by adding links to BashFAQ, StackOverflow, man pages, POSIX, etc!\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2275)"},{"id":"shellcheck_SC2276","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"This is interpreted as a command name containing '='. Bad assignment or comparison?","description":"This is interpreted as a command name containing '='. Bad assignment or comparison?","explanation":"## This is interpreted as a command name containing '='. Bad assignment or comparison?\n\n### Problematic code:\n\n```sh\n\"$var\"=42\nif \"$var\"=42\nthen\n  true\nfi\n```\n\n### Correct code:\n\n```sh\nvar=42\nif [ \"$var\" = 42 ]\nthen\n  true\nfi\n```\n\n### Rationale:\n\nShellCheck found a command name containing an unquoted equals sign `=`. This was likely intended as either a comparison or an assignment.\n\nTo compare two values, use e.g. `[ \"$var\" = \"42\" ]`\n\nTo assign a value, use e.g. `var=\"42\"`\n\n### Exceptions:\n\nNone, though you can quote the `=` to make ShellCheck ignore it: `\"$var=42\"`.\n\n### Related resources:\n\n* Help by adding links to BashFAQ, StackOverflow, man pages, POSIX, etc!\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2276)"},{"id":"shellcheck_SC2277","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"Use BASH_ARGV0 to assign to $0 in bash (or use [ ] to compare).","description":"Use BASH_ARGV0 to assign to $0 in bash (or use [ ] to compare).","explanation":"## Use BASH_ARGV0 to assign to $0 in bash (or use [ ] to compare).\n\n### Problematic code:\n\n```sh\n#!/bin/bash\n$0=myscriptname\n```\n\n### Correct code:\n\n```sh\n#!/bin/bash\nBASH_ARGV0=myscriptname\n```\n\n### Rationale:\n\nYou appear to be trying to assign a new value to `$0` in a Bash script. To do this, instead assign to the special variable `BASH_ARGV0`.\n\nIf you instead wanted to compare the value of `$0`, use a comparison like `[ \"$0\" = \"myname\" ]`.\n\n### Exceptions:\n\nNone.\n\n### Related resources:\n\n* Help by adding links to BashFAQ, StackOverflow, man pages, POSIX, etc!\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2277)"},{"id":"shellcheck_SC2278","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"$0 can't be assigned in Ksh (but it does reflect the current function).","description":"$0 can't be assigned in Ksh (but it does reflect the current function).","explanation":"## $0 can't be assigned in Ksh (but it does reflect the current function).\n\n### Problematic code:\n\n```sh\n#!/bin/ksh\n$0=myname\necho \"Usage: $0 --help\"\n```\n\n### Correct code:\n\n```sh\n#!/bin/ksh\nmyname() {\n  echo \"Usage: $0 --help\"\n}\nmyname\n```\n### Rationale:\n\nYou appear to be trying to assign a new value to `$0` in Ksh.\n\nThis is not possible. However, `$0` will reflect the current function name, so if you wrap your code in a function with your chosen name, you can have `$0` expand to it.\n\n### Exceptions:\n\nIf you instead wanted to compare the value of `$0`, use a comparison like `[ \"$0\" = \"myname\" ]`.\n\n### Related resources:\n\n* Help by adding links to BashFAQ, StackOverflow, man pages, POSIX, etc!\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2278)"},{"id":"shellcheck_SC2279","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"$0 can't be assigned in Dash. This becomes a command name.","description":"$0 can't be assigned in Dash. This becomes a command name.","explanation":"## $0 can't be assigned in Dash. This becomes a command name.\n\n### Problematic code:\n\n```sh\n#!/bin/dash\n$0=myname\n```\n\n### Correct code:\n\n`$0` can not be changed in Dash.\n\n### Rationale:\n\nYou appear to be trying to assign a new value to `$0` in Dash.\n\nDash does not support this. Write around it, or switch to Bash.\n\n### Exceptions:\n\nIf you instead wanted to compare the value of `$0`, use a comparison like `[ \"$0\" = \"myname\" ]`.\n\n### Related resources:\n\n* Help by adding links to BashFAQ, StackOverflow, man pages, POSIX, etc!\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2279)"},{"id":"shellcheck_SC2280","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"$0 can't be assigned this way, and there is no portable alternative.","description":"$0 can't be assigned this way, and there is no portable alternative.","explanation":"## $0 can't be assigned this way, and there is no portable alternative.\n\n### Problematic code:\n\n```sh\n#!/bin/sh\n$0=myname\n```\n\n### Correct code:\n\n`$0` can not be changed in a portable way.\n\n### Rationale:\n\nYou appear to be trying to assign a new value to `$0` in a `sh` script.\n\nThere is no portable way to do this. Write around it, or switch to Bash.\n\n### Exceptions:\n\nIf you instead wanted to compare the value of `$0`, use a comparison like `[ \"$0\" = \"myname\" ]`.\n\n### Related resources:\n\n* Help by adding links to BashFAQ, StackOverflow, man pages, POSIX, etc!\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2280)"},{"id":"shellcheck_SC2281","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"Don't use $/${} on the left side of assignments.","description":"Don't use $/${} on the left side of assignments.","explanation":"## Don't use $/${} on the left side of assignments.\n\n### Problematic code:\n\n```sh\n$greeting=\"Hello World\"\n${greeting}=\"Hello World\"\n```\n\n### Correct code:\n\n```sh\ngreeting=\"Hello World\"\n```\n\nAlternatively, if the goal was to assign to a variable whose name is in another variable (indirection), use `declare`:\n\n```sh\nname=foo\ndeclare \"$name=hello world\"\necho \"$foo\"\n```\n\nOr if you actually wanted to compare the value, use a test expression:\n\n```sh\nif [ \"$greeting\" = \"hello world\" ]\nthen\n  echo \"Programmer, I presume?\"\nfi\n```\n\n### Rationale:\n\nUnlike Perl or PHP, `$` is not used on the left-hand side of `=` when assigning to a variable.\n\n### Exceptions\n\nNone\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2281)"},{"id":"shellcheck_SC2282","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"Variable names can't start with numbers, so this is interpreted as a command.","description":"Variable names can't start with numbers, so this is interpreted as a command.","explanation":"## Variable names can't start with numbers, so this is interpreted as a command.\n\n### Problematic code:\n\n```sh\n411toppm=true\n```\n\n### Correct code:\n\n```sh\n_411toppm=true\n```\n\n### Rationale:\n\nYou appear to be assigning to a variable name that starts with a digit. This is not allowed: variables must start with A-Z, a-z or _.\n\nSwitch to a variable name that does not start with a digit.\n\n### Exceptions:\n\nNone\n\n### Related resources:\n\n* Help by adding links to BashFAQ, StackOverflow, man pages, POSIX, etc!\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2282)"},{"id":"shellcheck_SC2283","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"Use [ ] to compare values, or remove spaces around = to assign (or quote '=' if literal).","description":"Use [ ] to compare values, or remove spaces around = to assign (or quote '=' if literal).","explanation":"## Use [ ] to compare values, or remove spaces around = to assign (or quote '=' if literal).\n\n### Problematic code:\n\n```sh\n# Assignment\nvar = value\n\n# Comparison\nif $var = value\nthen\n  echo \"Match\"\nfi\n```\n\n### Correct code:\n\n```sh\n# Assignment\nvar=value\n\n# Comparison\nif [ \"$var\" = value ]\nthen\n  echo \"Match\"\nfi\n```\n\n### Rationale:\n\nShellCheck found an unquoted `=` after a word.\n\nIf this was supposed to be a comparison, use square brackets: `[ \"$var\" = value ]`\n\nIf this was supposed to be an assignment, remove spaces around `=`: `var=value`\n\n### Exceptions:\n\nIf the `=` was meant literally, quote it:\n\n    grep '=true' file.cfg\n\n### Related resources:\n\n* Help by adding links to BashFAQ, StackOverflow, man pages, POSIX, etc!\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2283)"},{"id":"shellcheck_SC2284","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"Use [ x = y ] to compare values (or quote '==' if literal).","description":"Use [ x = y ] to compare values (or quote '==' if literal).","explanation":"## Use [ x = y ] to compare values (or quote '==' if literal).\n\n### Problematic code:\n\n```sh\nif $var == value\nthen\n  echo \"Match\"\nfi\n```\n\n### Correct code:\n\n```sh\nif [ \"$var\" = value ]\nthen\n  echo \"Match\"\nfi\n```\n\n### Rationale:\n\nShellCheck found an unquoted `==` after a word.\n\nThis was most likely supposed to be a comparison, so use square brackets as in the correct code.\n\n### Exceptions:\n\nIf the `==` was supposed to be literal, you can quote it to make ShellCheck ignore it:\n\n    grep '===' file.js\n\n### Related resources:\n\n* Help by adding links to BashFAQ, StackOverflow, man pages, POSIX, etc!\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2284)"},{"id":"shellcheck_SC2285","category":"CodeStyle","level":"Error","severityLevel":"Error","enabled":false,"parameters":[],"title":"Remove spaces around += to assign (or quote '+=' if literal).","description":"Remove spaces around += to assign (or quote '+=' if literal).","explanation":"## Remove spaces around += to assign (or quote '+=' if literal).\n\n### Problematic code:\n\n```sh\nvar += \"my text\"\n```\n\n### Correct code:\n\n```sh\nvar+=\"my text\"\n```\n\n### Rationale:\n\nShellCheck found an unquoted `+=` after a word. To append text to a variable, remove spaces around `+=` as in the example.\n\n### Exceptions:\n\nIf the `+=` was supposed to be literal, you can quote it to make ShellCheck ignore it:\n\n    grep '+=' files..\n\n### Related resources:\n\n* Help by adding links to BashFAQ, StackOverflow, man pages, POSIX, etc!\n[Source](https://github.com/koalaman/shellcheck/wiki/SC2285)"},{"id":"shellcheck_SC3001","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"In POSIX sh, process substitution is undefined.","description":"In POSIX sh, process substitution is undefined.","explanation":"## In POSIX sh, process substitution is undefined.\n\n(or \"In dash, ... is not supported.\" when using `dash`)\n\n### Problematic code:\n\n```sh\n#!/bin/sh\nwhile IFS= read -r n\ndo\n  sum=$((sum+n))\ndone < <(program)\n```\n\n### Correct code:\n\nThe easiest fix is to switch to a shell that does support process substitution, by changing the shebang to `#!/bin/bash` or `ksh`.\n\n```sh\n#!/bin/bash\nwhile IFS= read -r n\ndo\n  sum=$((sum+n))\ndone < <(program)\n```\n\nAlternatively, process substitution can often be replaced with temporary files:\n\n```sh\n#!/bin/sh\ntmp=\"$(mktemp)\"\nprogram > \"$tmp\"\nwhile IFS= read -r n\ndo\n  sum=$((sum+n))\ndone < \"$tmp\"\nrm \"$tmp\"\n```\n\nIf streaming is important, the temporary file can be a named pipe, and the producer or consumer can be run as a background job.\n\nIf the reading command accepts input from standard input, the process substitution can be replaced with a regular pipe:\n\n```sh\n#!/bin/sh\nprogram | while IFS= read -r n\ndo\n  sum=$((sum+n))\ndone\n```\n\n### Rationale:\n\nProcess substitution is a ksh and bash extension. It does not work in sh or dash scripts.\n\n### Exceptions:\n\nIf you only intend to target shells that supports this feature, you can change\nthe shebang to a shell that guarantees support, or [[ignore]] this warning.\n\nYou can use `# shellcheck disable=SC3000-SC4000` to ignore all such compatibility\nwarnings.\n\n### Related resources:\n\n* Help by adding links to BashFAQ, StackOverflow, man pages, POSIX, etc!\n\n[Source](https://github.com/koalaman/shellcheck/wiki/SC3001)"},{"id":"shellcheck_SC3002","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"In POSIX sh, extglob is undefined.","description":"In POSIX sh, extglob is undefined.","explanation":"## In POSIX sh, extglob is undefined.\n\n(or \"In dash, ... is not supported.\" when using `dash`)\n\n### Problematic code:\n\n```sh\n#!/bin/sh\nrm !(*.hs)\n```\n\n### Correct code:\n\nEither switch the shebang to a shell that does support extglob, like `bash` or `ksh`, or rewrite in terms of a loop with a `case` or `grep` match:\n\n```sh\n#!/bin/sh\nfor file in *\ndo\n  case \"$file\" in\n    *.hs) true;;\n    *) rm \"$file\" ;;\n  esac\ndone\n```\n\n### Rationale:\n\nExtglobs are extensions in bash and ksh, while your shebang says you're using `sh` or `dash`. \n\n### Exceptions:\n\nIf you only intend to target shells that supports this feature, you can change\nthe shebang to a shell that guarantees support, or [[ignore]] this warning.\n\nYou can use `# shellcheck disable=SC3000-SC4000` to ignore all such compatibility\nwarnings.\n\n### Related resources:\n\n* Help by adding links to BashFAQ, StackOverflow, man pages, POSIX, etc!\n\n[Source](https://github.com/koalaman/shellcheck/wiki/SC3002)"},{"id":"shellcheck_SC3003","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"In POSIX sh, $'..' is undefined.","description":"In POSIX sh, $'..' is undefined.","explanation":"## In POSIX sh, $'..' is undefined.\n\n### Problematic code:\n\n```sh\n#!/bin/sh\nIFS=$' \\t\\n'\n```\n\n### Correct code:\n\n```sh\n#!/bin/sh\n# Note: \\n can not be last, or it will be stripped by $()\nIFS=$(printf ' \\n\\t')\n```\n\nor \n\n```sh\n#!/bin/sh\n# Trailing linefeed added literally\nIFS=\"$(printf ' \\t')\n\"\n```\n\nor\n\n```sh\n#!/bin/bash\n# Bash supports this\nIFS=$' \\t\\n'\n```\n\n### Rationale:\n\nYou are using the interpolated string Bashism `$'..'` in a script that declares itself as POSIX sh (e.g. via `#!/bin/sh`).\n\nTo ensure the script runs correctly on other systems, either switch to Bash, or rewrite it in a POSIX compatible way.\n\nThis can generally done via `printf` as in the example. Be careful about strings with trailing linefeeds, as a `$(command substitution)` will strip them.\n\n### Exceptions:\n\nNone.\n\n### Related resources:\n\n* StackOverflow: [Why does my bash code fail when I run it with sh?](https://stackoverflow.com/questions/15179446/why-does-my-bash-code-fail-when-i-run-it-with-sh)\n[Source](https://github.com/koalaman/shellcheck/wiki/SC3003)"},{"id":"shellcheck_SC3004","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"In POSIX sh, $\"..\" is undefined","description":"In POSIX sh, $\"..\" is undefined","explanation":"## In POSIX sh, $\"..\" is undefined\n\n### Problematic code:\n\n```sh\nprintf $\"Hello, %s\\n\" \"$USER\"\n```\n\n### Correct code:\n\n```sh\n# Check if gettext exists\nif ! type gettext > /dev/null 2>&1\nthen\n  # If not, create a dummy function that returns the input verbatim\n  gettext() { printf '%s' \"$1\"; }\nfi\n\n# Use gettext to get a translated version of the string\nprintf \"$(gettext 'Hello, %s\\n')\" \"$USER\"\n```\n\n### Rationale:\n\nBash allows using `$\"...\"` to easily get a translated string according to the current locale. This is powered by the gettext infrastructure.\n\nNeither `$\"..\"` nor the gettext infrastructure or the `gettext` command is POSIX. A script targeting `sh` may choose to invoke `gettext` if the system has it (such as GNU or Solaris), or use the translated string verbatim if it doesn't (such as macOS or FreeBSD).\n\n### Exceptions:\n\nNone.\n\n### Related resources:\n\n* Help by adding links to BashFAQ, StackOverflow, man pages, POSIX, etc!\n[Source](https://github.com/koalaman/shellcheck/wiki/SC3004)"},{"id":"shellcheck_SC3006","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"In POSIX sh, standalone ((..)) is undefined.","description":"In POSIX sh, standalone ((..)) is undefined.","explanation":"## In POSIX sh, standalone ((..)) is undefined.\n\n### Problematic code:\n\n```sh\nvariable=1\nif ((variable)); then\n  echo variable is not zero\nfi\n```\n\n### Correct code:\n\n[`bash` supports standalone `((..))`](https://www.gnu.org/software/bash/manual/html_node/Conditional-Constructs.html#index-select) natively.\n\nFor POSIX compliance, use\n\n```sh\nvariable=1\nif [ \"${variable}\" -ne 0 ]; then\n  echo variable is not zero\nfi\n```\n[Source](https://github.com/koalaman/shellcheck/wiki/SC3006)"},{"id":"shellcheck_SC3010","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"","description":"","explanation":"\n    In POSIX sh, [[ ]] is undefined.\n\nPOSIX sh uses `[ ]` instead. To see the limitations/differences, view http://mywiki.wooledge.org/BashFAQ/031 \n[Source](https://github.com/koalaman/shellcheck/wiki/SC3010)"},{"id":"shellcheck_SC3012","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"In POSIX sh, lexicographical `\\<` is undefined.","description":"In POSIX sh, lexicographical `\\<` is undefined.","explanation":"## In POSIX sh, lexicographical `\\<` is undefined.\n\n### Problematic code:\n\n```sh\n#!/bin/sh\nx=\"aardvark\"\ny=\"zebra\"\nif [ $x \\< $y ]\nthen\n  echo \"$x comes before $y in the dictionary\"\nfi\n```\n\n### Correct code:\n\nFirst, make sure you wanted a lexicographical comparison (aka dictionary order), and not a numerical comparison.\n\nThen to compare as string, you can use `expr` and make sure that the strings are not interpreted numerically by adding some non-numerical data to them. Here, an apostrophe is prepended:\n\n```\n#!/bin/sh\nx=\"aardvark\"\ny=\"zebra\"\nif expr \"'$x\" \\< \"'$y\"   > /dev/null \nthen\n  echo \"$x comes before $y in the dictionary\"\nfi\n```\n\n### Rationale:\n\nThe `test` binary operators `>`, `\\>`, `<`, and `\\<` are not part of POSIX and not guaranteed to be supported in scripts targeting `sh`.\n\nThe `expr` functionality is specified by POSIX.\n\n### Exceptions:\n\nIf you know your `sh` will be e.g. `dash`, consider explicitly using `#!/bin/dash`. \n\n### Related resources:\n\n* POSIX: [test](https://pubs.opengroup.org/onlinepubs/9699919799/utilities/test.html#tag_20_128), [expr](https://pubs.opengroup.org/onlinepubs/9699919799/utilities/expr.html)\n\n[Source](https://github.com/koalaman/shellcheck/wiki/SC3012)"},{"id":"shellcheck_SC3013","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"In POSIX sh, `-nt` is undefined.","description":"In POSIX sh, `-nt` is undefined.","explanation":"## In POSIX sh, `-nt` is undefined.\n\n### Problematic code:\n\n```sh\n#!/bin/sh\nif [ Foo.java -nt Foo.class ]\nthen\n  javac Foo.java\nfi\n```\n\n### Correct code:\n\nThe easiest fix is to switch to a shell that *does* support `-nt`, like bash:\n\n```sh\n#!/bin/bash\nif [ Foo.java -nt Foo.class ]\nthen\n  javac Foo.java\nfi\n```\n\nOtherwise, `find` can be used:\n\n```sh\n#!/bin/sh\nif [ -n \"$(find Foo.java -newer Foo.class)\" ]\nthen\n  javac Foo.java\nfi\n```\n\n### Rationale:\n\n`test -nt` is an extension in ksh, bash and dash, but it is not covered by POSIX.\n\n### Exceptions:\n\nIf you only intend to target shells that supports this feature, you can change\nthe shebang to a shell that guarantees support, or [[ignore]] this warning.\n\nYou can use `# shellcheck disable=SC3000-SC4000` to ignore all such compatibility\nwarnings.\n\n### Related resources:\n\n* Help by adding links to BashFAQ, StackOverflow, man pages, POSIX, etc!\n\n[Source](https://github.com/koalaman/shellcheck/wiki/SC3013)"},{"id":"shellcheck_SC3014","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"In POSIX sh, `==` in place of `=` is undefined.","description":"In POSIX sh, `==` in place of `=` is undefined.","explanation":"## In POSIX sh, `==` in place of `=` is undefined.\n\n(or \"In dash, ... is not supported.\" when using `dash`)\n\n### Problematic code:\n\n```sh\n#!/bin/sh\nif [ $1 == \"-n\" ]\nthen\n  dry_run=1\nfi\n```\n\n### Correct code:\n\n```sh\n#!/bin/sh\nif [ $1 = \"-n\" ]\nthen\n  dry_run=1\nfi\n```\n\n### Rationale:\n\n`==` is used for equality comparison in C-like languages, and is also supported by `bash` and `ksh` in `[ .. ]` and `test` expressions.\n\n`sh` and `dash` only supports `=` for equality comparison, so use that instead.\n\n### Exceptions:\n\nIf you only intend to target shells that supports this feature, you can change\nthe shebang to a shell that guarantees support, or [[ignore]] this warning.\n\nYou can use `# shellcheck disable=SC3000-SC4000` to ignore all such compatibility\nwarnings.\n\n### Related resources:\n\n* Help by adding links to BashFAQ, StackOverflow, man pages, POSIX, etc!\n\n[Source](https://github.com/koalaman/shellcheck/wiki/SC3014)"},{"id":"shellcheck_SC3015","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"In POSIX sh, =~ regex matching is undefined.","description":"In POSIX sh, =~ regex matching is undefined.","explanation":"## In POSIX sh, =~ regex matching is undefined.\n\n### Problematic code:\n\n```sh\n[ \"$var\" =~ .*foo[0-9]* ]\n```\n\n### Correct code:\n\n```sh\nexpr \"$var\" : \".*foo[0-9]*\" > /dev/null\n```\n\n### Rationale:\n\nYou are using `=~` in a script declared to be compatible with POSIX sh or Dash.\n\n`=~` is not a POSIX operator and is unlikely to outside `[[ ]]` in Bash and Ksh.\n\nUse `expr`'s `:` operator instead.\n\n### Exceptions:\n\nNone\n\n### Related resources:\n\n* Help by adding links to BashFAQ, StackOverflow, man pages, POSIX, etc!\n[Source](https://github.com/koalaman/shellcheck/wiki/SC3015)"},{"id":"shellcheck_SC3017","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"In POSIX sh, unary `-a` in place of `-e` is undefined.","description":"In POSIX sh, unary `-a` in place of `-e` is undefined.","explanation":"## In POSIX sh, unary `-a` in place of `-e` is undefined.\n\n(or \"In dash, ... is not supported.\" when using `dash`)\n\n### Problematic code:\n\n```sh\n#!/bin/sh\nif [ -a file.txt ]\nthen\n  echo \"file.txt exists\"\nfi\n```\n\n### Correct code:\n\n```sh\n#!/bin/sh\nif [ -e file.txt ]\nthen\n  echo \"file.txt exists\"\nfi\n```\n\n### Rationale:\n\n`-a` was used in some shells to check for the existence of a file, but the POSIX standard and better supported equivalent is `-e`.\n\n### Exceptions:\n\nIf you only intend to target shells that supports this feature, you can change\nthe shebang to a shell that guarantees support, or [[ignore]] this warning.\n\nYou can use `# shellcheck disable=SC3000-SC4000` to ignore all such compatibility\nwarnings.\n\n### Related resources:\n\n* Help by adding links to BashFAQ, StackOverflow, man pages, POSIX, etc!\n\n[Source](https://github.com/koalaman/shellcheck/wiki/SC3017)"},{"id":"shellcheck_SC3018","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"In POSIX sh, ++ is undefined.","description":"In POSIX sh, ++ is undefined.","explanation":"## In POSIX sh, ++ is undefined.\n\n(or \"In dash, ... is not supported.\" when using `dash`)\n\n### Problematic code:\n\n```sh\n#!/bin/sh\ni=1\necho \"$((i++))\"\n```\n\n### Correct code:\n\nWrite out the increment/decrement operation explicitly:\n\n```sh\n#!/bin/sh\ni=1\necho \"$i\"\ni=$((i+1))\n```\n\n### Rationale:\n\nPrefix and postfix increment and decrement are extensions in bash and ksh. They're not supported in dash or POSIX sh, which is what your shebang says you're using.\n \n### Exceptions:\n\nIf you only intend to target shells that supports this feature, you can change\nthe shebang to a shell that guarantees support, or [[ignore]] this warning.\n\nYou can use `# shellcheck disable=SC3000-SC4000` to ignore all such compatibility\nwarnings.\n\n### Related resources:\n\n* Help by adding links to BashFAQ, StackOverflow, man pages, POSIX, etc!\n\n[Source](https://github.com/koalaman/shellcheck/wiki/SC3018)"},{"id":"shellcheck_SC3019","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"In POSIX sh, exponentials are undefined.","description":"In POSIX sh, exponentials are undefined.","explanation":"## In POSIX sh, exponentials are undefined.\n\n### Problematic code:\n\nShellCheck noticed you're using `**`-notation with two asterisks to obtain an exponent's value. Some examples:\n\n```sh\n#!/bin/sh\necho $((2 ** 3)) # Using `**` for an exponent is undefined in POSIX sh.\n```\n\n### Correct code:\n\nOther possibilities exist:\n```sh\n#!/bin/sh\necho $((2 * 2 * 2))   # equivalent to `bash`'s `echo $((2 ** 3))`\necho '2 ^ 3' | bc     # piping the formula to `bc` to parse the output https://stackoverflow.com/a/13111995\nprintf '2 ^ 3\\n' | bc # piping using `printf` (newline `\\n` is mandatory)\n```\n\n* Help by adding links to BashFAQ, StackOverflow, man pages, POSIX!\n[Source](https://github.com/koalaman/shellcheck/wiki/SC3019)"},{"id":"shellcheck_SC3020","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"In POSIX sh, `&>` is undefined.","description":"In POSIX sh, `&>` is undefined.","explanation":"## In POSIX sh, `&>` is undefined.\n\n(or \"In dash, ... is not supported.\" when using `dash`)\n\n### Problematic code:\n\n```sh\n#!/bin/sh\nssh host cmd &> log\n```\n\n### Correct code:\n\nUse the long form instead of the shorthand:\n\n```sh\n#!/bin/sh\nssh host cmd > log 2>&1\n```\n\n### Rationale:\n\n`&>` is a bash and ksh extension for redirecting both stdout and stderr. In dash and POSIX sh, use `2>&1` explicitly.\n\n### Exceptions:\n\nIf you only intend to target shells that supports this feature, you can change\nthe shebang to a shell that guarantees support, or [[ignore]] this warning.\n\nYou can use `# shellcheck disable=SC3000-SC4000` to ignore all such compatibility\nwarnings.\n\n### Related resources:\n\n* Help by adding links to BashFAQ, StackOverflow, man pages, POSIX, etc!\n\n[Source](https://github.com/koalaman/shellcheck/wiki/SC3020)"},{"id":"shellcheck_SC3021","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"In POSIX sh, `>&` is undefined.","description":"In POSIX sh, `>&` is undefined.","explanation":"## In POSIX sh, `>&` is undefined.\nSee similar warning [[SC3020]]\n[Source](https://github.com/koalaman/shellcheck/wiki/SC3021)"},{"id":"shellcheck_SC3022","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"In POSIX sh, named file descriptors is undefined.","description":"In POSIX sh, named file descriptors is undefined.","explanation":"## In POSIX sh, named file descriptors is undefined.\n\n(or \"In dash, ... is not supported.\" when using `dash`)\n\n### Problematic code:\n\n```sh\nexec {n}> \"$output\"\necho \"Your fd is $n\"\n```\n\n### Correct code:\n\nThere is no simple, mechanical alternative for POSIX sh, but you can either switch to a shell that does support this (like `bash`), or hard code (or `eval`) a specific file descriptor.  \n\n### Rationale:\n\nThe syntax for opening an arbitrary file descriptor and assigning it to a variable for later use is a `bash` and `ksh` extension. It does not work on POSIX sh or `dash`.\n\n### Exceptions:\n\nNone\n\n### Related resources:\n\n* Help by adding links to BashFAQ, StackOverflow, man pages, POSIX, etc!\n\n[Source](https://github.com/koalaman/shellcheck/wiki/SC3022)"},{"id":"shellcheck_SC3023","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"In POSIX sh, FDs outside of 0-9 are undefined.","description":"In POSIX sh, FDs outside of 0-9 are undefined.","explanation":"## In POSIX sh, FDs outside of 0-9 are undefined.\n\n(or \"In dash, ... are not supported.\" when using `dash`)\n\n### Problematic code:\n\n```sh\n# Open FD #10 for writing\nexec 10> file\n```\n\n### Correct code:\n\nEither rewrite the script to only use FDs in the valid range, or switch to a shell that allows a larger range like `bash` or `ksh`.\n\n### Rationale:\n\nThe shell grammar is only required to recognize a single digit before redirections to set the file descriptor, which limits the portable range to 0-9.\n\n### Exceptions:\n\nNone.\n\n### Related resources:\n\n* Help by adding links to BashFAQ, StackOverflow, man pages, POSIX, etc!\n\n[Source](https://github.com/koalaman/shellcheck/wiki/SC3023)"},{"id":"shellcheck_SC3024","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"In POSIX sh, += is undefined.","description":"In POSIX sh, += is undefined.","explanation":"## In POSIX sh, += is undefined.\n\n(or \"In dash, ... is not supported.\" when using `dash`)\n\n### Problematic code:\n\n```sh\nvar=\"Hello \"\nvar+=\"World\"\n```\n\n### Correct code:\n\n```sh\nvar=\"Hello \"\nvar=\"${var}World\"\n```\n\n### Rationale:\n\nUsing `+=` to concatenate to an existing variable is a ksh/bash extension. For POSIX sh or dash, write out the full expression. Be careful to use braces if the text you append could be confused for a variable (as in the example, to avoid `$varWorld` being interpreted as `${varWorld}`)  \n\n### Exceptions:\n\nNone.\n\n### Related resources:\n\n* Help by adding links to BashFAQ, StackOverflow, man pages, POSIX, etc!\n\n[Source](https://github.com/koalaman/shellcheck/wiki/SC3024)"},{"id":"shellcheck_SC3025","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"In POSIX sh, /dev/{tcp,udp} is undefined.","description":"In POSIX sh, /dev/{tcp,udp} is undefined.","explanation":"## In POSIX sh, /dev/{tcp,udp} is undefined.\n\n(or \"In dash, ... is not supported.\" when using `dash`)\n\n### Problematic code:\n\n```sh\necho foo > /dev/tcp/myhost/1234\n```\n\n### Correct code:\n\nRewrite using a tool like netcat (`nc`):\n\n```sh\necho foo | nc myhost 1234\n```\n\n### Rationale:\n\n`/dev/tcp/$host/$port` and `/dev/udp/$host/$port` are recognized in redirections by bash and ksh, and a socket connection is made instead of opening a file. They do not physically exist in `/dev`.\n\nPOSIX sh and dash do not support this, so any such code should be rewritten to use a socket tool explicitly. The obvious candidate is netcat aka `nc`.  \n\n### Exceptions:\n\nNone\n\n### Related resources:\n\n* Help by adding links to BashFAQ, StackOverflow, man pages, POSIX, etc!\n\n[Source](https://github.com/koalaman/shellcheck/wiki/SC3025)"},{"id":"shellcheck_SC3026","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"In POSIX sh, ^ in place of ! in glob bracket expressions is undefined.","description":"In POSIX sh, ^ in place of ! in glob bracket expressions is undefined.","explanation":"## In POSIX sh, ^ in place of ! in glob bracket expressions is undefined.\n\n### Problematic code:\n\n```sh\necho foo-[^0]*.jpg\n```\n\n### Correct code:\n\n```sh\necho foo-[!0]*.jpg\n```\n\n### Rationale:\n\n`[^c]` is frequently used in most regular expression variants to mean \"any character except `c`\". Ksh and Bash adopted it for globs as well.\n\nHowever, strictly speaking, the only range complement syntax guaranteed to be supported across shells is `[!c]`. Dash only supports it when using `fnmatch` and `glob` from glibc.\n\n### Exceptions:\n\nIf you only intend to target shells that supports this feature, you can change\nthe shebang to a shell that guarantees support, or [[ignore]] this warning.\nOr just rewrite it to be on the technically correct side.\n\n### Related resources:\n\n* Help by adding links to BashFAQ, StackOverflow, man pages, POSIX, etc!\n\n[Source](https://github.com/koalaman/shellcheck/wiki/SC3026)"},{"id":"shellcheck_SC3028","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"In POSIX sh, VARIABLE is undefined.","description":"In POSIX sh, VARIABLE is undefined.","explanation":"## In POSIX sh, VARIABLE is undefined.\n\n(or \"In dash, ... is not supported.\" when using `dash`)\n\n### Problematic code:\n\n```sh\n#!/bin/sh\necho \"$HOSTNAME $UID $RANDOM\"\n```\n\n### Correct code:\n\nEither switch to a shell like `bash` that supports the special variable you're trying to use, or use an external command to get the information you want:\n\n```sh\n#!/bin/sh\necho \"$(hostname) $(id -u) $(awk 'BEGIN { srand(); print int(rand()*32768) }' /dev/null)\"\n```\n\n### Rationale:\n\nThe variable you are attempting to use is a special variable in bash or ksh. To get the same information from `dash` or POSIX `sh`, use an external command instead.\n\nFor `PIPESTATUS`, the pipeline can be instrumented to record the exit value of each command:\n\n```sh\n{ cmd0; echo $? > status0; } | { cmd1; echo $? > status1; } | cmd2\n```\n\n### Exceptions:\n\nIf you only intend to target shells that supports this feature, you can change\nthe shebang to a shell that guarantees support, or [[ignore]] this warning.\n\nYou can use `# shellcheck disable=SC3000-SC4000` to ignore all such compatibility\nwarnings.\n\n### Related resources:\n\n* Help by adding links to BashFAQ, StackOverflow, man pages, POSIX, etc!\n\n[Source](https://github.com/koalaman/shellcheck/wiki/SC3028)"},{"id":"shellcheck_SC3031","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"In POSIX sh, redirecting from/to globs is undefined.","description":"In POSIX sh, redirecting from/to globs is undefined.","explanation":"## In POSIX sh, redirecting from/to globs is undefined.\n\n(or \"In dash, ... is not supported.\" when using `dash`)\n\n### Problematic code:\n\n```sh\n#!/bin/sh\ndate > /tmp/log*.txt\n```\n\n### Correct code:\n\nTo redirect from/to the only match of a glob, expand the glob first:\n\n```sh\n#!/bin/sh\nset -- /tmp/log*.txt\n# PS: This is a good place to verify that there was exactly one match\ndate > \"$1\"\n```\n\nAlternatively, use a loop to redirect from/to all if that was the intention.\n\n### Rationale:\n\nShells differ in whether (and how) they do pathname expansion on names in redirections. Avoid the issue by expanding the glob yourself. \n\n### Exceptions:\n\nIf you only intend to target shells that supports this feature, you can change\nthe shebang to a shell that guarantees support, or [[ignore]] this warning.\n\nYou can use `# shellcheck disable=SC3000-SC4000` to ignore all such compatibility\nwarnings.\n\n### Related resources:\n\n* Help by adding links to BashFAQ, StackOverflow, man pages, POSIX, etc!\n\n[Source](https://github.com/koalaman/shellcheck/wiki/SC3031)"},{"id":"shellcheck_SC3034","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"In POSIX sh, $(<file) is undefined.","description":"In POSIX sh, $(<file) is undefined.","explanation":"## In POSIX sh, $(<file) is undefined.\n\n(or \"In dash, ... is not supported.\" when using `dash`)\n\n### Problematic code:\n\n```sh\ncontent=$(<file)\n```\n\n### Correct code:\n\n```sh\ncontent=$(cat file)\n```\n\n### Rationale:\n\nIn bash and ksh, `$(< file)` will expand to the full contents of the file.\n\nHowever, in dash and POSIX sh, it will instead expand to nothing. This is because it's not recognized as special, and simply results in the command output of `< file`, a no-op command that opens the file and exits without reading it.\n \n### Exceptions:\n\nNone.\n\n### Related resources:\n\n* Help by adding links to BashFAQ, StackOverflow, man pages, POSIX, etc!\n\n[Source](https://github.com/koalaman/shellcheck/wiki/SC3034)"},{"id":"shellcheck_SC3035","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"In POSIX sh, `` `<file` `` is undefined.","description":"In POSIX sh, `` `<file` `` is undefined.","explanation":"## In POSIX sh, `` `<file` `` is undefined.\nSee equivalent warning [[SC3034]]\n[Source](https://github.com/koalaman/shellcheck/wiki/SC3035)"},{"id":"shellcheck_SC3037","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"In POSIX sh, echo flags are undefined.","description":"In POSIX sh, echo flags are undefined.","explanation":"## In POSIX sh, echo flags are undefined.\n\n### Problematic code:\n\n```sh\n#!/bin/sh\necho -ne 'Foo:\\tBar'\n```\n\n### Correct code:\n\nRewrite in terms of the more robust and standardized `printf`:\n\n```sh\n#!/bin/sh\nprintf 'Foo:\\tBar'\n```\n\n### Rationale:\n\n`echo` has historically behaved differently on different systems. Use `printf` instead to ensure compatibility between shells.\n\n### Exceptions:\n\nIf you only intend to target systems that supports this feature, you can change\nthe shebang to a shell that guarantees support, or [[ignore]] this warning.\n\nYou can use `# shellcheck disable=SC3000-SC4000` to ignore all such compatibility\nwarnings.\n\n### Related resources:\n\n* Help by adding links to BashFAQ, StackOverflow, man pages, POSIX, etc!\n\n[Source](https://github.com/koalaman/shellcheck/wiki/SC3037)"},{"id":"shellcheck_SC3038","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"In POSIX sh, exec flags are undefined.","description":"In POSIX sh, exec flags are undefined.","explanation":"## In POSIX sh, exec flags are undefined.\n\n(or \"In dash, ... are not supported.\" when using `dash`)\n\n### Problematic code:\n\n```sh\n#!/bin/sh\nexec -ca ls busybox\n```\n\n### Correct code:\n\nSwitch to a shell that does support the `exec` flags you are using, like `bash`:\n\n```sh\n#!/bin/bash\nexec -ca ls busybox\n```\n\nIn POSIX, you can use `env` to start a command with a clean environment, but there is no way to generally specifying the zeroth argument.\n\n### Rationale:\n\nFlags to `exec` are bash and ksh extensions. `dash` and POSIX `sh` does not support them.\n\n### Exceptions:\n\nIf you only intend to target shells that supports this feature, you can change\nthe shebang to a shell that guarantees support, or [[ignore]] this warning.\n\nYou can use `# shellcheck disable=SC3000-SC4000` to ignore all such compatibility\nwarnings.\n\n### Related resources:\n\n* Help by adding links to BashFAQ, StackOverflow, man pages, POSIX, etc!\n\n[Source](https://github.com/koalaman/shellcheck/wiki/SC3038)"},{"id":"shellcheck_SC3039","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"In POSIX sh, 'let' is undefined.","description":"In POSIX sh, 'let' is undefined.","explanation":"## In POSIX sh, 'let' is undefined.\n\n(or \"In dash, ... is not supported.\" when using `dash`)\n\n### Problematic code:\n\n```sh\n#!/bin/sh\nlet x=2+2\n```\n\n### Correct code:\n\nUse standard `$((arithmetic expansion))` instead of legacy `let`:\n\n```sh\n#!/bin/sh\nx=$((2+2))\n```\n\n### Rationale:\n\n`let` is a command used for arithmetic in some shells, but it's not a standard command. Use `$((..))` instead.\n\n### Exceptions:\n\nIf you only intend to target shells that supports this feature, you can change\nthe shebang to a shell that guarantees support, or [[ignore]] this warning.\n\nYou can use `# shellcheck disable=SC3000-SC4000` to ignore all such compatibility\nwarnings.\n\n### Related resources:\n\n* Help by adding links to BashFAQ, StackOverflow, man pages, POSIX, etc!\n\n[Source](https://github.com/koalaman/shellcheck/wiki/SC3039)"},{"id":"shellcheck_SC3040","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"In POSIX sh, set option pipefail is undefined.","description":"In POSIX sh, set option pipefail is undefined.","explanation":"## In POSIX sh, set option pipefail is undefined.\n\n### Problematic code:\n\n```sh\n#!/bin/sh\nset -o pipefail\nif cmd1 | cmd2 | cmd3\nthen\n  echo \"Success\"\nfi\n```\n\n### Correct code:\n\n```sh\nfail=\"$(mktemp)\"\nif { cmd1 || echo > \"$fail\"; } |\n   { cmd2 || echo > \"$fail\"; } |\n     cmd3 && [ ! -s \"$fail\" ]\nthen\n  echo \"Success\"\nfi\nrm \"$fail\"\n```\n\nor switch to a shell that supports pipefail, such as Bash.\n\n### Rationale:\n\nShellCheck found `set -o pipefail` in a script declare to run with `sh` or `dash`. This feature may not be supported on these shells.\n\nAs an alternative, each stage in the pipeline such as `cmd1` can be rewritten as `{ cmd1 || echo > file; }` which will behave as before but now also write the exit code into `file` if the command fails.\n\nIf the file has been written to when the pipeline is done, it means one of the commands failed. This is demonstrated in the correct example.\n\nThis can obviously be extended with e.g. `echo \"cmd1=$?\" >> file` if the particular exit codes for particular commands are desired.\n\n### Exceptions:\n\nIf the script has already inspected the current shell and determined the option is available, you can [[ignore]] this message.\n\n### Related resources:\n\n* Help by adding links to BashFAQ, StackOverflow, man pages, POSIX, etc!\n[Source](https://github.com/koalaman/shellcheck/wiki/SC3040)"},{"id":"shellcheck_SC3043","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"In POSIX sh, `local` is undefined.","description":"In POSIX sh, `local` is undefined.","explanation":"## In POSIX sh, `local` is undefined.\n\n### Problematic code:\n\n```sh\nmyfunc() {\n  local i=0\n  ..\n}\n```\n\n### Correct code:\n\nIn POSIX sh, you can adopt some convention to avoid accidentally overwriting variables names, e.g. prefixing with the function name:\n\n```sh\nmyfunc() {\n  _myfunc_i=0\n  ..\n}\n```\n\n### Rationale:\n\n`local` is supported in many shells, including bash, ksh, dash, and BusyBox ash. However, strictly speaking, it's not POSIX.\n\n### Exceptions:\n\nSince quite a lot of real world shells support this feature, you may decide to [[ignore]] the warning.\n\n### Related resources:\n\n* Help by adding links to BashFAQ, StackOverflow, man pages, POSIX, etc!\n\n[Source](https://github.com/koalaman/shellcheck/wiki/SC3043)"},{"id":"shellcheck_SC3044","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"In POSIX sh, `declare` is undefined.","description":"In POSIX sh, `declare` is undefined.","explanation":"## In POSIX sh, `declare` is undefined.\n\n### Problematic code:\n\n```sh\n#!/bin/sh\ndeclare var=\"value\"\n```\n\nor\n\n```sh\n#!/bin/sh\ndeclare -r readonly\n```\n\nor\n\n```sh\n#!/bin/sh\ndeclare ...\n```\n\n### Correct code:\n\nIf assigning a simple variable outside of a function, skip `declare` all together:\n\n```sh\nvar=\"value\"\n```\n\nIf declaring a variable read-only:\n```\nvar=value\nreadonly var\n```\n\nIf you are unable to find a suitable replacement, consider switching to a shell that supports `declare`:\n\n```sh\n#!/bin/bash\ndeclare ...\n```\n\nIndexed arrays, associative arrays, local variables, namerefs, and integer variables are not supported in POSIX sh. Either write around them, or switch to a shell that supports them.\n\n### Rationale:\n\nThe `declare` command is non-standard, and most of its functionality is not available across shells.\n\nEither find a POSIX replacement, or switch to a shell that is guaranteed to support them.\n\n\n### Exceptions:\n\nIf your `declare` command is guarded by a check of the shell version, such as inspecting `$BASH_VERSION`, you can ignore this message.\n\n### Related resources:\n\n* Help by adding links to BashFAQ, StackOverflow, man pages, POSIX, etc!\n[Source](https://github.com/koalaman/shellcheck/wiki/SC3044)"},{"id":"shellcheck_SC3045","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"In POSIX sh, some-command-with-flag is undefined.","description":"In POSIX sh, some-command-with-flag is undefined.","explanation":"## In POSIX sh, some-command-with-flag is undefined.\n\n(or \"In dash, ... is not supported.\" when using `dash`)\n\n### Problematic code:\n\nShellCheck has noticed you're using flags for commands that don't necessarily support them. Some examples:\n\n```sh\n#!/bin/sh\nread -e     # Using libreadline\nexport -f   # Exporting functions\nulimit -v   # Setting vspace limits\nwait   -n   # Waiting for a single process\n```\n\n### Correct code:\n\nThere are generally no simple rewrites. The easiest solution is instead to change the shebang and switch to a shell that *does* support the features you want, such as `bash`.\n\nAlternatively, look up how to do what you want to do in POSIX sh.\n\n### Rationale:\n\nExternal commands (`grep`, `ls`, `find`) invoke a binary on the system and therefore accept the same flags from all shells.\n\nHowever, some commands are instead built into the shell and therefore accept different flags depending on which shell is running them.\n\nYou have specified `sh` or `dash` in the shebang, but the flags you are using only works when it's executed in e.g. `bash`. You should either explicitly declare that the script requires `bash` to run, or you should only use features that work on all shells. \n\n### Exceptions:\n\nIf the code is gated on a check of the current shell, you can [[ignore]] this warning.\n\n### Related resources:\n\n* Help by adding links to BashFAQ, StackOverflow, man pages, POSIX, etc!\n\n[Source](https://github.com/koalaman/shellcheck/wiki/SC3045)"},{"id":"shellcheck_SC3046","category":"CodeStyle","level":"Warning","severityLevel":"Warning","enabled":false,"parameters":[],"title":"In POSIX sh, `source` in place of `.` is undefined.","description":"In POSIX sh, `source` in place of `.` is undefined.","explanation":"## In POSIX sh, `source` in place of `.` is undefined.\n\n(or \"In dash, ... is not supported.\" when using `dash`)\n\n### Problematic code:\n\n```sh\n#!/bin/sh\nsource mylib.sh\n```\n\n### Correct code:\n\n```sh\n#!/bin/sh\n. mylib.sh\n```\n\n### Rationale:\n\n`source` is a bash and ksh specific alias for the harder-to-pronounce/search command `.` (\"dot\")\n\nWhen writing for `dash` or `sh`, use `.` instead.\n\n### Exceptions:\n\nIf you only intend to target shells that supports this feature, you can change\nthe shebang to a shell that guarantees support, or [[ignore]] this warning.\n\nYou can use `# shellcheck disable=SC3000-SC4000` to ignore all such compatibility\nwarnings.\n\n### Related resources:\n\n* Help by adding links to BashFAQ, StackOverflow, man pages, POSIX, etc!\n\n[Source](https://github.com/koalaman/shellcheck/wiki/SC3046)"}],"pagination":{"cursor":"NDAw","limit":100,"total":411}}